<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Mr.ou`s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Mr.ou&#96;s Blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Mr.ou&#96;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Mr.ou">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Mr.ou`s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mr.ou`s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-学习笔记之Redis学习（一）：Redis介绍、单机版的安装、数据类型的介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BRedis%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARedis%E4%BB%8B%E7%BB%8D%E3%80%81%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time datetime="2020-07-20T15:04:55.000Z" itemprop="datePublished">2020-07-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Redis/">Redis</a>►<a class="article-category-link" href="/categories/Redis/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BRedis%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARedis%E4%BB%8B%E7%BB%8D%E3%80%81%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D/">Redis学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、Redis-介绍"><a href="#一、Redis-介绍" class="headerlink" title="一、Redis 介绍"></a>一、Redis 介绍</h1><h2 id="1、Redis-简介"><a href="#1、Redis-简介" class="headerlink" title="1、Redis  简介"></a>1、Redis  简介</h2><p>Remote Dictionary Server(Redis)是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。<br>它通常被称为数据结构服务器，因为值（value）可以是 <strong>字符串(String), 哈希(Map),列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</strong></p>
<h2 id="2、Redis-的特点"><a href="#2、Redis-的特点" class="headerlink" title="2、Redis  的特点"></a>2、Redis  的特点</h2><p>（1） 支持多种数据结构，如 string(字符串)、 list(双向链表)、dict(hash 表)、set(集合)、zset(排序 set)、hyperloglog(基数估算)<br>（2）支持持久化操作，可以进行 aof 及 rdb 数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。<br>（3）支持通过 Replication 进行数据复制，通过 master-slave 机制，可以实时进行数据的<br>同步复制，支持多级复制和增量复制，master-slave 机制是 Redis 进行 HA 的重要手段。<br>（4）单进程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。</p>
<h1 id="二、安装-Redis-单机版"><a href="#二、安装-Redis-单机版" class="headerlink" title="二、安装 Redis  单机版"></a>二、安装 Redis  单机版</h1><p>本次是在Linux环境下安装Redis，如果没有安装Linux，请安装一下，教程点<a href="/2020/07/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ALinux%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D%E3%80%81Xshell%E7%BB%88%E7%AB%AF%E7%9A%84%E5%AE%89%E8%A3%85/" title="这里">这里</a>。</p>
<p>本次介绍的Redis版本为：redis-3.0.0.tar.gz<br>redis 的版本：副版本号奇数版本号是测试版，不建议在生产环境中使用。偶数版本时稳定版建议在生产环境中使用。<br>3.0 版本更新比较大。集成了集群技术</p>
<p>下载链接在这里：<br>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1M5Vgh0Ev4PfUka5rq_NdeQ">https://pan.baidu.com/s/1M5Vgh0Ev4PfUka5rq_NdeQ</a><br>提取码：qljm</p>
<h2 id="1、安装gcc"><a href="#1、安装gcc" class="headerlink" title="1、安装gcc"></a>1、安装gcc</h2><p>需要在 linux 系统中安装 gcc，命令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc-c++</span><br></pre></td></tr></table></figure>
<h2 id="2、上传Redis并且解压"><a href="#2、上传Redis并且解压" class="headerlink" title="2、上传Redis并且解压"></a>2、上传Redis并且解压</h2><p>我们在root目录下的temp文件夹中上传并且解压Redis。<br>如果不熟悉上传和基本命令，就去点击<a href="/2020/07/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E5%8D%A1%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E9%85%8D%E7%BD%AEJDK%E3%80%81%E4%BB%A5%E5%8F%8Atomcat%E7%9A%84%E5%AE%89%E8%A3%85/" title="这里">这里</a>学习文件上传，基本命令在这片文章的上一节。</p>
<p>解压命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf redis-3.0.0.tar.gz </span><br></pre></td></tr></table></figure>
<h2 id="3、编译、安装Redis"><a href="#3、编译、安装Redis" class="headerlink" title="3、编译、安装Redis"></a>3、编译、安装Redis</h2><p>解压完毕之后我们进入到解压后的Redis目录下，使用make命令对redis进行编译，编译成功之后，在redis的根目录下在执行安装命令进行安装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编译命令  make</span><br><span class="line">安装命令  make install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis</span><br></pre></td></tr></table></figure>
<p>意思就是安装在后面给定参数的目录下，没有这个目录就自动创建。<br>执行完毕之后进入到安装目录的bin目录下。<br><img src="https://img-blog.csdnimg.cn/20200720220547913.png" alt="在这里插入图片描述"><br>出现上图就编译成功了。。。。进行下一步安装<br>安装成功之后如下所示：<br><img src="https://img-blog.csdnimg.cn/20200720221040903.png" alt="在这里插入图片描述"></p>
<h2 id="4、启动Redis"><a href="#4、启动Redis" class="headerlink" title="4、启动Redis"></a>4、启动Redis</h2><p>Redis的启动分为前端启动和后端启动。</p>
<h3 id="4-1、前端启动"><a href="#4-1、前端启动" class="headerlink" title="4.1、前端启动"></a>4.1、前端启动</h3><p>去redis的安装目录的bin 目录下执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin</span><br><span class="line"> .&#x2F;redis-server     启动redis</span><br><span class="line"> （ctrl+c）退出 redis</span><br></pre></td></tr></table></figure>
<p>启动成功会看见一个Redis的图标。<br><img src="https://img-blog.csdnimg.cn/20200720221348541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="4-2、后端启动"><a href="#4-2、后端启动" class="headerlink" title="4.2、后端启动"></a>4.2、后端启动</h3><p>停止Redis，我们发现在前端启动不太方便，无法写其他命令，因此我们得修改一下启动方式，将启动方式改为后端启动。</p>
<p>进入到解压后的Redis目录下，进行以下操作：<br><strong>（1）先将 redis 解压目录下的 redis.conf 文件拷贝到 安装好的 redis 的 bin 目录下</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;root&#x2F;temp&#x2F;redis-3.0.0</span><br><span class="line"></span><br><span class="line">命令：cp redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin</span><br></pre></td></tr></table></figure>
<p><strong>（2）修改拷贝过来的 redis.conf 配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进入到cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin</span><br><span class="line">命令：vim redis.conf</span><br><span class="line"></span><br><span class="line">将里面的daemonize的no 改为 yes</span><br><span class="line">然后保存退出</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200720221739609.png" alt="在这里插入图片描述"></p>
<p><strong>（3）再次启动 redis</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在 bin 目录下执行命令：</span><br><span class="line">.&#x2F;redis-server redis.conf</span><br></pre></td></tr></table></figure>
<p><strong>（4）查看 redis 启动是否成功</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入命令：ps aux|grep redis</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200720221955612.png" alt="在这里插入图片描述"><br>如果过启动成功了，那么Redis的线程就会如上图所示。</p>
<p><strong>（5）测试 redis</strong><br>在 bin 目录下启动 redis 自带的客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> .&#x2F;redis-cli</span><br><span class="line">常见 redis 命令：</span><br><span class="line">ping---&gt;pong</span><br><span class="line">Ctrl+C退出</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200720222258555.png" alt="在这里插入图片描述"><br><strong>（6）关闭 redis 的命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;redis-cli shutdown</span><br></pre></td></tr></table></figure>

<h1 id="三、Redis数据类型介绍"><a href="#三、Redis数据类型介绍" class="headerlink" title="三、Redis数据类型介绍"></a>三、Redis数据类型介绍</h1><h2 id="1、String-字符串"><a href="#1、String-字符串" class="headerlink" title="1、String( 字符串)"></a>1、String( 字符串)</h2><p>Redis 字符串是字节序列。Redis 字符串是二进制安全的，这意味着他们有一个已知的长度没有任何特殊字符终止，所以你可以存储任何东西，512 兆为上限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">redis 127.0.0.1:6379&gt; SET name kevin</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; GET name</span><br><span class="line">&quot;kevin&quot;</span><br></pre></td></tr></table></figure>
<p><strong>（1）incr：</strong> 让当前键值以 1 的数量递增，并返回递增后的值</p>
<p><strong>（2）incrby：</strong> 可以指定参数一次增加的数值，并返回递增后的值，(原来的num是2，加10之后变为12)</p>
<p><strong>（3）decr：</strong> 让当前键值以 1 的数量递减 并返回递减后的值</p>
<p><strong>（4）decrby：</strong> 可以指定参数一次递减的数值，并返回递减后的值</p>
<p><strong>（5）incrbyfloat：</strong> 可以递增一个双精度浮点数<br>以上三种方法和上面相加递增是一样的用法。</p>
<p><strong>（6）append：</strong> 作用是向键值的末尾追加 value。如果键不存在则将该键的值设置为 value。返回值是追加后字符串的总长度。<br><img src="https://img-blog.csdnimg.cn/20200720222749384.png" alt="在这里插入图片描述"><br><strong>（7）mget/mset</strong>作用与 get/set 相似，不过 mget/mset 可以同时获得/设置多个键的键值。这两个方法是批量设置和获取键值对。<br><img src="https://img-blog.csdnimg.cn/20200720222844792.png" alt="在这里插入图片描述"><br><strong>（8）del ：根据 key 来删除 value</strong><br><img src="https://img-blog.csdnimg.cn/20200720223021988.png" alt="在这里插入图片描述"><br><strong>（9）flushdb： 清除当前库的所有数据</strong><br><img src="https://img-blog.csdnimg.cn/20200720223042407.png" alt="在这里插入图片描述"></p>
<h2 id="2、Hash-hash-表"><a href="#2、Hash-hash-表" class="headerlink" title="2、Hash(hash  表)"></a>2、Hash(hash  表)</h2><p><img src="https://img-blog.csdnimg.cn/20200720223251751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>Redis 的哈希是键值对的集合。<br>Redis 的哈希值是字符串字段和字符串值之间的映射，因此它们被用来表示对象</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">redis 127.0.0.1:6379&gt; HSET key field value</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; HGET key field</span><br><span class="line">value</span><br></pre></td></tr></table></figure>
<p><strong>（1）hset：</strong> 存储一个哈希键值对的集合<br>基本格式： hset key field value  —–表示的是在key的field下设置一个为“value”的值。<br><img src="https://img-blog.csdnimg.cn/20200720223407790.png" alt="在这里插入图片描述"><br><strong>（2）hget</strong>：获取一个哈希键的值<br>基本格式：hget key field</p>
<p><strong>（3）hmset</strong>： 存储一个或多个哈希是键值对的集合<br>基本格式：hmset key field1 value1 ……fieldN keyN<br><img src="https://img-blog.csdnimg.cn/20200720223533543.png" alt="在这里插入图片描述"><br><strong>（4）hmget</strong>： 获取多个指定的键的值<br>基本格式：hmget key field1 … fieldN</p>
<p><strong>（5）hexists</strong>：判断哈希表中的字段名是否存在，如果存在返回 1 ，否则返回 0<br>基本格式： hexists key field<br><img src="https://img-blog.csdnimg.cn/20200720223642597.png" alt="在这里插入图片描述"><br><strong>（6）hdel</strong>： 删除一个或多个字段<br>基本格式：hdel key field<br><img src="https://img-blog.csdnimg.cn/2020072022373480.png" alt="在这里插入图片描述"><br><strong>（7）hgetall</strong>：获取一个哈希是键值对的集合<br>基本格式：hgetall key<br><img src="https://img-blog.csdnimg.cn/20200720223842172.png" alt="在这里插入图片描述"><br><strong>（8）hvals</strong>： 只返回字段值<br>基本格式：hvals key<br><img src="https://img-blog.csdnimg.cn/20200720223922934.png" alt="在这里插入图片描述"><br><strong>（9）hkeys</strong>： 只返回字段名<br>基本格式： hkeys key<br><img src="https://img-blog.csdnimg.cn/20200720224022331.png" alt="在这里插入图片描述"><br><strong>（10）hlen</strong>： 返回 key 的 hash 的元素个数<br>基本格式： hlen key<br><img src="https://img-blog.csdnimg.cn/20200720224054849.png" alt="在这里插入图片描述"><br>这里是因为user下有两个属性 username和userage</p>
<h2 id="3、List-链表"><a href="#3、List-链表" class="headerlink" title="3、List( 链表)"></a>3、List( 链表)</h2><p><img src="https://img-blog.csdnimg.cn/20200720224157124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Redis 的链表是简单的字符串列表，排序插入顺序。您可以添加元素到 Redis 的列表的头部或尾部<br>Lpush：表示的是向链表的左添加，也就是向链表的头添加；<br>Rpush：表示的是向链表的右添加，也就是向链表的尾添加；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush tutoriallist redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush tutoriallist mongodb</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush tutoriallist rabitmq</span><br><span class="line">(integer) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange tutoriallist 0 10</span><br><span class="line">1) &quot;rabitmq&quot;</span><br><span class="line">2) &quot;mongodb&quot;</span><br><span class="line">3) &quot;redis</span><br></pre></td></tr></table></figure>
<p>拿以上的前三句来解释：执行第一句的时候，相当于在图中的第三个Value添加了redis，然后执行第二句的时候，就在第二个Value处添加了mongodb，然后执行第三句的时候，就在第一个Value出添加了rabitmq，相当于就是左添加。所以执行第四句遍历的时候，从左往右遍历出来的顺序就是那样了。<br>如果第五句执行(rpush tutoriallist java),那么就是在redis的后面。也就是第四个Value处添加了java。</p>
<p><strong>（1）lpush key value</strong>： 向链表左侧添加<br><img src="https://img-blog.csdnimg.cn/20200720224613808.png" alt="在这里插入图片描述"><br><strong>（2）rpush key value</strong>： 向链表右侧添加</p>
<p><strong>（3）lpop key</strong>： 从左边移出一个元素<br>                    就是从最左边的那个节点剔除掉。<br><img src="https://img-blog.csdnimg.cn/20200720224708980.png" alt="在这里插入图片描述"><br><strong>（4）rpop key</strong>： 从右边移出一个元素<br>                    就是从最右边的那个节点剔除掉。<br><img src="https://img-blog.csdnimg.cn/20200720224733425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>（5）llen key</strong>： 返回链表中元素的个数 相当于关系型数据库中 select count(*)<br><img src="https://img-blog.csdnimg.cn/20200720224803187.png" alt="在这里插入图片描述"><br><strong>（6）lrange key start end lrange</strong>： 命令将返回索引从 start 到 stop 之间的所有元素。Redis 的列表起始索引为 0。<br><img src="https://img-blog.csdnimg.cn/20200720224836622.png" alt="在这里插入图片描述"><br>lrange也支持负索引 lrange nn -2 -1<br>如：-1 表示最右边第一个元素 ，-2 表示最右边第二个元素，依次类推。<br><img src="https://img-blog.csdnimg.cn/20200720224851644.png" alt="在这里插入图片描述"><br><strong>（7）lindex key indexnumber</strong>如果要将列表类型当做数组来用，lindex 命令是必不可少的。<br><img src="https://img-blog.csdnimg.cn/20200720224923461.png" alt="在这里插入图片描述"><br>lindex 命令用来返回指定索引的元素，索引从 0 开始，如果是负数表示从右边开始计算的索引，最右边元素的索引是-1。</p>
<p><strong>（8）lset key indexnumber value</strong>： 是另一个通过索引操作列表的命令，它会将索引为 index的元素赋值为 value，原来的值会被覆盖。<br><img src="https://img-blog.csdnimg.cn/20200720225024505.png" alt="在这里插入图片描述"></p>
<h2 id="4、Set-集合"><a href="#4、Set-集合" class="headerlink" title="4、Set( 集合)"></a>4、Set( 集合)</h2><p><img src="https://img-blog.csdnimg.cn/20200720225053826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>Redis 的集合是字符串的无序集合。<br>在Set集合当中，是不允许有重复的。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd tutoriallist redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd tutoriallist mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd tutoriallist rabitmq</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd tutoriallist rabitmq</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; smembers tutoriallist</span><br><span class="line">1) &quot;rabitmq&quot;</span><br><span class="line">2) &quot;mongodb&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></figure>
<p><strong>（1）sadd key value</strong>：<br>添加一个 string 元素到,key 对应的 set 集合中，<br>成功返回 1,如果元素已经在集合中返回 0<br><img src="https://img-blog.csdnimg.cn/20200720225156556.png" alt="在这里插入图片描述"></p>
<p><strong>（2）scard key</strong>： 返回 set 的元素个数，如果 set 是空或者 key 不存在返回 0<br><img src="https://img-blog.csdnimg.cn/20200720225250924.png" alt="在这里插入图片描述"><br><strong>（3）smembers key</strong>： 返回 key 对应 set 的所有元素，结果是无序的<br><img src="https://img-blog.csdnimg.cn/20200720225314417.png" alt="在这里插入图片描述"><br>但是不保证有序。</p>
<p><strong>（4）sismember key value</strong>： 判断 value 是否在 set 中，存在返回 1，0 表示不存在或者 key 不存在<br><img src="https://img-blog.csdnimg.cn/20200720225351398.png" alt="在这里插入图片描述"></p>
<p><strong>（5）srem key value</strong>：<br>从 key 对应 set 中移除给定元素，成功返回 1，<br>如果 value 在集合中不存在或者 key 不存在返回 0</p>
<h2 id="5、SortedSet-有序集合-zset"><a href="#5、SortedSet-有序集合-zset" class="headerlink" title="5、SortedSet( 有序集合)zset"></a>5、SortedSet( 有序集合)zset</h2><p> Redis 的有序集合类似于 Redis 的集合，字符串不重复的集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd tutoriallist 0 redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd tutoriallist 0 mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd tutoriallist 0 rabitmq</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd tutoriallist 0 rabitmq</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; ZRANGEBYSCORE tutoriallist 0 1000</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;mongodb&quot;</span><br><span class="line">3) &quot;rabitmq&quot;</span><br></pre></td></tr></table></figure>
<p><strong>（1）zadd key score value</strong>： 将一个或多个 value 及其 socre 加入到 set 中<br><img src="https://img-blog.csdnimg.cn/20200720225539875.png" alt="在这里插入图片描述"><br><strong>（2）zrange key start end **：0 和-1 表示从索引为 0 的元素到最后一个元素（同 LRANGE 命令相似）<br><img src="https://img-blog.csdnimg.cn/20200720225605922.png" alt="在这里插入图片描述"><br>**（3）zrange key 0 -1 withscores **<br>也可以连同 score 一块输出，使用 WITHSCORES 参数<br><img src="https://img-blog.csdnimg.cn/20200720225632693.png" alt="在这里插入图片描述"><br>**（4）zremrangebyscore key start end</strong>： 可用于范围删除操作<br><img src="https://img-blog.csdnimg.cn/20200720225706584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>这里只介绍了5种数据类型，后面会持续更新。。。</strong></p>
<p>上一篇学习：学习笔记之</p>
<p>下一篇学习：学习笔记之Redis学习（二）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BRedis%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARedis%E4%BB%8B%E7%BB%8D%E3%80%81%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D/" data-id="ckf1vxjfg000dk0uk1ezp996p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis%E5%AD%A6%E4%B9%A0/" rel="tag">Redis学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础常见面试题整理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/20/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" class="article-date">
  <time datetime="2020-07-20T12:38:40.000Z" itemprop="datePublished">2020-07-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>►<a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/20/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">Java基础常见面试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1、JDK和JRE有什么区别？"><a href="#1、JDK和JRE有什么区别？" class="headerlink" title="1、JDK和JRE有什么区别？"></a>1、JDK和JRE有什么区别？</h1><p>JDK就是Java Development Kit 。JDK是面向开发人员使用的SDK，它提供了Java的开发环境和运行环境。SDK是Software Development Kit 一般指软件开发包，可以包括函数库、编译程序等。</p>
<p>JRE是Java Runtime Enviroment是指Java的运行环境，是面向Java程序的使用者，而不是开发者。</p>
<h1 id="2、-和-equals-的区别是什么？"><a href="#2、-和-equals-的区别是什么？" class="headerlink" title="2、== 和 equals 的区别是什么？"></a>2、== 和 equals 的区别是什么？</h1><p>（1）== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。<br>(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)</p>
<p>（2）equals() : 它的作用也是判断两个对象是否相等。<br>但它一般有两种使用情况：<br>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</p>
<p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p>
<h1 id="3、两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#3、两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="3、两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？"></a>3、两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</h1><p>如果两个对象相等，则hashcode一定也是相同的</p>
<p>两个对象相等，对两个对象分别调用equals方法都返回true</p>
<p>两个对象有相同的hashcode值，它们也不一定是相等的</p>
<p>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</p>
<p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
<h1 id="4、final-在-java-中有什么作用？"><a href="#4、final-在-java-中有什么作用？" class="headerlink" title="4、final 在 java 中有什么作用？"></a>4、final 在 java 中有什么作用？</h1><p>用于修饰类、属性和方法；</p>
<p>被final修饰的类不可以被继承<br>被final修饰的方法不可以被重写<br>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</p>
<h1 id="5、java-中的-Math-round-1-5-等于多少？-Math-round-1-5-等于多少？"><a href="#5、java-中的-Math-round-1-5-等于多少？-Math-round-1-5-等于多少？" class="headerlink" title="5、java 中的 Math.round(1.5) 等于多少？ Math.round(-1.5) 等于多少？"></a>5、java 中的 Math.round(1.5) 等于多少？ Math.round(-1.5) 等于多少？</h1><p>Math.round(1.5)等于2，Math.round(-1.5)等于-1，四舍五入是在原来的基础上加上0.5向下取整。</p>
<h1 id="6、说出以下代码的输出结果。"><a href="#6、说出以下代码的输出结果。" class="headerlink" title="6、说出以下代码的输出结果。"></a>6、说出以下代码的输出结果。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> public class A &#123;</span><br><span class="line">   static&#123;</span><br><span class="line">      System.out.println(&quot;static in class A&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public A()&#123;</span><br><span class="line">      System.out.println(&quot;class A&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> public class SubA extends A &#123;</span><br><span class="line">   static &#123;</span><br><span class="line">      System.out.println(&quot;static in class SubA&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public SubA() &#123;</span><br><span class="line">      super();</span><br><span class="line">      System.out.println(&quot;class SubA&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public SubA(String sa) &#123;</span><br><span class="line">      System.out.println(&quot;class SubA &quot; + sa);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> public class StaticTest &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      SubA subA1 &#x3D; new SubA(&quot;111111&quot;);</span><br><span class="line">      SubA subA2 &#x3D; new SubA(&quot;222222&quot;);</span><br><span class="line">      SubA subA3 &#x3D; new SubA(&quot;333333&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输出结果为：</span><br><span class="line"> static in class A</span><br><span class="line">static in class SubA</span><br><span class="line">class A</span><br><span class="line">class SubA 111111</span><br><span class="line">class A</span><br><span class="line">class SubA 222222</span><br><span class="line">class A</span><br><span class="line">class SubA 333333</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong><br>子类构造方法调用规则：<br>（1）如果子类的构造方法中没有通过 super 显式调用父类的有参构造方法，<br>        也没有通过 this 显式调用自身的其他构造方法，则系统会默认先调用父类的无参构造方法。<br>        这种情况下，写不写 super(); 语句，效果是一样的<br>（2）如果子类的构造方法中通过 super 显式调用父类的有参构造方法，<br>         将执行父类相应的构造方法，不执行父类无参构造方法<br>（3）如果子类的构造方法中通过 this 显式调用自身的其他构造方法，将执行类中相应的构造方法<br>（4）如果存在多级继承关系，在创建一个子类对象时，以上规则会多次向更高一级父类应用，<br>         一直到执行顶级父类 Object 类的无参构造方法为止<br><strong>结论：</strong><br>类的实例化方法调用顺序：<br>类加载器实例化时进行的操作步骤：加载 -&gt; 连接 -&gt; 初始化<br>（1）父类静态代变量<br>（2）父类静态代码块<br>（3）子类静态变量<br>（4）子类静态代码块<br>（5）父类非静态变量（父类实例成员变量）<br>（6）父类构造函数<br>（7）子类非静态变量（子类实例成员变量）<br>（8）子类构造函数</p>
<h1 id="7、Java中，基本的数据类型有哪些？"><a href="#7、Java中，基本的数据类型有哪些？" class="headerlink" title="7、Java中，基本的数据类型有哪些？"></a>7、Java中，基本的数据类型有哪些？</h1><p>基本数据类型有byte、short、int、long、float、double、char、boolean八种基本数据类型。<br>byte：1个字节，8位<br>short：2个字节，16位<br>int：4个字节，32位<br>long：8个字节，64位<br>float：4个字节，32位<br>double：8个字节，64位<br>boolean：逻辑上理解是占用 1位，但是实际中会考虑计算机高效存储因素<br>char：2个字节，16位</p>
<h1 id="8、String-属于基础的数据类型吗？"><a href="#8、String-属于基础的数据类型吗？" class="headerlink" title="8、String 属于基础的数据类型吗？"></a>8、String 属于基础的数据类型吗？</h1><p>不属于，Java中基本数据类型只有byte、short、int、long、float、double、char、boolean八种数据类型。<br>String在Java中属于对象，底层实现是char数组，使用final修饰。</p>
<h1 id="9、switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上？"><a href="#9、switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上？" class="headerlink" title="9、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？"></a>9、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？</h1><p>在Java5以前，switch(expr)中的expr只能是byte、char、short、int四种数据类型。从Java5以后引入了枚举，expr可以是enum类型，Java7开始，expr就可以支持String字符串了，但是目前还不能使用long类型的。</p>
<h1 id="10、java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#10、java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="10、java 中操作字符串都有哪些类？它们之间有什么区别？"></a>10、java 中操作字符串都有哪些类？它们之间有什么区别？</h1><p>Java中操作字符串的类有String、StringBuffer、StringBuilder三个类。<br><strong>三者的相同点：</strong><br>（1）都可以存储和操作字符串；<br>（2）底层都使用了final修饰，不能被继承。<br>（3）提供了API相似。<br><strong>三者的区别：</strong><br>（1）String是不可变字符序列，String内容是不能被改变的；<br>（2）StringBuffer和StringBuilder是可变字符序列，他们都可以对字符串内容进行修改，<br>   并且修改之后的内存地址不会发生改变；<br>（3）StringBuilder是JDK1.5的，效率高，但是它的线程不安全，<br>          StringBuffer是JDK1.0的，效率低，但是它是线程安全的(方法加了Synchronized)。</p>
<p><strong>对于三者使用的总结</strong></p>
<p>如果要操作少量的数据用 = String</p>
<p>单线程操作字符串缓冲区 下操作大量数据 = StringBuilder</p>
<p>多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</p>
<h1 id="11、String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#11、String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="11、String str=”i”与 String str=new String(“i”)一样吗？"></a>11、String str=”i”与 String str=new String(“i”)一样吗？</h1><p>不一样，因为内存的分配方式不一样，String str = “i”的方式，Java虚拟机会将其分配到常量池中；而String str = new String(“i”) 则会被分配到堆内存中。</p>
<p>提问：String s = new String(“abc”)创建了几个对象呢？<br>答案是两个对象，一个是静态区的”abc”，另外一个是用new创建在堆上的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str1 &#x3D; &quot;hello&quot;; &#x2F;&#x2F;str1指向静态区</span><br><span class="line">String str2 &#x3D; new String(&quot;hello&quot;);  &#x2F;&#x2F;str2指向堆上的对象</span><br><span class="line">String str3 &#x3D; &quot;hello&quot;;</span><br><span class="line">String str4 &#x3D; new String(&quot;hello&quot;);</span><br><span class="line">System.out.println(str1.equals(str2)); &#x2F;&#x2F;true</span><br><span class="line">System.out.println(str2.equals(str4)); &#x2F;&#x2F;true</span><br><span class="line">System.out.println(str1 &#x3D;&#x3D; str3); &#x2F;&#x2F;true</span><br><span class="line">System.out.println(str1 &#x3D;&#x3D; str2); &#x2F;&#x2F;false</span><br><span class="line">System.out.println(str2 &#x3D;&#x3D; str4); &#x2F;&#x2F;false</span><br><span class="line">System.out.println(str2 &#x3D;&#x3D; &quot;hello&quot;); &#x2F;&#x2F;false</span><br><span class="line">str2 &#x3D; str1;</span><br><span class="line">System.out.println(str2 &#x3D;&#x3D; &quot;hello&quot;); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
<h1 id="13、如何将字符串反转？"><a href="#13、如何将字符串反转？" class="headerlink" title="13、如何将字符串反转？"></a>13、如何将字符串反转？</h1><p>使用StringBuffer或者StringBuilder中的reverse()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; StringBuffer reverse</span><br><span class="line"> StringBuffer stringBuffer &#x3D; new StringBuffer();</span><br><span class="line"> stringBuffer. append(&quot;abcdefg&quot;);</span><br><span class="line"> System. out. println(stringBuffer. reverse()); &#x2F;&#x2F; gfedcba</span><br><span class="line">&#x2F;&#x2F; StringBuilder reverse</span><br><span class="line"> StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line"> stringBuilder. append(&quot;abcdefg&quot;);</span><br><span class="line"> System. out. println(stringBuilder. reverse()); &#x2F;&#x2F; gfedcba</span><br></pre></td></tr></table></figure>
<h1 id="14、String-类的常用方法都有那些？"><a href="#14、String-类的常用方法都有那些？" class="headerlink" title="14、String 类的常用方法都有那些？"></a>14、String 类的常用方法都有那些？</h1><p>（1）String 类的常用方法都有那些？<br>（2）indexOf()：返回指定字符的索引。<br>（3）charAt()：返回指定索引处的字符。<br>（4）replace()：字符串替换。<br>（5）trim()：去除字符串两端空白。<br>（6）split()：分割字符串，返回一个分割后的字符串数组。<br>（7）getBytes()：返回字符串的 byte 类型数组。<br>（8）length()：返回字符串长度。<br>（9）toLowerCase()：将字符串转成小写字母。<br>（10）toUpperCase()：将字符串转成大写字符。<br>（11）substring()：截取字符串。<br>（12）equals()：字符串比较。</p>
<h1 id="15、HashMap中使用String做key有什么好处？"><a href="#15、HashMap中使用String做key有什么好处？" class="headerlink" title="15、HashMap中使用String做key有什么好处？"></a>15、HashMap中使用String做key有什么好处？</h1><pre><code>    HashMap内部实现是通过key的hashcode来确定value的存储位置，因为字符串是不可变的，并且使用字符串时会在字符串常量池中进行缓存，所以当创建字符串的时候，hashcode会被缓存下来，不需要再次计算，所以相比于其他对象来说快一些。</code></pre>
<h1 id="16、抽象类必须要有抽象方法吗？"><a href="#16、抽象类必须要有抽象方法吗？" class="headerlink" title="16、抽象类必须要有抽象方法吗？"></a>16、抽象类必须要有抽象方法吗？</h1><p>抽象类不一定要有抽象方法，但是抽象方法必要要有抽象类。</p>
<h1 id="17、普通类和抽象类有哪些区别？"><a href="#17、普通类和抽象类有哪些区别？" class="headerlink" title="17、普通类和抽象类有哪些区别？"></a>17、普通类和抽象类有哪些区别？</h1><p>（1）抽象类不能被实例化；<br>（2）抽象类可以有抽象方法，但是普通类没有；<br>（3）含有抽象方法的类必须是抽象类；<br>（4）抽象方法不能被声明为静态；<br>（5）抽象方法不能被private；<br>（6）抽象方法不能被final修饰。</p>
<h1 id="18、抽象类能使用-final-修饰吗？"><a href="#18、抽象类能使用-final-修饰吗？" class="headerlink" title="18、抽象类能使用 final 修饰吗？"></a>18、抽象类能使用 final 修饰吗？</h1><p>不能，因为被final修饰的类不能被继承，而定义抽象类就是为了让其他类去继承的，如果使用final修饰了就矛盾了，因此不能被final修饰。</p>
<h1 id="19、接口和抽象类有什么区别？"><a href="#19、接口和抽象类有什么区别？" class="headerlink" title="19、接口和抽象类有什么区别？"></a>19、接口和抽象类有什么区别？</h1><p>（1）实现：抽象类的子类使用extends来继承，而接口就必须使用implements来实现接口；<br>（2）构造函数：抽象类可以有构造函数，但是接口没有；<br>（3）实现数量：类可以实现很多个接口，但是只能继承一个抽象类；<br>（4）访问修饰符：接口的方法默认使用的是public修饰，而抽象类中的方法可以是任意访问修饰符；</p>
<h1 id="20、内部类有哪几种？详细说明一下。"><a href="#20、内部类有哪几种？详细说明一下。" class="headerlink" title="20、内部类有哪几种？详细说明一下。"></a>20、内部类有哪几种？详细说明一下。</h1><p>内部类的定义：可以将一个类的定义放在另外一个类的定义内部；<br>内部类的种类：成员内部类、局部内部类、匿名内部类、静态内部类。</p>
<p>（1）静态内部类：定义在类内部的静态类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line"></span><br><span class="line">   private static int radius &#x3D; 1;</span><br><span class="line"></span><br><span class="line">   static class StaticInner &#123;</span><br><span class="line">      public void visit() &#123;</span><br><span class="line">         System.out.println(&quot;visit outer static  variable:&quot; + radius);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，new 外部类.静态内部类()，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> Outer.StaticInner inner &#x3D; new Outer.StaticInner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure>
<p>（2）成员内部类：定义在类内部，成员位置上的非静态类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> public class Outer &#123;</span><br><span class="line"></span><br><span class="line">   private static  int radius &#x3D; 1;</span><br><span class="line">   private int count &#x3D;2;</span><br><span class="line"></span><br><span class="line">   class Inner &#123;</span><br><span class="line">      public void visit() &#123;</span><br><span class="line">         System.out.println(&quot;visit outer static  variable:&quot; + radius);</span><br><span class="line">         System.out.println(&quot;visit outer   variable:&quot; + count);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式外部类实例.new 内部类()，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> Outer outer &#x3D; new Outer();</span><br><span class="line">Outer.Inner inner &#x3D; outer.new Inner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure>
<p>（3）局部内部类：定义在方法的内部，就是局部内部类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> public class Outer &#123;</span><br><span class="line"></span><br><span class="line">   private  int out_a &#x3D; 1;</span><br><span class="line">   private static int STATIC_b &#x3D; 2;</span><br><span class="line"></span><br><span class="line">   public void testFunctionClass()&#123;</span><br><span class="line">      int inner_c &#x3D;3;</span><br><span class="line">      class Inner &#123;</span><br><span class="line">         private void fun()&#123;</span><br><span class="line">            System.out.println(out_a);</span><br><span class="line">            System.out.println(STATIC_b);</span><br><span class="line">            System.out.println(inner_c);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Inner  inner &#x3D; new Inner();</span><br><span class="line">      inner.fun();</span><br><span class="line">   &#125;</span><br><span class="line">   public static void testStaticFunctionClass()&#123;</span><br><span class="line">      int d &#x3D;3;</span><br><span class="line">      class Inner &#123;</span><br><span class="line">         private void fun()&#123;</span><br><span class="line">            &#x2F;&#x2F; System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量</span><br><span class="line">            System.out.println(STATIC_b);</span><br><span class="line">            System.out.println(d);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Inner  inner &#x3D; new Inner();</span><br><span class="line">      inner.fun();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，new 内部类()，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> public static void testStaticFunctionClass()&#123;</span><br><span class="line">   class Inner &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   Inner  inner &#x3D; new Inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）匿名内部类：没有名字的内部类，日常开发中使用的比较多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> public class Outer &#123;</span><br><span class="line"></span><br><span class="line">   private void test(final int i) &#123;</span><br><span class="line">      new Service() &#123;</span><br><span class="line">         public void method() &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">               System.out.println(&quot;匿名内部类&quot; );</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;.method();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;匿名内部类必须继承或实现一个已有的接口 </span><br><span class="line">interface Service&#123;</span><br><span class="line">   void method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了没有名字，<strong>匿名内部类还有以下特点：</strong><br>A、匿名内部类必须继承一个抽象类或者实现一个接口。<br>B、匿名内部类不能定义任何静态成员和静态方法。<br>C、当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。<br>D、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">匿名内部类创建方式：</span><br><span class="line"> new 类&#x2F;接口&#123;</span><br><span class="line">      &#x2F;&#x2F;匿名内部类实现部分</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h1 id="21、内部类有哪些使用场景？你在哪些地方使用到了内部类？"><a href="#21、内部类有哪些使用场景？你在哪些地方使用到了内部类？" class="headerlink" title="21、内部类有哪些使用场景？你在哪些地方使用到了内部类？"></a>21、内部类有哪些使用场景？你在哪些地方使用到了内部类？</h1><p>（1）在设计模式中使用静态内部类实现单例模式；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonDemo03 &#123;</span><br><span class="line"></span><br><span class="line">    private static class SingletonClassInstance&#123;</span><br><span class="line">        private static final SingletonDemo03 instance &#x3D; new SingletonDemo03();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonDemo03 getInstance()&#123;</span><br><span class="line">        return SingletonClassInstance.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SingletonDemo03()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）其他的忘记了，，，等记得来的时候再补上0.0</p>
<h1 id="22、Files的常用方法都有哪些？"><a href="#22、Files的常用方法都有哪些？" class="headerlink" title="22、Files的常用方法都有哪些？"></a>22、Files的常用方法都有哪些？</h1><p>（1）Files. exists()：检测文件路径是否存在。<br>（2）Files. createFile()：创建文件。<br>（3）Files. createDirectory()：创建文件夹。<br>（4）Files. delete()：删除一个文件或目录。<br>（5）Files. copy()：复制文件。<br>（6）Files. move()：移动文件。<br>（7）Files. size()：查看文件个数。<br>（8）Files. read()：读取文件。<br>（9）Files. write()：写入文件。</p>
<h1 id="23、Date类常用方法都有哪些？"><a href="#23、Date类常用方法都有哪些？" class="headerlink" title="23、Date类常用方法都有哪些？"></a>23、Date类常用方法都有哪些？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">-----日期类型如何格式化？</span><br><span class="line">      ***************************************************************************************</span><br><span class="line">      DateFormat  sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line">      String s &#x3D; sdf.format(new Date());&#x2F;&#x2F;日期转字符串</span><br><span class="line">      ***************************************************************************************</span><br><span class="line">      -----字符串如何转日期？</span><br><span class="line">      ***************************************************************************************</span><br><span class="line">      DateFormat  sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line">      String s &#x3D; &quot;2019-10-31 22:53:10&quot;;</span><br><span class="line">      Date date &#x3D; sdf.parse(s);</span><br><span class="line">      ***************************************************************************************</span><br><span class="line">      -----如何取得当前年、月、日、时、分、秒、毫秒？</span><br><span class="line">      年：Calendar.getInstance().get(Calendar.YEAR)；</span><br><span class="line">      或者Year.now()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line">      还有LocalDate.now().getYear();&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line"></span><br><span class="line">      月：Calendar.getInstance().get(Calendar.MONTH)+1；</span><br><span class="line">      MonthDay.now().getMonthValue()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line">      LocalDate.now().getMonthValue()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line"></span><br><span class="line">      日：Calendar.getInstance().get(Calendar.DAY_OF_MONTH)；</span><br><span class="line">      MonthDay.now().getDayOfMonth()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line">      LocalDate.now().getDayOfMonth()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line"></span><br><span class="line">      时：Calendar.getInstance().get(Calendar.HOUR_OF_DAY)；</span><br><span class="line">      LocalTime.now().getHour()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line"></span><br><span class="line">      分：Calendar.getInstance().get(Calendar.MINUTE)；</span><br><span class="line">      LocalTime.now().getMinute()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line"></span><br><span class="line">      秒：Calendar.getInstance().get(Calendar.SECOND)；</span><br><span class="line">      LocalTime.now().getSecond()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line"></span><br><span class="line">      毫秒：Calendar.getInstance().get(Calendar.MILLISECOND)；</span><br><span class="line">      ***************************************************************************************</span><br><span class="line">--如何取得从1970年1月1日0时0分0秒到现在的毫秒数？</span><br><span class="line">      System.currentTimeMillis();</span><br><span class="line">      Calendar.getInstance().getTimeInMillis();</span><br><span class="line">--如何格式化日期？</span><br><span class="line">      new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date())；</span><br><span class="line">      &#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line">      LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;))；</span><br></pre></td></tr></table></figure>


<h1 id="24、java-中-IO-流分为几种？"><a href="#24、java-中-IO-流分为几种？" class="headerlink" title="24、java 中 IO 流分为几种？"></a>24、java 中 IO 流分为几种？</h1><p>（1）按照流向可以分为输入流和输出流；<br>（2）按照操作单元划分可以分为字节流和字符流；<br>（3）按照流的角色划分可分为节点流和处理流；</p>
<h1 id="25、BIO、NIO、AIO-有什么区别？"><a href="#25、BIO、NIO、AIO-有什么区别？" class="headerlink" title="25、BIO、NIO、AIO 有什么区别？"></a>25、BIO、NIO、AIO 有什么区别？</h1><p><strong>简答：</strong></p>
<p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>
<p><strong>详细回答：</strong></p>
<p>BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p>
<p>NIO (New I/O): NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。</p>
<p>AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/20/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" data-id="ckf1vxjh70034k0ukc7itcz5y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习笔记之Zookeeper学习（一）：Zookeeper简介、存储结构、监听通知机制、单机版的安装" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BZookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AZookeeper%E7%AE%80%E4%BB%8B%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E3%80%81%E7%9B%91%E5%90%AC%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E3%80%81%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E5%AE%89%E8%A3%85/" class="article-date">
  <time datetime="2020-07-19T15:30:12.000Z" itemprop="datePublished">2020-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Zookeeper/">Zookeeper</a>►<a class="article-category-link" href="/categories/Zookeeper/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BZookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AZookeeper%E7%AE%80%E4%BB%8B%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E3%80%81%E7%9B%91%E5%90%AC%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E3%80%81%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E5%AE%89%E8%A3%85/">学习笔记之Zookeeper学习（二）：Zookeeper集群的安装、启动关闭脚本的编写、常用命令介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、Zookeeper-简介"><a href="#一、Zookeeper-简介" class="headerlink" title="一、Zookeeper 简介"></a>一、Zookeeper 简介</h1><p>Zookeeper 官网： <a target="_blank" rel="noopener" href="http://zookeeper.apache.org/">http://zookeeper.apache.org/</a><br>Zookeeper 是 Apache 的一个分布式服务框架，是 Apache Hadoop 的一个子项目。官方<br>文档上这么解释 Zookeeper，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，<br>如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。<br>简单来说 zookeeper=文件系统+监听通知机制。</p>
<h1 id="二、-Zookeeper-存储结构"><a href="#二、-Zookeeper-存储结构" class="headerlink" title="二、 Zookeeper 存储结构"></a>二、 Zookeeper 存储结构</h1><p><img src="https://img-blog.csdnimg.cn/20200719201812653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="（1）Znode"><a href="#（1）Znode" class="headerlink" title="（1）Znode"></a>（1）Znode</h2><p>在 Zookeeper 中，znode 是一个跟 Unix 文件系统路径相似的节点，可以向节点存储数据或者获取数据。<br>Zookeeper 底层是一套数据结构。这个存储结构是一个树形结构，其上的每一个节点，我们称之为“znode”。<br>Zookeeper 中的数据是按照“树”结构进行存储的。而且 znode 节点还分为 4 中不同的类型。<strong>每一个 znode 默认能够存储 1MB 的数据</strong>（对于记录状态性质的数据来说，够了），可以使用 zkCli 命令，登录到 Zookeeper 上，并通过<strong>ls、create、delete、get、set</strong>等命令操作这些 znode 节点。</p>
<h2 id="（2）Znode-节点类型"><a href="#（2）Znode-节点类型" class="headerlink" title="（2）Znode 节点类型"></a>（2）Znode 节点类型</h2><h3 id="（2-1）-PERSISTENT-持久化目录节点"><a href="#（2-1）-PERSISTENT-持久化目录节点" class="headerlink" title="（2.1） PERSISTENT-持久化目录节点"></a>（2.1） PERSISTENT-持久化目录节点</h3><p>客户端与 zookeeper 断开连接后，该节点依旧存在。</p>
<h3 id="（2-2）-PERSISTENT-SEQUENTIAL-持久化顺序编号目录节点"><a href="#（2-2）-PERSISTENT-SEQUENTIAL-持久化顺序编号目录节点" class="headerlink" title="（2.2） PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点"></a>（2.2） PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点</h3><p>客户端与 zookeeper 断开连接后，该节点依旧存在，只是 Zookeeper 给该节点名称进行顺序编号。</p>
<h3 id="（2-3）-EPHEMERAL-临时目录节点"><a href="#（2-3）-EPHEMERAL-临时目录节点" class="headerlink" title="（2.3） EPHEMERAL-临时目录节点"></a>（2.3） EPHEMERAL-临时目录节点</h3><p>客户端与 zookeeper 断开连接后，该节点被删除。</p>
<h3 id="（2-4）-EPHEMERAL-SEQUENTIAL-临时顺序编号目录节点"><a href="#（2-4）-EPHEMERAL-SEQUENTIAL-临时顺序编号目录节点" class="headerlink" title="（2.4） EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点"></a>（2.4） EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</h3><p>客户端与 zookeeper 断开连接后，该节点被删除，只是 Zookeeper 给该节点名称进行顺序编号。</p>
<h1 id="三、-监听通知机制"><a href="#三、-监听通知机制" class="headerlink" title="三、 监听通知机制"></a>三、 监听通知机制</h1><p>Zookeeper 是使用观察者设计模式来设计的。当客户端注册监听它关心的目录节点时，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，Zookeeper 会通知客户端。</p>
<h1 id="四、-安装-zookeeper（单机版）"><a href="#四、-安装-zookeeper（单机版）" class="headerlink" title="四、 安装 zookeeper（单机版）"></a>四、 安装 zookeeper（单机版）</h1><p>官方资源包可在 <a target="_blank" rel="noopener" href="https://zookeeper.apache.org/releases.html">https://zookeeper.apache.org/</a> 站点中下载。<br>可以去下载最新版，这里我介绍的zookeeper版本为：3.6.0。</p>
<h2 id="1、安装Linux"><a href="#1、安装Linux" class="headerlink" title="1、安装Linux"></a>1、安装Linux</h2><p>如果不知道该怎么安装Linux，<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43246215/article/details/107430831">点击这里</a>。</p>
<h2 id="2、安装JDK"><a href="#2、安装JDK" class="headerlink" title="2、安装JDK"></a>2、安装JDK</h2><p>如果不知道该怎么安装JDK，<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43246215/article/details/107432534">点击这里</a>。<br>并且配置jdk的环境变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk</span><br><span class="line">export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>

<h2 id="3、上传-Zookeeper"><a href="#3、上传-Zookeeper" class="headerlink" title="3、上传 Zookeeper"></a>3、上传 Zookeeper</h2><p>在虚拟机的root目录下新建了一个temp目录，我们将文件上传到temp目录下，如果不知道文件该怎么上传的请学习<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43246215/article/details/107432534">这个笔记</a>。<br>文件上传之后，将文件解压并且拷贝到/usr/local/zookeeper目录下，命令如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost temp]# tar -zxf zookeeper-3.6.0.tar.gz</span><br><span class="line">[root@localhost temp]# cp zookeeper-3.6.0 &#x2F;usr&#x2F;local&#x2F;zookeeper -r</span><br></pre></td></tr></table></figure>
<p>然后可以进入zookeeper目录下使用ls查看目录结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. bin：放置运行脚本和工具脚本，</span><br><span class="line">2. conf：zookeeper 默认读取配置的目录，里面会有默认的配置文件</span><br><span class="line">3. docs：zookeeper 相关的文档</span><br><span class="line">4. lib：zookeeper 核心的 jar</span><br><span class="line">5. logs：zookeeper 日志</span><br></pre></td></tr></table></figure>
<h2 id="4、配置zookeeper"><a href="#4、配置zookeeper" class="headerlink" title="4、配置zookeeper"></a>4、配置zookeeper</h2><p>Zookeeper 在启动时默认的去 conf 目录下查找一个名称为 zoo.cfg 的配置文件。在 zookeeper 应用目录中有子目录 conf。<br>其中有配置文件模板：zoo_sample.cfg，因此我们进入到该目录下将文件拷贝一份并且重新命名，将zookeeper 应用中的配置文件改为 conf/zoo.cfg。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd zookeeper&#x2F;conf</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>
<p>之后便是修改配置文件 zoo.cfg - 设置数据缓存路径，我们先退回到zookeeper的目录下，使用mkdir命令新建一个文件夹data，使用pwd命令获取当前文件的路径，复制路径，然后再进入到conf目录下编辑配置文件 zoo.cfg。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">mkdir data</span><br><span class="line">pwd</span><br><span class="line">cd ..&#x2F;conf</span><br><span class="line">vim zoo.cfg</span><br></pre></td></tr></table></figure>
<p>然后将配置文件作一下修改，然后ESC，保存并退出(:wq)：<br><img src="https://img-blog.csdnimg.cn/20200719204534884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="5、启动Zookeeper"><a href="#5、启动Zookeeper" class="headerlink" title="5、启动Zookeeper"></a>5、启动Zookeeper</h2><p>以上配置完成之后，我们进入到zookeeper/bin目录下，<br>使用以下命令启动zookeeper：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">启动zookeeper：</span><br><span class="line">.&#x2F;zkServer.sh start</span><br><span class="line"></span><br><span class="line">关闭zookeeper：</span><br><span class="line">.&#x2F;zkServer.sh stop</span><br><span class="line"></span><br><span class="line">查看zookeeper状态：</span><br><span class="line">.&#x2F;zkServer.sh status</span><br></pre></td></tr></table></figure>
<p>默认加载配置文件：./zkServer.sh start：默认的会去 conf 目录下加载 zoo.cfg 配置文件。<br>指定加载配置文件：./zkServer.sh start 配置文件的路径。<br>启动成功图为：<br><img src="https://img-blog.csdnimg.cn/20200719205545618.png" alt="在这里插入图片描述"></p>
<h2 id="6、使用客户端连接单机版-Zookeeper"><a href="#6、使用客户端连接单机版-Zookeeper" class="headerlink" title="6、使用客户端连接单机版 Zookeeper"></a>6、使用客户端连接单机版 Zookeeper</h2><p>前提是先成功启动zookeeper，如果启动不成功请详细检查自己哪一步出错了。</p>
<h3 id="6-1、连接方式一"><a href="#6-1、连接方式一" class="headerlink" title="6.1、连接方式一"></a>6.1、连接方式一</h3><p>到zookeeper的bin目录下使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;zkCli.sh</span><br></pre></td></tr></table></figure>
<p>默认连接地址为本机地址，默认连接端口为 2181<br>成功连接之后为：<br><img src="https://img-blog.csdnimg.cn/20200719205836271.png" alt="在这里插入图片描述"><br><strong>按Ctrl+C退出，或者输入命令quit</strong></p>
<h3 id="6-2、连接方式二"><a href="#6-2、连接方式二" class="headerlink" title="6.2、连接方式二"></a>6.2、连接方式二</h3><p>这种方式可以远程调用，这里不做详细介绍，<br>还是在bin目录下执行以下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;zkCli.sh -server ip:port</span><br><span class="line">连接指定 IP 地址与端口</span><br></pre></td></tr></table></figure>
<p>比如说我192.168.15.130的虚拟机下也装了一个zookeeper单机版，那我在启动两个虚拟主机的zookeeper之后，在本机的zookeeper/bin目录下使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;zkCli.sh -server 192.168.15.130:2181</span><br><span class="line">如果130的那台zookeeper的端口还是2181的话就这样写</span><br></pre></td></tr></table></figure>
<h1 id="五、下篇学习预告"><a href="#五、下篇学习预告" class="headerlink" title="五、下篇学习预告"></a>五、下篇学习预告</h1><p>Zookeeper集群的安装<br>Zookeeper常用命令介绍</p>
<p>上一篇学习：<a href="/2020/07/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E5%8D%A1%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E9%85%8D%E7%BD%AEJDK%E3%80%81%E4%BB%A5%E5%8F%8Atomcat%E7%9A%84%E5%AE%89%E8%A3%85/" title="学习笔记之Linux学习（三）">学习笔记之Linux学习（三）</a></p>
<p>下一篇学习：<a href="/2020/07/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BZookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AZookeeper%E9%9B%86%E7%BE%A4%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E5%90%AF%E5%8A%A8%E5%85%B3%E9%97%AD%E8%84%9A%E6%9C%AC%E7%9A%84%E7%BC%96%E5%86%99%E3%80%81%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/" title="学习笔记之Zookeeper学习（二）">学习笔记之Zookeeper学习（二）</a></p>
<p><strong>如果觉得对自己有帮助，欢迎大家点赞、评论！</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BZookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AZookeeper%E7%AE%80%E4%BB%8B%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E3%80%81%E7%9B%91%E5%90%AC%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E3%80%81%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E5%AE%89%E8%A3%85/" data-id="ckf1vxjfl000jk0uk4ffdb2aa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Zookeeper%E5%AD%A6%E4%B9%A0/" rel="tag">Zookeeper学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习笔记之Zookeeper学习（二）：Zookeeper集群的安装、启动关闭脚本的编写、常用命令介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BZookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AZookeeper%E9%9B%86%E7%BE%A4%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E5%90%AF%E5%8A%A8%E5%85%B3%E9%97%AD%E8%84%9A%E6%9C%AC%E7%9A%84%E7%BC%96%E5%86%99%E3%80%81%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time datetime="2020-07-18T16:58:46.000Z" itemprop="datePublished">2020-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Zookeeper/">Zookeeper</a>►<a class="article-category-link" href="/categories/Zookeeper/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BZookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AZookeeper%E9%9B%86%E7%BE%A4%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E5%90%AF%E5%8A%A8%E5%85%B3%E9%97%AD%E8%84%9A%E6%9C%AC%E7%9A%84%E7%BC%96%E5%86%99%E3%80%81%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/">学习笔记之Zookeeper学习（二）：Zookeeper集群的安装、启动关闭脚本的编写、常用命令介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章主要介绍了<a href="/2020/07/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BZookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AZookeeper%E7%AE%80%E4%BB%8B%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E3%80%81%E7%9B%91%E5%90%AC%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E3%80%81%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E5%AE%89%E8%A3%85/" title="Zookeeper单机版的安装">Zookeeper单机版的安装</a><br>本篇文章主要讲解Zookeeper集群版以及Zookeeper常用命令介绍。</p>
<h1 id="一、Zookeeper集群"><a href="#一、Zookeeper集群" class="headerlink" title="一、Zookeeper集群"></a>一、Zookeeper集群</h1><h2 id="1、Zookeeper-集群说明"><a href="#1、Zookeeper-集群说明" class="headerlink" title="1、Zookeeper 集群说明"></a>1、Zookeeper 集群说明</h2><h3 id="1-1-Zookeeper-集群中的角色"><a href="#1-1-Zookeeper-集群中的角色" class="headerlink" title="1.1 Zookeeper 集群中的角色"></a>1.1 Zookeeper 集群中的角色</h3><p>Zookeeper 集群中的角色主要有以下三类：<br><img src="https://img-blog.csdnimg.cn/20200719211946488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200719211957325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2、集群的搭建（伪集群）"><a href="#2、集群的搭建（伪集群）" class="headerlink" title="2、集群的搭建（伪集群）"></a>2、集群的搭建（伪集群）</h2><p>使用 3 个 Zookeeper 应用搭建一个伪集群。应用部署位置是：192.168.15.131。<br>客户端监听端口分别为：2181、2182、2183。投票选举端口分别为 2881/3881、2882/3882、2883/3883。</p>
<h3 id="2-1、拷贝文件"><a href="#2-1、拷贝文件" class="headerlink" title="2.1、拷贝文件"></a>2.1、拷贝文件</h3><p>首先在/usr/local/的目录下新建一个文件zookeeperCluster用于存放后续文件，然后将root/temp目录下我们解压的zookeeper文件做拷贝，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local</span><br><span class="line">mkdir zookeeperCluster</span><br><span class="line">cd &#x2F;root&#x2F;temp</span><br><span class="line">cp apache-zookeeper-3.6.0-bin &#x2F;usr&#x2F;local&#x2F;zookeeperCluster&#x2F;zookeeper01 -r</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;zookeeperCluster&#x2F;zookeeper01&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="2-2、提供缓存目录并拷贝应用"><a href="#2-2、提供缓存目录并拷贝应用" class="headerlink" title="2.2、提供缓存目录并拷贝应用"></a>2.2、提供缓存目录并拷贝应用</h3><p>这里我们进入到zookeeperCluster的zookeeper01目录下之后，新建一个data目录，用于缓存应用运行数据，创建之后进入data目录使用pwd命令获取路径，然后复制路径，返回到zookeeperCluster目录下，使用cp命令将zookeeper复制两份，用于模拟集群中的3个节点，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir data</span><br><span class="line">cd data </span><br><span class="line">pwd</span><br><span class="line">cd ..&#x2F;..</span><br><span class="line">cp zookeeper01 zookeeper02 -r</span><br><span class="line">cp zookeeper01 zookeeper03 -r</span><br></pre></td></tr></table></figure>
<h3 id="2-3、提供配置文件、设置缓存路径"><a href="#2-3、提供配置文件、设置缓存路径" class="headerlink" title="2.3、提供配置文件、设置缓存路径"></a>2.3、提供配置文件、设置缓存路径</h3><p>在每个zookeeper应用目录中有子目录 conf，需要配置里面的配置文件，<br>首先进入到zookeeper01/conf目录下将zoo_sample.cfg改为zoo.cfg，然后使用vim命令编辑这个文件，在这个文件中加入dataDir 参数值为应用运行缓存数据保存目录，每个Zookeeper都要这样配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd zookeeper01&#x2F;conf</span><br><span class="line">cp zoo_sample.cfg  zoo.cfg -r</span><br><span class="line">vim zoo.cfg</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200719214210430.png" alt="在这里插入图片描述"><br>这里要将三个zookeeper的配置文件都要改名、然后加入这样的配置。</p>
<h3 id="2-4、提供应用唯一标识"><a href="#2-4、提供应用唯一标识" class="headerlink" title="2.4、提供应用唯一标识"></a>2.4、提供应用唯一标识</h3><p>在 Zookeeper 集群中，每个节点需要一个唯一标识。这个唯一标识要求是自然数。且唯一标识保存位置是：<br>数据缓存目录(dataDir=/usr/local/zookeeper/data)的 myid 文件中。其中“数据缓存目录”为配置文件 zoo.cfg 中的配置参数。<br>执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt;&gt; zookeeper01&#x2F;data&#x2F;myid</span><br><span class="line">echo 2 &gt;&gt; zookeeper02&#x2F;data&#x2F;myid</span><br><span class="line">echo 3 &gt;&gt; zookeeper03&#x2F;data&#x2F;myid</span><br></pre></td></tr></table></figure>
<p>然后可以使用cat zookeeper01/data/myid去查看唯一标识。</p>
<h3 id="2-5、修改配置文件-zoo-cfg-设置服务、投票、选举端口"><a href="#2-5、修改配置文件-zoo-cfg-设置服务、投票、选举端口" class="headerlink" title="2.5、修改配置文件 zoo.cfg - 设置服务、投票、选举端口"></a>2.5、修改配置文件 zoo.cfg - 设置服务、投票、选举端口</h3><p>首先要进入到每个zookeeper的conf目录下去编辑zoo.cfg文件，<br>编辑内容如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim zookeeper01&#x2F;conf&#x2F;zoo.cfg</span><br><span class="line">#服务端口根据应用做对应修改,zk01-2181,zk02-2182,zk03-2183</span><br><span class="line">clientPort&#x3D;2181 </span><br><span class="line">server.1&#x3D;192.168.15.131:2881:3881</span><br><span class="line">server.2&#x3D;192.168.15.131:2882:3882</span><br><span class="line">server.3&#x3D;192.168.15.131:2883:3883</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200719215101811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>以上为zookeeper01的设置，如果是zookeeper02，属性clientPort就是2182，如下所示（这里我只演示两个zookeeper的，第三个自己配置）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim zookeeper02&#x2F;conf&#x2F;zoo.cfg</span><br><span class="line">#服务端口根据应用做对应修改,zk01-2181,zk02-2182,zk03-2183</span><br><span class="line">clientPort&#x3D;2182 </span><br><span class="line">server.1&#x3D;192.168.15.131:2881:3881</span><br><span class="line">server.2&#x3D;192.168.15.131:2882:3882</span><br><span class="line">server.3&#x3D;192.168.15.131:2883:3883</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200719215513553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>三个zookeeper都配置完成之后就保存退出，然后就是编写我们的启动和停止脚本了。</p>
<h3 id="2-6、编写启动、关闭集群脚本并且授权"><a href="#2-6、编写启动、关闭集群脚本并且授权" class="headerlink" title="2.6、编写启动、关闭集群脚本并且授权"></a>2.6、编写启动、关闭集群脚本并且授权</h3><p><strong>回到zookeeperCluster目录下</strong>，使用以下命令去创建并编辑脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">启动脚本</span><br><span class="line">第一步：vim start.sh </span><br><span class="line">第二步复制以下内容粘贴到以上文件中，然后保存退出</span><br><span class="line">zookeeper01&#x2F;bin&#x2F;zkServer.sh start  </span><br><span class="line">zookeeper02&#x2F;bin&#x2F;zkServer.sh start</span><br><span class="line">zookeeper03&#x2F;bin&#x2F;zkServer.sh start</span><br><span class="line"></span><br><span class="line">关闭脚本：</span><br><span class="line">第一步：vim stop.sh </span><br><span class="line">第二步复制以下内容粘贴到以上文件中，然后保存退出</span><br><span class="line">zookeeper01&#x2F;bin&#x2F;zkServer.sh stop </span><br><span class="line">zookeeper02&#x2F;bin&#x2F;zkServer.sh stop</span><br><span class="line">zookeeper03&#x2F;bin&#x2F;zkServer.sh stop</span><br><span class="line"></span><br><span class="line">查看状态的脚本：</span><br><span class="line">第一步：vim status.sh </span><br><span class="line">第二步复制以下内容粘贴到以上文件中，然后保存退出</span><br><span class="line">zookeeper01&#x2F;bin&#x2F;zkServer.sh status</span><br><span class="line">zookeeper02&#x2F;bin&#x2F;zkServer.sh status</span><br><span class="line">zookeeper03&#x2F;bin&#x2F;zkServer.sh status</span><br></pre></td></tr></table></figure>
<p>脚本编写完毕之后，由于没有授权不能运行，因此我们还要进行授权，<br>如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给启动脚本授权：</span><br><span class="line">chmod +x start.sh</span><br><span class="line"></span><br><span class="line">给关闭脚本授权：</span><br><span class="line">chmod +x stop.sh </span><br><span class="line"></span><br><span class="line">给查看状态的脚本授权：</span><br><span class="line">chmod +x  status.sh </span><br></pre></td></tr></table></figure>
<p>授权完毕之后就可以去使用脚本启动zookeeper集群了。<br><strong>注意：脚本文件的配置是在zookeeperCluster目录下进行的，启动关闭也是在该目录下执行。</strong></p>
<p>启动命令：**./start.sh**<br><img src="https://img-blog.csdnimg.cn/20200719220545544.png" alt="在这里插入图片描述"><br>停止命令：**./stop.sh**</p>
<h3 id="2-7、客户端连接Zookeeper集群"><a href="#2-7、客户端连接Zookeeper集群" class="headerlink" title="2.7、客户端连接Zookeeper集群"></a>2.7、客户端连接Zookeeper集群</h3><p>在集群启动的情况下，使用以下命令我们可以在zookeeperCluster目录下连接集群：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式为：zkCli.sh -server host:port</span><br><span class="line">.&#x2F;zookeeper&#x2F;bin&#x2F;zkCli.sh -server 192.168.15.131:2181</span><br></pre></td></tr></table></figure>
<p>连接成功之后是这样的：<br><img src="https://img-blog.csdnimg.cn/20200719221414503.png" alt="在这里插入图片描述"><br><strong>注意：在本机的集群情况下我们可以连接任何一个端口，如果是三个Linux组合成的集群，那么中间的ip地址就可以填对应的linux地址，因为是集群，所以我们链接其中的任何一个都可以。</strong></p>
<h1 id="二、常用命令的介绍"><a href="#二、常用命令的介绍" class="headerlink" title="二、常用命令的介绍"></a>二、常用命令的介绍</h1><h2 id="1-ls-命令"><a href="#1-ls-命令" class="headerlink" title="1 ls 命令"></a>1 ls 命令</h2><p>基本格式为：<strong>ls /path</strong><br>使用 ls 命令查看 zookeeper 中的内容。在 ZooKeeper 控制台客户端中，没有默认列表功能，必须指定要列表资源的位置。 如： ls / 或者 ls /path<br><img src="https://img-blog.csdnimg.cn/20200719221527850.png" alt="在这里插入图片描述"></p>
<h2 id="2-create-命令"><a href="#2-create-命令" class="headerlink" title="2 create 命令"></a>2 create 命令</h2><p><strong>create [-e] [-s] /path [data]</strong><br>使用 create 命令创建一个新的 Znode。create [-e] [-s] path data - 创建节点，如： create /test 123 创建一个/test 节点，节点携带数据信息 123。 </p>
<p>create -e /test 123 创建一个临时节点/test，携带数据为 123，临时节点只在当前会话生命周期中有效，会话结束节点自动删除。</p>
<p>create -s /test 123 创建一个顺序节点/test，携带数据 123，创建的顺序节点由 ZooKeeper 自动为节点增加后缀信息，如-/test00000001 等。-e 和-s 参数可以联合使用。<br><img src="https://img-blog.csdnimg.cn/20200719221631676.png" alt="在这里插入图片描述"></p>
<h2 id="3-get-命令"><a href="#3-get-命令" class="headerlink" title="3 get 命令"></a>3 get 命令</h2><p>基本格式为：<strong>get [-s] /path</strong>  </p>
<p>get 命令获取 Znode 中的数据。<img src="https://img-blog.csdnimg.cn/20200719221732262.png" alt="在这里插入图片描述"><br><strong>get -s /path</strong><br>            -s 查看 Znode 详细信息<br><img src="https://img-blog.csdnimg.cn/20200719221815110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1）oldlu:存放的数据<br>（2）cZxid:创建时 zxid(znode 每次改变时递增的事务 id)<br>（3）ctime:创建时间戳<br>（4）mZxid:最近一次更近的 zxid<br>（5）mtime:最近一次更新的时间戳<br>（6）pZxid:子节点的 zxid<br>（7）cversion:子节点更新次数<br>（8）dataversion:节点数据更新次数<br>（9）aclVersion:节点 ACL(授权信息)的更新次数<br>（10）ephemeralOwner:如果该节点为 ephemeral 节点(临时，生命周期与 session 一样),ephemeralOwner 值表示与该节点绑定的 session id. 如果该节点不是ephemeral 节点, ephemeralOwner 值为 0.<br>（11）dataLength:节点数据字节数<br>（12）numChildren:子节点数量</p>
<h2 id="4-set-命令"><a href="#4-set-命令" class="headerlink" title="4 set 命令"></a>4 set 命令</h2><p>基本格式为：<strong>set /path [data]</strong><br>添加或修改 Znode 中的值<img src="https://img-blog.csdnimg.cn/20200719222038655.png" alt="在这里插入图片描述"></p>
<h2 id="5-delete-命令"><a href="#5-delete-命令" class="headerlink" title="5 delete 命令"></a>5 delete 命令</h2><p>基本格式为：<strong>delete /path</strong><br>删除 Znode。<br><img src="https://img-blog.csdnimg.cn/20200719222110924.png" alt="在这里插入图片描述"></p>
<p>上一篇学习：<a href="/2020/07/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BZookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AZookeeper%E7%AE%80%E4%BB%8B%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E3%80%81%E7%9B%91%E5%90%AC%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E3%80%81%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E5%AE%89%E8%A3%85/" title="学习笔记之Zookeeper学习（一）">学习笔记之Zookeeper学习（一）</a></p>
<p>下一篇学习：学习笔记之Zookeeper学习（三）</p>
<p><strong>喜欢的小伙伴记得点一下赞哦，谢谢！</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BZookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AZookeeper%E9%9B%86%E7%BE%A4%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E5%90%AF%E5%8A%A8%E5%85%B3%E9%97%AD%E8%84%9A%E6%9C%AC%E7%9A%84%E7%BC%96%E5%86%99%E3%80%81%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/" data-id="ckf1vxjfm000kk0uk26ql432j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Zookeeper%E5%AD%A6%E4%B9%A0/" rel="tag">Zookeeper学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习笔记之Linux学习（三）：配置虚拟机网卡、文件上传、配置JDK、以及tomcat的安装" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E5%8D%A1%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E9%85%8D%E7%BD%AEJDK%E3%80%81%E4%BB%A5%E5%8F%8Atomcat%E7%9A%84%E5%AE%89%E8%A3%85/" class="article-date">
  <time datetime="2020-07-16T18:20:40.000Z" itemprop="datePublished">2020-07-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>►<a class="article-category-link" href="/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E5%8D%A1%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E9%85%8D%E7%BD%AEJDK%E3%80%81%E4%BB%A5%E5%8F%8Atomcat%E7%9A%84%E5%AE%89%E8%A3%85/">学习笔记之Linux学习（三）：配置虚拟机网卡、文件上传、配置JDK、以及tomcat的安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章：<a href="/2020/07/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ALinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/" title="学习笔记之Linux学习（二）">学习笔记之Linux学习（二）</a><br>介绍了Linux常用命令，为本文以及后面的学习做了准备。<br>本文会详细的介绍Linux网卡配置、使用Xshell连接Linux终端、软件的上传、tomcat的安装、jdk的配置。</p>
<h1 id="一、Linux虚拟网卡的配置"><a href="#一、Linux虚拟网卡的配置" class="headerlink" title="一、Linux虚拟网卡的配置"></a>一、Linux虚拟网卡的配置</h1><p>首先我们打开Linux 的终端，如图所示：<br><img src="https://img-blog.csdnimg.cn/20200718174613722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开终端之后我们输入命令：<strong>ifconfig</strong>   查看网络编辑器. 查看网卡信息.<br>然后<strong>回车</strong>就可以看见我们的虚拟机的ip地址，但是这个是动态的地址，我们需要将它改为静态的。<br><img src="https://img-blog.csdnimg.cn/20200718174802695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来输入命令<strong>cd /etc/sysconfig/network-scripts/</strong><br>进入到该目录下，然后使用命令：<strong>ls</strong>      去查看当前目录下的文件：<br><img src="https://img-blog.csdnimg.cn/20200718175144502.png" alt="在这里插入图片描述"><br>红框圈中的就是我们需要编辑的网卡，使用命令：<strong>vim ifcfg-eth0</strong><br>对网卡进行编辑，执行这个命令之后会进入一个以下界面：<br><img src="https://img-blog.csdnimg.cn/20200718175435411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们按两下D按键就可以删除一行，把里面的内容全部删除，然后复制好以下配置，然后到编辑的那个终端右键选择paste粘贴进去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DEVICE&#x3D;eth0</span><br><span class="line">BOOTPROTO&#x3D;static</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">IPADDR&#x3D;192.168.15.130</span><br><span class="line">NETMASK&#x3D;255.255.255.0</span><br><span class="line">GATEWAY&#x3D;192.168.15.2</span><br><span class="line">DNS1&#x3D;114.114.114.114</span><br><span class="line">DNS2&#x3D;4.4.4.4</span><br><span class="line">IPV6INIT&#x3D;no</span><br></pre></td></tr></table></figure>
<p>复制进去之后需要特别注意，一定要先检查一下复制的内容少了没有，如果少了的话就要加进去，这里要按<strong>i</strong>键进入编辑模式，按下<strong>i</strong>键之后左下角会出现<strong>INSERT</strong>说明可以编辑了，这里我们主要修改的地方就是下图所示内容：<br><img src="https://img-blog.csdnimg.cn/20200718180437556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>编辑完成之后先按一下键盘左上角的<strong>ESC</strong>退出编辑模式，<br>然后使用命令  <strong>:wq</strong>   意思是保存并退出。<br>这个时候再使用命令：<strong>service network restart</strong> 将我们的网卡重启一下，然后使用尝试一下ping百度，命令为：<strong>ping <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></strong><br>停止命令为：<strong>Ctrl+C</strong>，如果能正常上网应该是这样的：<br><img src="https://img-blog.csdnimg.cn/20200718180913108.png" alt="在这里插入图片描述"><br>这样我们的网卡就配置成功了，这个时候使用命令：<strong>ifconfig</strong><br>将我们的IP地址复制，可以将我们左上方的虚拟机名字命名为这个IP地址，复制好我们的IP地址之后，打开我们的Xshell软件。</p>
<h1 id="二、使用Xshell连接Linux终端"><a href="#二、使用Xshell连接Linux终端" class="headerlink" title="二、使用Xshell连接Linux终端"></a>二、使用Xshell连接Linux终端</h1><p>我们发现，在使用linux的终端的时候，我们想切屏啥的都不太习惯，而且我们平时使用的快捷键复制粘贴啥的在Linux里面都不能用，这个时候使用Xshell就解决了这样的一些问题。</p>
<p><strong>打开Xshell软件</strong><br>如果是第一次打开，它会弹出让你新建一个会话连接，并且让你填写一下信息，如图所示：<br><img src="https://img-blog.csdnimg.cn/20200718181632918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>注意：</strong>填写好名称和主机IP之后，点击确认，选择好刚刚创建的点击连接，然后选择接受并一次性保存，之后会弹出让你输入用户和密码，这里我建议使用root用户登录，然后勾选记住用户和密码，方便下次用的时候不用重复输入。</p>
<p>这样我们就可以在Xshell中使用Linux命令去操作Linux了，可以使用我们之前查看IP新的命令看一下：<strong>ifconfig</strong></p>
<p>如果关闭了Xshell软件之后再次打开，就在<strong>文件–&gt;打开</strong>  然后就可以看见我们创建的连接了。</p>
<h1 id="三、文件上传（lrzsz工具）"><a href="#三、文件上传（lrzsz工具）" class="headerlink" title="三、文件上传（lrzsz工具）"></a>三、文件上传（lrzsz工具）</h1><p>首先我们打开Xshell，并且连接上Linux。<br>使用文件上传的方式有很多种，这里我主要介绍一种比较简单的文件上传方式，这种方式需要在Linux中安装lrzsz工具。</p>
<p>输入命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y lrzsz</span><br></pre></td></tr></table></figure>
<p>网速好一下子就安装完成了，这样我们使用rz命令就可以方便的上传文件。</p>
<p>首先我们在root的目录下新建一个文件temp：<br><img src="https://img-blog.csdnimg.cn/20200718190146399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>命令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir temp</span><br></pre></td></tr></table></figure>
<p>然后使用cd命令进入该文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd temp</span><br></pre></td></tr></table></figure>
<p>在该目录下使用命令<strong>rz</strong>，这个时候会弹出一个让你选择文件的框，这里我们后面需要配置JDK和tomcta，选择好文件我们一个一个上传。</p>
<h1 id="四、配置JDK"><a href="#四、配置JDK" class="headerlink" title="四、配置JDK"></a>四、配置JDK</h1><p>文件上传完毕之后我们可以使用<strong>ls</strong>命令查看。<br><img src="https://img-blog.csdnimg.cn/20200718190606722.png" alt="在这里插入图片描述"><br><strong>第一步：</strong><br>这个时候我们开始去解压它，使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf jdk-8u11-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
<p><strong>注：输入命令时可以按Tab键快速补齐。</strong><br>然后再用ls命令去查看一下当前目录就可以看见多出了一个文件夹。</p>
<p><strong>第二步：</strong><br>将解压后的文件拷贝到/usr/local/目录下，使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp jdk1.8.0_11&#x2F; &#x2F;usr&#x2F;local&#x2F;jdk -rf</span><br></pre></td></tr></table></figure>
<p>后面加的jdk相当于是在目标目录下新建了一个jdk的文件夹。拷贝完成之后可以cd /usr/local/ 目录下使用ls命令查看。返回root目录下使用cd 就行了<br><strong>第三步：</strong><br>使用以下命令去配置jdk：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p>用键盘的上下键移到该文件的最底部，然后按<strong>i</strong>键进入编辑模式，复制以下内容粘贴进去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk</span><br><span class="line">export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200718191833273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>注意：一定要检查好不要写漏或者写错，写完之后ESC退出编辑模式，然后:wq保存并退出。</strong></p>
<p><strong>第四步</strong><br>本来配置完这一步是要重启Linux才能完全让JDK生效的，但是这里我们可以先使用以下命令暂时不重启Linux来查看jdk是否配置好。（注意中间有空格）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p>然后使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200718192518655.png" alt="在这里插入图片描述"><br>出现以上就说明你的JDK配置成功啦。。。。</p>
<h1 id="五、tomcat的安装"><a href="#五、tomcat的安装" class="headerlink" title="五、tomcat的安装"></a>五、tomcat的安装</h1><p>首先使用<strong>cd /root/temp</strong>到我们的temp目录下，上传文件并且解压。<br>（以下为了多练习一下命令求多加了一步。）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解压：tar -zxf  apache-tomcat-7.0.47.tar.gz          </span><br><span class="line">拷贝到：cp apache-tomcat-7.0.47 &#x2F;usr&#x2F;local&#x2F; -rf</span><br><span class="line">改名称：mv apache-tomcat-7.0.47&#x2F; tomcat</span><br></pre></td></tr></table></figure>
<p>然后我们就可以到该目录下去查看了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line">使用ls查看目录结构</span><br></pre></td></tr></table></figure>
<p>启动tomcat的目录就是在bin目录里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd bin </span><br><span class="line">使用ls命令查看：</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200718193357954.png" alt="在这里插入图片描述"><br><strong>接下来便是去启动tomcat:</strong><br>启动之前首先要关闭防火墙：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关闭防火墙：service iptables stop</span><br><span class="line">启动命令：.&#x2F;startup.sh </span><br><span class="line">停止命令：.&#x2F;shutdown.sh </span><br></pre></td></tr></table></figure>
<p>启动成功之后，会是以下提示：<br><img src="https://img-blog.csdnimg.cn/20200718193531898.png" alt="在这里插入图片描述"><br>接下来我们就去浏览器访问我们Linux的tomcat，在浏览器中输入<br>Linux的ip地址+端口号<br>我的是：<a target="_blank" rel="noopener" href="http://192.168.15.132:8080/">http://192.168.15.132:8080</a><br>访问成功之后会出现以下界面：<br><img src="https://img-blog.csdnimg.cn/20200718194011394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>出现以上界面就说明我们的tomcat安装成功了。<br><strong>如果浏览器访问不了就注意一定要关闭Linux 的防火墙。</strong></p>
<p><strong>如果觉得笔记符合需求的话不要忘记点赞收藏哦！</strong></p>
<p>返回首页：<a target="_blank" rel="noopener" href="https://oldou.github.io/">点击此处</a></p>
<p>上一篇文章：<a href="/2020/07/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ALinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/" title="学习笔记之Linux学习（二）">学习笔记之Linux学习（二）</a></p>
<p>下一篇文章：<a href="/2020/07/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BZookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AZookeeper%E7%AE%80%E4%BB%8B%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E3%80%81%E7%9B%91%E5%90%AC%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E3%80%81%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E5%AE%89%E8%A3%85/" title="学习笔记之Zookeeper学习（一）">学习笔记之Zookeeper学习（一）</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E5%8D%A1%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E9%85%8D%E7%BD%AEJDK%E3%80%81%E4%BB%A5%E5%8F%8Atomcat%E7%9A%84%E5%AE%89%E8%A3%85/" data-id="ckf1vxjfd0009k0uk60pufs2a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E5%AD%A6%E4%B9%A0/" rel="tag">Linux学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习笔记之Linux学习（二）：Linux常用命令介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ALinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time datetime="2020-07-16T15:55:36.000Z" itemprop="datePublished">2020-07-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>►<a class="article-category-link" href="/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ALinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/">学习笔记之Linux学习（二）：Linux常用命令介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章：<a href="/2020/07/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ALinux%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D%E3%80%81Xshell%E7%BB%88%E7%AB%AF%E7%9A%84%E5%AE%89%E8%A3%85/" title="学习笔记之Linux学习（一）">学习笔记之Linux学习（一）</a><br>介绍了VMware Workstation Pro 软件的安装、Linux的安装、Xshell终端的安装以及Linux目录的介绍。</p>
<p>本文主要介绍Linux的常用命令，为后续的学习作准备。</p>
<h1 id="Linux常用命令介绍"><a href="#Linux常用命令介绍" class="headerlink" title="Linux常用命令介绍"></a>Linux常用命令介绍</h1><h1 id="（1）ifconfig"><a href="#（1）ifconfig" class="headerlink" title="（1）ifconfig"></a>（1）ifconfig</h1><pre><code>    查看网络编辑器. 查看网卡信息.</code></pre>
<h1 id="（2）pwd"><a href="#（2）pwd" class="headerlink" title="（2）pwd"></a>（2）pwd</h1><pre><code>    print working directory - 输出当前工作目录,光标所在位置的目录.</code></pre>
<h1 id="（3）cd"><a href="#（3）cd" class="headerlink" title="（3）cd"></a>（3）cd</h1><pre><code>    change directory - 切换目录.
    特殊目录符号 : 当前目录 - ‘.’ , 父目录 - ‘..’(cd ..)
    使用方式
            1  切换固定位置
                    使用根目录作为定位标准, 绝对寻址.
                     如：cd /xxx/yyy/zzz
            2  切换相对位置
                    在当前目录位置开始相对寻址.
                     如：cd xxx/yyy/zzz
            3  进入主目录
                    直接进入用户主目录
                      cd
                      cd ~    这里的~代表的就是root目录</code></pre>
<h1 id="（4）ls"><a href="#（4）ls" class="headerlink" title="（4）ls"></a>（4）ls</h1><p>list - 列表目录中的内容.默认显示当前目录下的文件列表</p>
<pre><code>     使用方式
            列表当前目录 ：ls
            列表指定目录 ：ls 目录位置(绝对路径|相对路径)
            查看全部内容 ：ls -a [目录]---list all - 查看所有, 包括隐藏文件. 
            注意：Linux 中隐藏文件都是以’.’开头的文件.
            列表查看目录内容 ：
                  ls -l [目录]：显示当前目录下的文件属性：大小、权限、日期、符号链接。
                  ll - 简化命令不代表全部 Linxu 系统可用.
                  list list - 以列表的信息,显示指定目录中的内容. 列表代表的是文件的详情.


             类型： - | 1 代表文件
                    d | 2 代表目录, 2+n, n 代表目录中的文件数量.

             容量：单位是字节. 所有的目录固定容量为 4096.

             权限：分为不同的角色: 文件的所有者, 就是创建文件的用户. 
                    所在组,和所有者同一个组的其他用户. 其他用户, 和所有者不在一个组的用户.
                    rwx - read write execut
                   ‘-’ 代表没有对应权限.
     命令参数
          所有以‘-‘ 开头的命令后缀信息, 都是命令参数. 多参数可以并行使用. 如: ls -al</code></pre>
<h1 id="（5）clear"><a href="#（5）clear" class="headerlink" title="（5）clear"></a>（5）clear</h1><pre><code>    clear screen - 清空屏幕.
    清屏命令有两个:clear 和 clear screen</code></pre>
<h1 id="（6）touch"><a href="#（6）touch" class="headerlink" title="（6）touch"></a>（6）touch</h1><pre><code>创建空白文件,在 Linux 系统中,文件不需要强制后缀名.
                    如: 文本文件可以定义为, a | a.txt | a.text
使用方式
            touch 文件名:指的是在当前目录下创建文件
            touch 目录/文件名:基于相对路径 如：touch root/b
            touch /目录/文件名:基于绝对路径 </code></pre>
<h1 id="（7）cat"><a href="#（7）cat" class="headerlink" title="（7）cat"></a>（7）cat</h1><pre><code>查看文件的全部内容.一次性显示文件中所有内容.</code></pre>
<h1 id="（8）more"><a href="#（8）more" class="headerlink" title="（8）more"></a>（8）more</h1><pre><code>分屏显示文件内容, 显示后,使用空格显示下一屏, 
回车显示下一行,q 退出分屏显示.
ctrl+c,退出命令</code></pre>
<h1 id="（9）head"><a href="#（9）head" class="headerlink" title="（9）head"></a>（9）head</h1><pre><code>显示文件的前多少行, 默认显示前 10 行. 如：head -number filename
查看文件中的前多少行.</code></pre>
<h1 id="（10）tail"><a href="#（10）tail" class="headerlink" title="（10）tail"></a>（10）tail</h1><pre><code>显示文件末尾多少行.默认显示末尾 10 行. 如：tail -number filename</code></pre>
<h1 id="（11）mkdir"><a href="#（11）mkdir" class="headerlink" title="（11）mkdir"></a>（11）mkdir</h1><pre><code>make directory - 创建目录.
    10.1  使用方式
            10.1.1  相对创建一个子目录--mkdir directoryName
            10.1.2  绝对创建一个目录 --mkdir /directoryName
            10.1.3  一次性创建多级目录--mkdir -p                
            parentDirectoryName/childDirectoryName</code></pre>
<h1 id="（12）cp"><a href="#（12）cp" class="headerlink" title="（12）cp"></a>（12）cp</h1><pre><code> copy - 复制命令.
  使用方式--copy 源信息 目录信息    copy source target  
  复制文件-copy fileName newFileName
    copy directoryName/fileName directoryName/[newFileName]
    copy /directoryName/fileName /directoryName/[newFileName]
 复制目录
    copy -r directoryName newDirectoryName</code></pre>
<h1 id="（13）-rm"><a href="#（13）-rm" class="headerlink" title="（13） rm"></a>（13） rm</h1><pre><code>remove - 删除
    使用方式 ---rm source ：rm 要删除的资源
    删除文件需提示----rm fileName   
                             rm directoryName/fileName
                             rm / directoryName/fileName
    删除文件不需提示---rm-f fileName
                             rm -f directoryName/fileName
                             rm -f /directoryName/fileName
    删除目录需提示
                            rm -r directoryName
    删除目录不需提示
                            rm -rf directoryName</code></pre>
<h1 id="（14）mv"><a href="#（14）mv" class="headerlink" title="（14）mv"></a>（14）mv</h1><pre><code>move - 移动或重命名. 相当于剪切和重命名.
  使用方式
         mv source target 移动
         mv source newName 重命名
  移动文件到指定位置 ：mv fileName directoryName
  为文件重命名 ：mv fileName newFileName</code></pre>
<h1 id="（15）-vi-vim"><a href="#（15）-vi-vim" class="headerlink" title="（15） vi | vim"></a>（15） vi | vim</h1><pre><code>编辑文件, vim 是增强命令. 
            不代表所有的 Linux 都支持.vim 增强在有高亮显示.
使用方式----vi fileName
命令模式----是控制编辑的文件的状态的,如:保存,退出编辑等.
       进入编辑模式:
        a - append, 追加的方式进入编辑模式
        i - insert, 插入的方式进入编辑模式
        o - under line , 在光标所在位置之下,新增一行,进入编辑模式.
        O - pre line, 在光标所在位置之上,新增一行, 进入编辑模式.
        dd  ：[number] dd - delete line 删除指定行, 默认 1 行
        w   ： write - 保存
        q   ：quit - 退出 vi 编辑器
        wq  ：保存并退出
        q!  ：强制退出不保存.
        set nu  ：显示行号
         /keywords  ：搜索关键字, keywords 是关键字的命名.
        G   ：光标跳转到文件尾
        gg  ：光标跳转到文件头
编辑模式：是编辑文件内容的.进入命令模式 - esc</code></pre>
<h1 id="（16）service"><a href="#（16）service" class="headerlink" title="（16）service"></a>（16）service</h1><pre><code>服务控制命令. 常用服务:iptables - 防火墙, 
vsftpd ftp 文件服务器, mysql防火墙建议关闭. 
否则除 80,22 端口外,其他所有端口无法访问.

关闭操作：（service iptables stop）
使用方式
     1、启动服务
              service 服务名称 start
     2、停止服务
              service 服务名称 stop 
     3、重启服务
              service 服务名称 restart
     4、查看服务状态
              service 服务名称 status</code></pre>
<h1 id="（17）-ps"><a href="#（17）-ps" class="headerlink" title="（17）  ps"></a>（17）  ps</h1><pre><code>进程信息查看命令.
    使用方式
            ps aux [| grep keywords]
             a - 所有进程
             u - 包含用户启动的进程
             x - 正在执行中的进程.</code></pre>
<h1 id="（18）grep"><a href="#（18）grep" class="headerlink" title="（18）grep"></a>（18）grep</h1><pre><code>过滤|筛选, 筛选符合关键字的数据.</code></pre>
<h1 id="（19）tar"><a href="#（19）tar" class="headerlink" title="（19）tar"></a>（19）tar</h1><pre><code>解压缩 : tar 命令
      1  使用方式
          tar [参数] source [target]
          source - 压缩文件
          target - 解压缩后的目标位置, 默认解压到当前目录.
            常用写法 :
                    解压缩 : tar -zxf 压缩文件名
                    解压缩 : tar -zxvf 压缩文件名
                    压缩 : tar -czf 要压缩的目录 压缩后的文件名

        1.1  z
              zip 格式压缩文件, 包含 zip,gz,tar.gz 等格式. 
              不包含 rar.
        1.2  c
              创建压缩包.
        1.3  x
              解压缩
        1.4  f
              指定文件
        1.5  v
             显示解压缩过程.</code></pre>
<h1 id="（20）useradd"><a href="#（20）useradd" class="headerlink" title="（20）useradd"></a>（20）useradd</h1><pre><code>创建新用户 : useradd 命令
    useradd + 用户名</code></pre>
<h1 id="（21）passwd"><a href="#（21）passwd" class="headerlink" title="（21）passwd"></a>（21）passwd</h1><pre><code>为用户添加密码 : passwd 命令
    passwd + 用户名(为哪个用户添加密码)</code></pre>
<h1 id="（22）chkconfig-iptables-off"><a href="#（22）chkconfig-iptables-off" class="headerlink" title="（22）chkconfig iptables off"></a>（22）chkconfig iptables off</h1><pre><code>永久关闭防火墙</code></pre>
<h1 id="（23）reboot"><a href="#（23）reboot" class="headerlink" title="（23）reboot"></a>（23）reboot</h1><pre><code>重启linux(慎用)</code></pre>
<p>返回首页：<a target="_blank" rel="noopener" href="https://oldou.github.io/">点击此处</a></p>
<p>上一篇文章：<a href="/2020/07/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ALinux%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D%E3%80%81Xshell%E7%BB%88%E7%AB%AF%E7%9A%84%E5%AE%89%E8%A3%85/" title="学习笔记之Linux学习（一）">学习笔记之Linux学习（一）</a></p>
<p>下一篇文章：<a href="/2020/07/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E5%8D%A1%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E9%85%8D%E7%BD%AEJDK%E3%80%81%E4%BB%A5%E5%8F%8Atomcat%E7%9A%84%E5%AE%89%E8%A3%85/" title="学习笔记之Linux学习（三）">学习笔记之Linux学习（三）</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ALinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/" data-id="ckf1vxjfe000ak0uk806y0qj4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E5%AD%A6%E4%B9%A0/" rel="tag">Linux学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习笔记之Linux学习（一）：Linux安装以及目录介绍、Xshell终端的安装" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ALinux%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D%E3%80%81Xshell%E7%BB%88%E7%AB%AF%E7%9A%84%E5%AE%89%E8%A3%85/" class="article-date">
  <time datetime="2020-07-15T15:58:46.000Z" itemprop="datePublished">2020-07-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>►<a class="article-category-link" href="/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ALinux%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D%E3%80%81Xshell%E7%BB%88%E7%AB%AF%E7%9A%84%E5%AE%89%E8%A3%85/">学习笔记之Linux学习（一）：Linux安装以及目录介绍、Xshell终端的安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1、Linux的介绍"><a href="#1、Linux的介绍" class="headerlink" title="1、Linux的介绍"></a>1、Linux的介绍</h1><p><img src="https://img-blog.csdnimg.cn/20200718161819617.png" alt="在这里插入图片描述"></p>
<h1 id="2、Linux的安装文件介绍"><a href="#2、Linux的安装文件介绍" class="headerlink" title="2、Linux的安装文件介绍"></a>2、Linux的安装文件介绍</h1><p>首先介绍一下本次学习需要安装的软件：<br>VMware Workstation Pro   （VMware-workstation-full-12.1.0-3272444）<br>CentOS-6.5-x86_64-bin-DVD1.iso<br>Xshell5.exe<br>下载地址为：<br>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1QIzxgQAY1wNttaxOxwoZEg">https://pan.baidu.com/s/1QIzxgQAY1wNttaxOxwoZEg</a><br>提取码：pcra</p>
<p>里面有整理好的笔记以及后续学习所需要的安装包，包括有以下：<br>apache-tomcat-7.0.47.tar.gz<br>VMware12及密钥<br>CentOS-6.5-x86_64-bin-DVD1.iso<br>FileZilla_3.23.0.2_win64-setup.exe<br>jdk-8u11-linux-x64.tar.gz<br>mysql-community-release-el6-5.noarch.rpm<br>Xshell5.exe</p>
<p>好了，不多BB了，开始下面的学习。</p>
<h1 id="3、VMware-Workstation-Pro-的安装"><a href="#3、VMware-Workstation-Pro-的安装" class="headerlink" title="3、VMware Workstation Pro 的安装"></a>3、VMware Workstation Pro 的安装</h1><p>打开下载的文件夹，<br>找到VMware12及密钥下的VMware-workstation-full-12.1.0-3272444.exe<br>双击运行。<br><img src="https://img-blog.csdnimg.cn/20200718163329414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后一直点击下一步，选择合适的安装目录，直接安装即可，安装完成之后需要输入密钥，在文件夹中有密钥，复制粘贴即可。<br>VMware 12 专业版永久许可证密钥：<br>5A02H-AU243-TZJ49-GTC7K-3C61N</p>
<p><strong>4、Linux的安装</strong><br>打开安装好的VMware Workstation Pro ，点击新建虚拟机。<br><img src="https://img-blog.csdnimg.cn/20200718163922934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后选择典型，下一步<br><img src="https://img-blog.csdnimg.cn/20200718163957759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里是要选择镜像文件，选择我们下载的镜像文件，在文件夹中，点击下一步<br><img src="https://img-blog.csdnimg.cn/20200718164112604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>填写好用户名和密码，密码建议短一点，不要太长，填写完毕之后点击下一步。<br><img src="https://img-blog.csdnimg.cn/20200718164446997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>之后就是选择安装的位置，建议不要装在C盘，建议在其他盘新建一个文件夹专门用来放虚拟机文件，然后点击下一步<br><img src="https://img-blog.csdnimg.cn/20200718164641109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里我们选择默认的。<br><img src="https://img-blog.csdnimg.cn/20200718164722505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里也选择默认的，点击完成，接下来便是等待安装。<br><img src="https://img-blog.csdnimg.cn/20200718164817743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>安装期间会出现下图所示，这个时候鼠标点进去按回车就行了，鼠标如果想切换出来按<strong>Ctrl+Alt</strong><br><img src="https://img-blog.csdnimg.cn/20200718165116423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>等待的时间可能会稍微有点长，这个时候不要关闭程序，耐心等待…..<br>最后出现以下界面就说明安装成功了，这里我们点击other，输入root<br>和密码，使用root角色进入虚拟机。<br><img src="https://img-blog.csdnimg.cn/20200718165923772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>进入之后出现这个弹框，勾选以后不再弹出就行了。<br><img src="https://img-blog.csdnimg.cn/20200718170057160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这样我们虚拟机就安装完成了。。。。<br><img src="https://img-blog.csdnimg.cn/20200718170143271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="4、Linux目录介绍"><a href="#4、Linux目录介绍" class="headerlink" title="4、Linux目录介绍"></a>4、Linux目录介绍</h1><p><strong>1.1.1 ： /</strong><br>        根目录.Unix 和 Linux 中,没有盘符. 一个硬盘,一个根.</p>
<p><strong>1.1.2 ：/bin</strong><br>        系统的常用命令目录. 包括控制台命令, 系统可执行文件, 系统的核心二进制文件等.</p>
<p><strong>1.1.3 /etc</strong><br>        发布目录, 相当于 windows 系统中的 windows 目录, 保存系统中的所有核心内容.<br>        要求控制权限高, 建议不要随便读写.</p>
<p><strong>1.1.4 /usr</strong><br>        用户目录, 相当于 windows 系统中的 program files 目录.<br>        常用于安装系统所有用户共用的软件,资源的.</p>
<p><strong>1.1.5 /root</strong><br>        root根用户的用户目录.相当于windows系统中的C:/users/administrator 目录.<br>        称为用户主目录.</p>
<p><strong>1.1.6 /home</strong><br>        保存其他用户主目录的目录.<br>        如: Linux 系统中有 oldlu 用户. 那么一定有/home/oldlu 目录存在.<br>        代表用户的主目录.</p>
<p><strong>1.1.7 /var</strong><br>        系统运行过程的数据目录.</p>
<h1 id="5、Xshell终端的安装"><a href="#5、Xshell终端的安装" class="headerlink" title="5、Xshell终端的安装"></a>5、Xshell终端的安装</h1><p>在下载的文件夹中，找到Xshell5.exe，双击运行，一直点击下一步，<strong>中间安装目录</strong>选择在其他盘，最后安装完成后出现下图所示：<br><img src="https://img-blog.csdnimg.cn/20200718170931481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><p>如果不是用的我分享的文件，在安装Linux的时候出现黑屏一直卡在黑屏的界面没有其他的显示，那就说明VMware Workstation Pro和安装的CentOS-6.5-x86_64-bin-DVD1.iso版本不匹配造成的，如果都用的我分享的文件，是不会出现这样的问题的。</p>
<p><strong>软件安装成功之后，接下来便是进入下一个阶段的学习，<br>下一阶段的内容为：</strong><br><strong>1、设计虚拟机网卡</strong><br><strong>2、如何使用Xshell连接虚拟机</strong><br><strong>3、软件上传以及安装、配置JDK</strong><br><strong>4、安装tomcat</strong></p>
<p>返回首页：<a href="#">Post not found: https://oldou.github.io/ 点击此处</a><br>下一篇文章：<a href="/2020/07/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ALinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/" title="学习笔记之Linux学习（二）">学习笔记之Linux学习（二）</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ALinux%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D%E3%80%81Xshell%E7%BB%88%E7%AB%AF%E7%9A%84%E5%AE%89%E8%A3%85/" data-id="ckf1vxjfb0006k0ukbowe13ou" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E5%AD%A6%E4%B9%A0/" rel="tag">Linux学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Zookeeper常见面试题整理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/13/Zookeeper%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" class="article-date">
  <time datetime="2020-07-13T07:30:33.000Z" itemprop="datePublished">2020-07-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Zookeeper/">Zookeeper</a>►<a class="article-category-link" href="/categories/Zookeeper/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/13/Zookeeper%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">Zookeeper常见面试题整理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1、Zookeeper是什么？"><a href="#1、Zookeeper是什么？" class="headerlink" title="1、Zookeeper是什么？"></a>1、Zookeeper是什么？</h1><p>Zookeeper是Apache的一个分布式服务框架，是Apache Hadoop的一个子项目，同时是一个为分布式应用提供了一致性服务的软件，主要是用来解决分布式应用中经常遇到的一些数据管理问题，所提供的功能包括：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p>
<p>简单来说，<strong>zookeeper=文件系统+通知机制</strong></p>
<h1 id="2、介绍一下Zookeeper的存储结构？"><a href="#2、介绍一下Zookeeper的存储结构？" class="headerlink" title="2、介绍一下Zookeeper的存储结构？"></a>2、介绍一下Zookeeper的存储结构？</h1><p><img src="https://img-blog.csdnimg.cn/20200716231003637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 如上图所示，Zookeeper的底层是树形的数据结构来做存储的，它的每一个节点被称为Znode，在Zookeeper中znode是一个和Unix文件系统路径相似的节点，可以向节点中存储数据或者是获取数据。<br>Zookeeper为了保证高吞吐和低延迟，在内存中维持了树状的的结构，但是这样的结构也让Zookeeper不能用于存放大量的数据，默认的每个Znode节点的数据存放上限为1MB。</p>
<h1 id="3、Zookeeper的文件系统"><a href="#3、Zookeeper的文件系统" class="headerlink" title="3、Zookeeper的文件系统"></a>3、Zookeeper的文件系统</h1><p>Zookeeper的内部提供了一种多层级的节点命名空间，同时节点被称为Znode，和文件系统不一样的是，文件系统不能像Znode那样可以设置关联的数据，它只有文件节点可以存放数据，而目录节点不可以。</p>
<p><strong>需要注意的是：Zookeeper的每个Znode最多只能存放1MB的数据。</strong></p>
<h1 id="4、介绍一下Zookeeper四种类型的数据节点Znode。"><a href="#4、介绍一下Zookeeper四种类型的数据节点Znode。" class="headerlink" title="4、介绍一下Zookeeper四种类型的数据节点Znode。"></a>4、介绍一下Zookeeper四种类型的数据节点Znode。</h1><p>Zookeeper有四种类型的节点，分别是：持久化顺序节点(PERSISTENT)、持久化顺序编号目录节点(PERSISTENT_SEQUENTIAL)、临时目录节点(EPHEMERAL)、临时顺序编号目录节点(EPHEMERAL_SEQUENTIAL)。<br><strong>（1）持久化顺序节点(PERSISTENT)</strong><br>            该节点创建之后，当客户端和Zookeeper断开连接后，该节点依然存在，除非手动删除。<br><strong>（2）持久化顺序编号目录节点(PERSISTENT_SEQUENTIAL)</strong><br>            该节点创建时，Zookeeper会给该节点名称添加一个顺序编号，当客户端和Zookeeper断开连接后，该节点依然存在。<br><strong>（3）临时目录节点(EPHEMERAL)</strong><br>            该节点创建之后，当客户端和Zookeeper断开连接后，该节点就会被删除。<br><strong>（4）临时顺序编号目录节点(EPHEMERAL_SEQUENTIAL)</strong><br>            该节点创建时，Zookeeper会给该节点名称添加一个顺序编号，当客户端和Zookeeper断开连接后，该节点就会被删除掉。</p>
<h1 id="5、说一下Zookeeper常用的命令（详解）"><a href="#5、说一下Zookeeper常用的命令（详解）" class="headerlink" title="5、说一下Zookeeper常用的命令（详解）"></a>5、说一下Zookeeper常用的命令（详解）</h1><p><strong>Zookeeper常用的命令有：ls、create、get、set、delete</strong><br><strong>（1）ls命令</strong><br>基本格式为： ls  /path<br>使用ls命令查看zookeeper节点中的内容，在zookeeper控制客户端中，没有默认列表功能，必须要指定列表资源的位置。比如说：ls  /   或者  ls  /path<br>如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200716234130455.png" alt="在这里插入图片描述"><br>这其实和linux操作系统中查看文件内容是类似的。</p>
<p><strong>（2）create命令</strong><br>基本格式为：create [-e] [-s] /path [data]<br>使用create命令创建一个新的znode，create [-e] [-s] path data - 创建节点，同时我们可以根据后面的参数创建不同类型的节点。<br>A、创建持久化目录节点时不需要给定后面任何参数，create /path  [data]<br>比如：create /test 123   ，其意思就是创建了一个持久化目录节点test，节点携带的信息为123，该节点创建后会一直存在，除非手动删除。</p>
<p>B、创建持久化顺序目录节点时，后面需要给定参数-s，create -s /path [data]<br>比如：create -s /test 456  ，该节点创建后会一直存在，除非手动删除。</p>
<p>C、创建临时目录节点时，后面需要给定参数-e，create -e /path [data]<br>比如：create -e /ssm 666 ，临时节点只在当前会话生命周期中有效，会话结束节点自动删除。</p>
<p>D、创建临时顺序目录节点时，后面需要给定l两个参数-e  -s ,create -e -s /path [data]。临时节点只在当前会话生命周期中有效，会话结束节点自动删除。</p>
<p><strong>（3）get命令</strong><br>基本格式为：get [-s] /path<br>get命令获取Znode中的数据，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200717000307337.png" alt="在这里插入图片描述">同时，如果给定参数-s的话就会查看出Znode全部的信息。<br><img src="https://img-blog.csdnimg.cn/20200717000044872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>oldlu:存放的数据<br>cZxid:创建时 zxid(znode 每次改变时递增的事务 id)<br>ctime:创建时间戳<br>mZxid:最近一次更近的 zxid<br>mtime:最近一次更新的时间戳<br>pZxid:子节点的 zxid<br>cversion:子节点更新次数<br>dataversion:节点数据更新次数<br>aclVersion:节点 ACL(授权信息)的更新次数<br>ephemeralOwner:如果该节点为 ephemeral 节点(临时，生命周期与 session 一样),<br>ephemeralOwner 值表示与该节点绑定的 session id. 如果该节点不是<br>ephemeral 节点, ephemeralOwner 值为 0.<br>dataLength:节点数据字节数<br>numChildren:子节点数量</p>
<p><strong>（4）set命令</strong><br>基本格式为：set /path [data]<br>功能为添加或修改 Znode 中的值。<br><img src="https://img-blog.csdnimg.cn/20200717000409240.png" alt="在这里插入图片描述"><br><strong>（5）delete命令</strong><br>基本格式为：delete /path<br>功能为删除 Znode。<br><img src="https://img-blog.csdnimg.cn/20200717000456541.png" alt="在这里插入图片描述"></p>
<h1 id="6、介绍一下Zookeeper的监听机制？"><a href="#6、介绍一下Zookeeper的监听机制？" class="headerlink" title="6、介绍一下Zookeeper的监听机制？"></a>6、介绍一下Zookeeper的监听机制？</h1><p>Zookeeper的监听机制使用的是观察者模式来进行设计的。当客户端注册监听它关心的目录节点(znode)时，当目录节点（znode）发生变化时(数据变化、被删除、子目录节点增加或者删除)时，Zookeeper会通知客户端。但是watcher通知客户端时，只告诉客户端发生了事件而不会告知其内容，并且无论是客户端还是服务端，一旦一个监听器watcher被触发就会被zookeeper从相应的存储中删除，</p>
<h1 id="7、Zookeeper哪些部署模式？"><a href="#7、Zookeeper哪些部署模式？" class="headerlink" title="7、Zookeeper哪些部署模式？"></a>7、Zookeeper哪些部署模式？</h1><p>Zookeeper有三种部署模式：<br>（1）单机部署：一台集群上运行；<br>（2）集群部署：多台集群上运行；<br>（3）伪集群部署：一台集群上启动多个Zookeeper实例运行。</p>
<h1 id="8、Zookeeper中的服务器角色"><a href="#8、Zookeeper中的服务器角色" class="headerlink" title="8、Zookeeper中的服务器角色"></a>8、Zookeeper中的服务器角色</h1><p><strong>（1）Leader 领导者</strong><br>它是事务请求的唯一调度和处理者，保证集群事务处理的顺序性，同时也是集群内部各服务的调度者。</p>
<p><strong>（2）Follower跟随者</strong><br>主要是处理客户端的非事务请求，转发事务请求给 Leader 服务器，同时参与事务请求 Proposal 的投票，还有参与 Leader 选举投票。</p>
<p><strong>（3）Observer观察者</strong><br>它是3.0 版本以后引入的一个服务器角色，有在不影响集群事务处理能力的基础上提升集群的非事务处理能力，可以处理客户端的非事务请求，转发事务请求给 Leader 服务器，但是它不参与任何形式的投票</p>
<h1 id="9、zookeeper-怎么保证主从节点的状态同步"><a href="#9、zookeeper-怎么保证主从节点的状态同步" class="headerlink" title="9、zookeeper 怎么保证主从节点的状态同步"></a>9、zookeeper 怎么保证主从节点的状态同步</h1><p>zookeeper 的核心是原子广播机制，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者(Leader)崩溃后，zab 就进入了恢复模式，当领导者(Leader)被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p>
<h1 id="10、集群中为什么要有主节点（master）？"><a href="#10、集群中为什么要有主节点（master）？" class="headerlink" title="10、集群中为什么要有主节点（master）？"></a>10、集群中为什么要有主节点（master）？</h1><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，而其他的机器可以共享这个结果，这样就可以大大减少了重复计算，从而提高性能，因此就需要有主节点。</p>
<h1 id="11、集群中有三台服务器，假如其中一个节点宕机了，这个时候的zookeeper还能继续使用吗？"><a href="#11、集群中有三台服务器，假如其中一个节点宕机了，这个时候的zookeeper还能继续使用吗？" class="headerlink" title="11、集群中有三台服务器，假如其中一个节点宕机了，这个时候的zookeeper还能继续使用吗？"></a>11、集群中有三台服务器，假如其中一个节点宕机了，这个时候的zookeeper还能继续使用吗？</h1><p>可以继续使用，Zookeeper本身也是集群，推荐的是配置不少于3台服务器，也就是说Zookeeper自身也要保证当其中一个节点宕机之后其他的节点也能正常的提供服务。Zookeeper的集群机制就是只要超过半数的节点正常，zookeeper就会正常的提供服务，只有当zookeeper节点宕（dang）得太多了，能工作的节点只剩下一半或者是不到一半的时候，集群才会失效。<br>比如说：3个节点的集群最多只能挂掉一个节点，2个节点的集群就不能挂掉任何一个节点。</p>
<h1 id="12、集群最少要几台机器？集群规则是怎样的？集群中有3台服务器，其中有一个节点宕机，这个时候Zookeeper还可以使用吗？"><a href="#12、集群最少要几台机器？集群规则是怎样的？集群中有3台服务器，其中有一个节点宕机，这个时候Zookeeper还可以使用吗？" class="headerlink" title="12、集群最少要几台机器？集群规则是怎样的？集群中有3台服务器，其中有一个节点宕机，这个时候Zookeeper还可以使用吗？"></a>12、集群最少要几台机器？集群规则是怎样的？集群中有3台服务器，其中有一个节点宕机，这个时候Zookeeper还可以使用吗？</h1><p> 集群规则为<strong>2N+1</strong>台，即最少需要3台机器。<br> 可以继续使用，单数服务器只要没超过一半多点服务器宕机就可以继续使用。</p>
<h1 id="13、说一下Zookeeper的应用场景。"><a href="#13、说一下Zookeeper的应用场景。" class="headerlink" title="13、说一下Zookeeper的应用场景。"></a>13、说一下Zookeeper的应用场景。</h1><p>zookeeper是一个经典的发布/订阅模式的分布式服务框架，开发人员经常使用它来进行一些分布式数据的发布/订阅（注册中心），一般有以下几个应用场景：<br>（1）数据发布/订阅；<br>（2）统一命名服务；<br>（3）分布式协调/通知；<br>（4）集群管理；<br>（5）负载均衡；<br>（6）分布式锁；<br>（7）分布式队列</p>
<p>返回首页：<a target="_blank" rel="noopener" href="https://oldou.github.io/">点击此处</a></p>
<p><strong>本文全属查阅资料以及平时自己笔记整理所写（不喜勿喷！），如有不正确的地方，请在评论区说明，我会及时进行更正。</strong></p>
<p><strong>现在暂时内容有些少，后面会持续更新……….</strong></p>
<p><strong>互相学习，互相进步！</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/13/Zookeeper%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" data-id="ckf1vxjf80004k0ukc1io5s6c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Zookeeper%E5%AD%A6%E4%B9%A0/" rel="tag">Zookeeper学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-个人博客之Windows下如何使用Hexo搭建个人博客" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/13/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BWindows%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" class="article-date">
  <time datetime="2020-07-13T07:30:33.000Z" itemprop="datePublished">2020-07-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">个人博客</a>►<a class="article-category-link" href="/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/13/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BWindows%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">个人博客之Windows下如何使用Hexo搭建个人博客</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>身为程序猿，刚入坑Java时，看到别人搭建的个人博客，心里往往都是很羡慕的（反正我是羡慕的），<br>以至于很想拥有一个自己的个人博客，而前一段时间在bilibili上面找到了一个关于个人博客的搭建视频，<br>up主是羊哥，真的特别感谢他，这是他的bilili视频链接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Yb411a7ty">https://www.bilibili.com/video/BV1Yb411a7ty</a><br>羊哥使用的是Mac环境下搭建的博客，今天把就从视频中所学到的、我在Windows环境如何搭建个人博客分享出来。</p>
<h1 id="我的个人博客"><a href="#我的个人博客" class="headerlink" title="我的个人博客"></a>我的个人博客</h1><p><a target="_blank" rel="noopener" href="https://oldou.github.io/">点这里</a></p>
<h1 id="第一步：下载安装Node-js"><a href="#第一步：下载安装Node-js" class="headerlink" title="第一步：下载安装Node.js"></a>第一步：下载安装Node.js</h1><p>首先我们要安装Node.js，官网的地址为：<a target="_blank" rel="noopener" href="https://nodejs.org/en/">nodejs.org</a><br><img src="https://img-blog.csdnimg.cn/20200719000017621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下载LTS版，下载好之后点击安装就好了。<br><img src="https://img-blog.csdnimg.cn/20200719000221845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>安装完成之后是以下界面：<br><img src="https://img-blog.csdnimg.cn/20200719000137602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>安装成功之后可以使用Windows运行CMD打开命令窗口，使用下图中的两个命令查看：<br><img src="https://img-blog.csdnimg.cn/20200719000421740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="第二步-安装cnpm管理器以及hexo框架"><a href="#第二步-安装cnpm管理器以及hexo框架" class="headerlink" title="第二步 安装cnpm管理器以及hexo框架"></a>第二步 安装cnpm管理器以及hexo框架</h1><p><strong>（2.1）安装淘宝的cnpm管理器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;http:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>安装成功之后去查看一下cnpm的版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure>
<p><strong>（2.2）安装hexo框架</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli </span><br></pre></td></tr></table></figure>
<p>安装成功之后查看一下hexo的版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v </span><br></pre></td></tr></table></figure>

<h1 id="第三步-开始搭建博客"><a href="#第三步-开始搭建博客" class="headerlink" title="第三步 开始搭建博客"></a>第三步 开始搭建博客</h1><p>这个时候我们可以现在其他盘中新建一个目录专门用于存放博客文件，我是建在了D:\MyHexoBlogs\blog  ，这里直接手动建文件夹即可，然后在windows命令窗口中执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）先使用  d:   调到D盘</span><br><span class="line">（2）然后再使用   cd D:\MyHexoBlogs\blog   进入到blog目录下</span><br><span class="line">（3）使用命令：hexo init  进行初始化</span><br></pre></td></tr></table></figure>
<p>初始化时可能会有点慢，初始化完毕之后就可以去启动博客了。<br>启动博客的命令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（4）hexo s</span><br></pre></td></tr></table></figure>
<p>之后最后输出的信息会有一个地址：localhost:4000<br>浏览器中输入改地址就可以看见博客页面了。</p>
<h1 id="开始写第一篇博客"><a href="#开始写第一篇博客" class="headerlink" title="开始写第一篇博客"></a>开始写第一篇博客</h1><p>输入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new “我的第一篇博客文章”</span><br></pre></td></tr></table></figure>
<p>由于windows不能使用vim命令去编辑，于是我们直接找到博客安装目录<br>D:\MyHexoBlogs\blog\source_posts下找到新建的那个文件，编辑一些内容<br><img src="https://img-blog.csdnimg.cn/20200719002643957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用MarkDown格式随便写点内容进去方便测试，写完之后保存，叉掉。<br>接下来便是在命令窗口中清理一下之前的内容，然后生成、再启动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）hexo clean</span><br><span class="line">（2）hexo g</span><br><span class="line">（3）hexo s</span><br></pre></td></tr></table></figure>
<p>然后浏览器访问的那个地址刷新一下就可以看见我们书写的博客了。</p>
<h1 id="将个人博客部署到Github上"><a href="#将个人博客部署到Github上" class="headerlink" title="将个人博客部署到Github上"></a>将个人博客部署到Github上</h1><p>这里要自己先去注册一个Github账号。<br>然后登录之后新建一个仓库，如图所示：<br><img src="https://img-blog.csdnimg.cn/20200719003026824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200719003056385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>根据上图中的内容来，这里特别注意的是地址的前面必须是自己的Github账号名。</strong><br><img src="https://img-blog.csdnimg.cn/20200719003233442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>创建好之后就会生成一个连接，如图中描述，地址一定要记好了。</p>
<p>接下来便是回到我们的命令窗口，要安装一下部署插件。<br>命令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install –save hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p>安装完成之后去编辑D:\MyHexoBlogs\blog目录下的一个_config.yml文件，我们直接鼠标右键打开(这里如果电脑没有编辑这种文件的软件，建议下载一个<a target="_blank" rel="noopener" href="https://dl.pconline.com.cn/html_2/1/117/id=10699&pn=0.html">Notepad++</a>）。<br>在文件的底部编辑以下图中的内容：<br><img src="https://img-blog.csdnimg.cn/20200719003904919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>需要注意的是，里面的地址为自己创建好的Github仓库地址，<br>然后中间是有空格的！！！！！！！</strong></p>
<p>接下来便是将博客部署到Github中去，在命令窗口中使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d    部署的意思</span><br></pre></td></tr></table></figure>
<p>然后就会让你输入你的Github的账号和密码，输入完成之后就会进行验证，部署成功之后，去Github创建的仓库中查看就可以看见自己的博客项目了。<br><img src="https://img-blog.csdnimg.cn/2020071900433122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="访问我们部署到Github的博客"><a href="#访问我们部署到Github的博客" class="headerlink" title="访问我们部署到Github的博客"></a>访问我们部署到Github的博客</h1><p>接下来输入自己的github仓库名地址：<a target="_blank" rel="noopener" href="https://oldou.github.io/">https://oldou.github.io/</a><br>以上为我的Github地址，大家只要改为自己的即可。以下便是访问到的博客页面。<br><img src="https://img-blog.csdnimg.cn/20200719004824812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="怎么更换博客主题？"><a href="#怎么更换博客主题？" class="headerlink" title="怎么更换博客主题？"></a>怎么更换博客主题？</h1><p>本次介绍的是yilia主题，地址在<a target="_blank" rel="noopener" href="https://github.com/litten/hexo-theme-yilia">https://github.com/litten/hexo-theme-yilia</a><br>然后克隆该项目，将地址复制<img src="https://img-blog.csdnimg.cn/20200719005136558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>回到我们的命令窗口，使用shdir可以查看当前目录，这里介绍一下，如果觉得博客没啥用了，可以直接将blog文件夹删除即可。</p>
<p>拷贝了那个链接，接下来我们使用命令将主题克隆过来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia.git themes&#x2F;yilia</span><br></pre></td></tr></table></figure>
<p>由于GitHub仓库是国外的，所以可能会比较慢，耐心等待几分钟<br>克隆好之后Windows直接去D:\MyHexoBlogs\blog\themes文件夹中就可以看见yilia文件已经下载好了。<br><img src="https://img-blog.csdnimg.cn/20200719005616839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下载好了接下来就是将这个主题配置到我们的博客中，<br>找到我们的_config.yml文件，这个文件比较重要，用编辑器打开<br><img src="https://img-blog.csdnimg.cn/20200719005659913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>以后想换主题了就这样还，然后保存退出，之后就是命令的连式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在窗口中使用hexo clean 清理一下</span><br><span class="line">然后重新生成一下hexo g</span><br><span class="line">再重新start一下：hexo s</span><br><span class="line">接下来再去访问losthost:4000就发现主题变了</span><br><span class="line">接下来ctrl+C退出</span><br><span class="line">我们将这个博客再次上传到Github</span><br><span class="line">使用命令hexo d</span><br><span class="line">上传完毕之后我们再去用Github命令访问就发现主题可以了</span><br></pre></td></tr></table></figure>
<p><strong>按照这个顺序来，以后修改主题了一定要到安装的博客目录下执行对应的命令，我的是以下目录。</strong><br><img src="https://img-blog.csdnimg.cn/20200719005943685.png" alt="在这里插入图片描述"></p>
<p><strong>后续我会继续分享我使用个人博客的经验，大家如果喜欢我这次分享的话，就点赞评论一下，大家一起相互学习学习。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/13/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BWindows%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" data-id="ckf1vxjfa0005k0uk5xr5bf27" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" rel="tag">个人博客</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" rel="tag">经验分享</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring常见面试题整理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/12/Spring%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" class="article-date">
  <time datetime="2020-07-12T10:38:45.000Z" itemprop="datePublished">2020-07-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/12/Spring%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">Spring常见面试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1、Spring是什么？"><a href="#1、Spring是什么？" class="headerlink" title="1、Spring是什么？"></a>1、Spring是什么？</h1><p> Sprin是一个轻量级的IOC和AOP容器框架，它能够解决企业级应用开发的业务逻辑层和其他各层之间的耦合问题，简化企业级应用程序开发的复杂性，即简化Java开发。<br> Spring有两个核心特性分别是：IOC(控制反转)和AOP(面向切面编程)。</p>
<h1 id="2、使用Spring有什么优点？解释一下为什么要使用Spring？"><a href="#2、使用Spring有什么优点？解释一下为什么要使用Spring？" class="headerlink" title="2、使用Spring有什么优点？解释一下为什么要使用Spring？"></a>2、使用Spring有什么优点？解释一下为什么要使用Spring？</h1><p>（1）方便解耦，简化开发<br>                Spring就像是一个大工厂，可以将所有对象的创建和依赖关系的维护都交给Spring管理，从而减低组件的耦合性；<br>（2）AOP编程的支持<br>                Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控、扩展程序功能等等；<br>（3）声明式事务的支持<br>                只需要通过配置就可以完成对事务的管理，无需手动编程；<br>（4）方便程序的测试<br>                Spring对Junit4的支持，可以通过注解方便的测试Spring程序；<br>（5）方便集成各种优秀的框架</p>
<h1 id="3、Spring有哪些主要模块？"><a href="#3、Spring有哪些主要模块？" class="headerlink" title="3、Spring有哪些主要模块？"></a>3、Spring有哪些主要模块？</h1><p>（1）Spring Core ：框架最基础的部分，提供IOC容器，对bean进行管理；</p>
<p>（2）Spring Context：基于bean，提供上下文对象，扩展出JNDI、EJB、电子邮件、校验调度等功能。</p>
<p>（3）Spring DAO：提供了JDBC的抽象层，它可以消除冗(rong)长的JDBC编码和解析数据库厂商特有的错误代码，还提供了声明式事务管理方法。</p>
<p>（4）Spring ORM：提供了常用的“对象/关系”映射APIs的集成。其中包括JPA、JDO、Mybatis等。</p>
<p>（5）Spring AOP：提供了符合AOP Alliance规范的面向切面的编程实现。</p>
<p>（6）Spring Web：提供了基础的Web开发的上下文信息，可与其他web进行集成。</p>
<p>（7）Spring Web MVC：提供了Web应用的Model-View-Controller全功能的实现。</p>
<h1 id="4、介绍一下SpringIOC，使用IOC有什么好处？"><a href="#4、介绍一下SpringIOC，使用IOC有什么好处？" class="headerlink" title="4、介绍一下SpringIOC，使用IOC有什么好处？"></a>4、介绍一下SpringIOC，使用IOC有什么好处？</h1><p>IOC，Inversion of Control（控制反转），它是一种设计思想，就是将你设计好的对象交给容器控制，而不是自己去创建。把创建和查找依赖对象的控制权交给IOC容器，由IOC容器进行注入、组合对象。</p>
<p> 优点：实现了对象与对象之间的松耦合、便于测试、功能可复用，减少了对象的创建和内存的消耗，使得程序的整体结构变得更方便维护、灵活性更高、扩展性更强。</p>
<p>大白话解释：<br>IOC就是控制反转，就是让一个对象的创建不用自己去new了，使用Spring之后对象可以自动的产生，这其实就是利用了java中的反射，反射其实就是在运行时动态的去创建、调用对象，Spring就是在运行的时候，在Spring的配置文件，也就是XML文件中来动态的创建对象和调用对象中的方法。</p>
<p>ioc的思想最核心的地方在于，资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处。<br>第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。</p>
<p>举例子说：<br>比如甲方需要一双袜子，而乙方它卖一双袜子，它要把袜子卖出去，但是乙方要告诉别人我要卖一双袜子。甲乙双方进行交易活动，但是他们都不需要自己直接去找卖家，相当于程序内部开放接口，卖家由第三方作为参数传入。甲乙互相不依赖，而且只有在进行交易活动的时候，甲才和乙产生联系。反之亦然。这样做什么好处么呢，甲乙可以在对方不真实存在的情况下独立存在，而且保证不交易时候无联系，想交易的时候可以很容易的产生联系。甲乙交易活动不需要双方见面，避免了双方的互不信任造成交易失败的问题。因为交易由第三方来负责联系，而且甲乙都认为第三方可靠。那么交易就能很可靠很灵活的产生和进行了。</p>
<h1 id="5、SpringIOC创建对象的方式有哪些？"><a href="#5、SpringIOC创建对象的方式有哪些？" class="headerlink" title="5、SpringIOC创建对象的方式有哪些？"></a>5、SpringIOC创建对象的方式有哪些？</h1><p>（1）通过无参构造器创建对象；<br>（2）通过有参构造器创建对象；<br>（3）通过工厂模式创建对象。</p>
<h1 id="6、SpringIOC的三种注入方式分别是什么？"><a href="#6、SpringIOC的三种注入方式分别是什么？" class="headerlink" title="6、SpringIOC的三种注入方式分别是什么？"></a>6、SpringIOC的三种注入方式分别是什么？</h1><p>（1）通过构造器注入；<br>（2）通过set方法注入；<br>（3）通过注解自动注入；</p>
<h1 id="7、介绍一下Spring-AOP。"><a href="#7、介绍一下Spring-AOP。" class="headerlink" title="7、介绍一下Spring AOP。"></a>7、介绍一下Spring AOP。</h1><p> AOP全名为Aspect Oriented Programming，面向切面编程。<br>作为面向对象的一种补充，用于将那些与业务无关，但是却对多个对象产生影响的公共行为和逻辑，抽取并封装成一个可重用的模块，这个模块被命名为切面（Aspect），减少了系统的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p>
<p>SpringAOP实现的关键在于代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表就是AspectJ；动态代理则以SpringAOP为代表。</p>
<h1 id="8、Spring-AOP中的几个名词解释。"><a href="#8、Spring-AOP中的几个名词解释。" class="headerlink" title="8、Spring AOP中的几个名词解释。"></a>8、Spring AOP中的几个名词解释。</h1><p>（1）切面（Aspect）：切面其实就是切点和通知的结合。切点和通知共同定义了切面中的内容，在SpringAOP中切面可以使用通用类(基于模板风格)或者是在普通类中使用@AspectJ注解来实现。</p>
<p>（2）连接点（Join point）：指的是方法，在SpringAOP中一个连接点总是代表着一个方法的执行。</p>
<p>（3）通知（Advice）：在切面上某个连接点上执行的动作，通俗的说就是我们需要扩展的功能代码，通知又分为前置通知（before）、后置通知（after）、环绕通知（around）、异常通知等。</p>
<p>（4）切入点（Pointcut）：指的是我们需要对哪些连接点进行拦截，通过切入点表达式可以指定拦截的方法。</p>
<p>（5）引入（Introduction）：引入允许我们想现有类添加新方法或者属性；</p>
<p>（6）目标对象（Target Object）：被一个或者多个切面所通知的对象。通常为一个代理对象。</p>
<p>（7）织入（Weaving）：织入就是把切面应用到目标对象并创建新的代理对象的过程，Spring在运行时完成织入。</p>
<h1 id="9、介绍一下SpringAOP的动态代理模式。"><a href="#9、介绍一下SpringAOP的动态代理模式。" class="headerlink" title="9、介绍一下SpringAOP的动态代理模式。"></a>9、介绍一下SpringAOP的动态代理模式。</h1><p> SpringAOP的动态代理模式主要有两种，分别是JDK动态代理和CGLIB动态代理。<br>（1）JDK动态代理只提供接口的代理，不支持类代理。核心为InvocationHandler接口和Proxy类，InvocationHandler接口通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务逻辑编织在一起，接着Proxy就利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。</p>
<p>（2）CGLIB动态代理，代理类没有实现InvocationHandler接口，它是一个代码生成的类库，可以在运行时动态地生产指定类的一个子类对象，并且覆盖其中特定方法来增强代码，从而实现代理；CGLIB是通过继承的方式做的动态代理，如果某个类被标记为final，那么它就无法使用CGLIB做动态代理的。</p>
<p>静态代理和动态代理的区别在于生成代理对象的时机不一样，相对来说静态代理AspectJ的静态代理方式具有更好的性能。</p>
<h1 id="10、Spring的bean是什么？它是线程安全的吗？"><a href="#10、Spring的bean是什么？它是线程安全的吗？" class="headerlink" title="10、Spring的bean是什么？它是线程安全的吗？"></a>10、Spring的bean是什么？它是线程安全的吗？</h1><p>Spring bean是那些形成Spring应用主干的Java对象，它们被SpringIOC容器初始化、装配和管理，这些beans通过在容器中配置的元数据创建。<br>        默认的Spring容器中的bean是单例的，当单例中存在竞争条件时，会有线程安全问题。<br>        Spring管理的bean的线程安全跟bean的创建作用域和bean所在的使用环境是否存在竞争有关，Spring并不能保证bean的线程安全。</p>
<h1 id="11、Spring支持几种bean的作用域？"><a href="#11、Spring支持几种bean的作用域？" class="headerlink" title="11、Spring支持几种bean的作用域？"></a>11、Spring支持几种bean的作用域？</h1><p>（1）Singleton：单例模式，在整个SpringIOC容器中，使用singleton定义的bean只有一个实例；</p>
<p>（2）prototype：原型模式，每次通过容器的getbean方式获取prototype定义的bean时，都产生了一个新的bean实例。</p>
<p>只有在Web应用中使用Spring时，request、session、global-session作用域才会生效。<br>（3）request：对于每次HTTP请求，使用request定义的bean都将产生一个新实例，即每次HTTP请求将会产生不同的bean实例。</p>
<p>（4）session：同一个Session共享一个bean实例。</p>
<p>（5）global-session：同session作用域不同的是，所有的Session共享一个Bean实例。</p>
<h1 id="12、Spring自动装配bean有哪些方式？"><a href="#12、Spring自动装配bean有哪些方式？" class="headerlink" title="12、Spring自动装配bean有哪些方式？"></a>12、Spring自动装配bean有哪些方式？</h1><p>（1）no方式，默认的方式，不自动装配，需要使用到<ref/>节点或者参数；</p>
<p>（2）byName：根据bean的名称进行装配；</p>
<p>（3）byType：通过参数的数据类型进行装配；</p>
<p>（4）constructor：根据构造函数进行装配。</p>
<p>（5）Spring配置文件中<bean>节点的Autowire参数可以控制bean自动装配的方式。</p>
<h1 id="13、介绍一下Spring支持的事务管理类型？"><a href="#13、介绍一下Spring支持的事务管理类型？" class="headerlink" title="13、介绍一下Spring支持的事务管理类型？"></a>13、介绍一下Spring支持的事务管理类型？</h1><p>   Spring支持两种两种事物管理，一种是编程式事务管理，另外一种是声明式事务管理。<br>（1）编程式事务管理：指的是通过编码方式实现事务，允许用户在代码中精确定义事务的边界。即类似于JDBC编程实现事务管理。</p>
<p>（2）声明式事务管理：管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。</p>
<p>声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中。</p>
<p>声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式，使业务代码不受污染，只要加上注解就可以获得完全的事务支持。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p>
<h1 id="14、介绍一下Spring的事务隔离级别？（重点）"><a href="#14、介绍一下Spring的事务隔离级别？（重点）" class="headerlink" title="14、介绍一下Spring的事务隔离级别？（重点）"></a>14、介绍一下Spring的事务隔离级别？（重点）</h1><p>   Spring有五大事务隔离级别，其中Spring默认的事务隔离级别为：ISOLATION_DEFAULT（使用的是数据库的设置），其他的四个事务隔离级别和数据库的隔离级别一致。<br><strong>（1）ISOLATION_DEFAULT</strong>：用的底层数据库的设置隔离级别，数据库设置的是什么就用什么。</p>
<p><strong>（2）ISOLATION_READ_UNCOMMITTED</strong>：未提交读，最低的事务隔离级别，事务未提交前就可以被其他事务读取，会出现幻读、脏读，不可重复读。</p>
<p><strong>（3）ISOLATION_READ_COMMITTED</strong> ：已提交读，一个事务提交后才能被其他事务读取到（可能会造成幻读、不可重复读），SQL Server的默认级别（Oracle的默认隔离级别）。</p>
<p><strong>（4）ISOLATION_REPEATABLE_READ</strong>：可重复读，保证多次读取同一个数据时，其值都和事务开始的时候的内容一致，禁止读取到别的事务未提交的数据（可能会造成幻读），这是MYSQL的默认隔离级别。</p>
<p><strong>（5）ISOLATION_SERIALIZABLE</strong>：序列化，代价最高的但是最可靠的隔离级别，该级别能够防止脏读、不可重复读、幻读。</p>
<p><strong>脏读</strong>：表示一个事务能够读取另一个事务未提交的数据；<br><strong>幻读</strong>：指的是同一个事务多次查询返回的结果集不一样。<br><strong>不可重复读</strong>：指的是在一个事务中多次读取同一个数据。</p>
<h1 id="15、介绍一下关于事务的四个特性（ACID）"><a href="#15、介绍一下关于事务的四个特性（ACID）" class="headerlink" title="15、介绍一下关于事务的四个特性（ACID）"></a>15、介绍一下关于事务的四个特性（ACID）</h1><p>事务有四个特性（ACID），分别是原子性、一致性、隔离性、持久性。<br><strong>（1）原子性（Atomicity）</strong>：事务是一个原子操作，由一系列动作组成。事务的原子性能够确保动作（增、删、改）要么全部完成，要么不起作用。</p>
<p><strong>（2）一致性（Consistency）</strong>：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败，在现实中的数据不应该被破坏。</p>
<p><strong>（3）隔离性（Isolation）</strong>：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，以此防止数据损坏。</p>
<p><strong>（4）持久性（Durability）</strong>：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下事务的结果被写到持久化存储器中。</p>
<h1 id="16、Spring的事务传播行为介绍"><a href="#16、Spring的事务传播行为介绍" class="headerlink" title="16、Spring的事务传播行为介绍"></a>16、Spring的事务传播行为介绍</h1><p>Spring的事务传播行为说的是当多个事务同时存在的时候，Spring是如何处理这些事务的行为的。<br><strong>（1）PROPAGATION_REQUIRED</strong>：如果当前没有事务就创建一个新的事务，如果当前存在事务就加入该事务，该设置是最常用的设置，同时也是默认值；</p>
<p><strong>（2）PROPAGATION_SUPPORTS</strong>：支持当前事务，如果当前存在事务就加入当前事务，如果当前不存在事务就以非事务执行；</p>
<p>（3）PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务就加入该事务，如果当前不存在事务就抛出异常；</p>
<p>（4）PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务都创建新事务；</p>
<p>（5）PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起；</p>
<p>（6）PROPAGATION_NEVER：以非事务的方式执行，如果当前存在事务，则抛出异常；</p>
<p>（7）PROPAGATION_NESTED：如果当前存在事务，则嵌套事务内执行，如果当前没有事务就按REQUIRED属性执行。</p>
<h1 id="17、Spring的注解介绍"><a href="#17、Spring的注解介绍" class="headerlink" title="17、Spring的注解介绍"></a>17、Spring的注解介绍</h1><p>Spring常见的注解及其作用：<br><strong>（1）@Conponent</strong>：创建类对象，相当于配置<bean/>，bean的ID默认为类名首字母小写，同时也可以指定ID，例如@Conponent(“stu”)；</p>
<p><strong>（2）@Service</strong>：作用和@Conponent一样，创建类对象，但是它是作用在业务层实现类上；</p>
<p><strong>（3）@Repository</strong>：作用和@Conponent一样，也是创建类对象，但是它是作用在数据访问层上；</p>
<p><strong>（4）@Controller</strong>：作用和@Conponent一样，创建类对象，作用在控制器类上；</p>
<p><strong>（5）@Resource</strong>：使用了这个注解之后就不需要写对象的get/set方法了，它是Java的注解，默认是按照byName方式注入，如果没有名称对象就按照byType注入，使用这个注解的时候建议把对象名称写成和Spring容器中对象名一致。</p>
<p><strong>（6）@Autowired</strong>：自动注入，使用了这个注解同样不需要写对象的get、set方法了，它是Spring的注解，同样也是最常用的注解之一，默认是按照byType进行注入。</p>
<p>（7）@Value()：这个注解是获取properties配置文件中的内容。</p>
<p><strong>（8）@RequestMapping</strong>：此注解用于将特定的HTTP请求映射到将处理相应请求的控制器中的特定类/方法。此注解可应用于两个级别：<br>        A、类级别：映射请求的URL；<br>        B、方法级别：映射URL以及HTTP请求方法。</p>
<p><strong>（9）@Configuration</strong>：该注解用于定义配置类，可替换xml配置文件，被该注解标注的类内部包含一个或者多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，从而初始化Spring容器。<br>@Configuration标注在类上，相当于把该类作为spring的xml配置文件中的<beans>，作用为：配置spring容器(应用上下文)。</p>
<h1 id="18、-Autowired-、-Inject、-Resource-之间有什么区别？"><a href="#18、-Autowired-、-Inject、-Resource-之间有什么区别？" class="headerlink" title="18、 @Autowired 、 @Inject、@Resource 之间有什么区别？"></a>18、 @Autowired 、 @Inject、@Resource 之间有什么区别？</h1><p>（1）@Autowired是Spring提供的注解，而@Inject和@Resource是java规范的；<br>（2）@Autowired和@Inject基本是一样的，都是使用AutowiredAnnotationBeanPostProcessor来处理依赖注入，但是@Resouece是个例外，它是由CommonAnnotationBeanPostProcessor来处理依赖注入的；<br>（3）@Autowired是spring实现的，@Inject是jsr330实现的，@Resouece是jsr250实现的。</p>
<h1 id="19、-Configuration-如何嵌套？-Configuration-使用上有哪些约束？"><a href="#19、-Configuration-如何嵌套？-Configuration-使用上有哪些约束？" class="headerlink" title="19、@Configuration 如何嵌套？@Configuration 使用上有哪些约束？"></a>19、@Configuration 如何嵌套？@Configuration 使用上有哪些约束？</h1><p>@Configuration注解作用在类上，就和普通类一样能够进行相互嵌套，定义内部类就可以进行相互嵌套。<br>这个注解的使用约束如下所示：<br>（1）必须以类的方式提供（而不是从工厂方法返回的实例）；<br>（2）被@Configuration注解的类必须是非final的；<br>（3）任何嵌套的@Configuration都必须是static的；<br>（4）@Bean方法可能不会反过来创建更多配置类；<br>（5）配置类必须是本地的（可能不在方法中声明），native标注的方法。</p>
<h1 id="20、Spring项目怎么进行单元测试？"><a href="#20、Spring项目怎么进行单元测试？" class="headerlink" title="20、Spring项目怎么进行单元测试？"></a>20、Spring项目怎么进行单元测试？</h1><p>首先加载Spring的jar包，Spring-test-4.0.4-RELEASE.jar和commons-logging-1.2.jar<br>然后再applicationContext.xml中扫描service实现包，<br>&lt;context:component-scan base-package=”service.impl”&gt;</context:component-scan><br>之后在UserServiceImpl实现类上使用springmvc 注解@Service(“userService”)<br>编写spring单元测试，点击运行。<br><img src="https://img-blog.csdnimg.cn/20200717224221927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>@RunWith(SpringJUnit4ClassRunner.class) 上面已做介绍。<br>@ContextConfiguration(locations={“classpath:applicationContext.xml”})加载配置文件，locations参数是一个数组，可以加载多个，配置文件。<br>@Resource 自动注入Ioc容器的对应的bean。<br>@Test 我们的测试方法。</p>
<h1 id="21、Spring-框架中都用到了哪些设计模式？"><a href="#21、Spring-框架中都用到了哪些设计模式？" class="headerlink" title="21、Spring 框架中都用到了哪些设计模式？"></a>21、Spring 框架中都用到了哪些设计模式？</h1><p>（1）工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</p>
<p>（2）单例模式：Bean默认为单例模式。</p>
<p>（3）代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</p>
<p>（4）模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</p>
<p>（5）观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，<br>                 所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</p>
<h1 id="22、Spring如何处理线程并发问题？"><a href="#22、Spring如何处理线程并发问题？" class="headerlink" title="22、Spring如何处理线程并发问题？"></a>22、Spring如何处理线程并发问题？</h1><p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，<br>在Spring中，绝大部分Bean都可以声明为singleton作用域，<br>因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p>
<h1 id="23、Spring项目是如何启动的？"><a href="#23、Spring项目是如何启动的？" class="headerlink" title="23、Spring项目是如何启动的？"></a>23、Spring项目是如何启动的？</h1><p><img src="https://img-blog.csdnimg.cn/2020071816102833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如上图所示，Spring项目在启动时，首先会去读取应用程序提供的Bean配置信息，并且会在Spring容器中生成一份对应的Bean配置注册表，然后根据这张注册表实例化Bean，装配好Bean之间的依赖关系，为上层应用提供准备就绪的运行环境。</p>
<p>关于图中步骤的详细说明：<br>第一步：<strong>读取Bean的配置信息</strong>，对于Bean的配置有很多种方式，比如说可以在Spring的XML文件当中使用<bean/>标签声明一个bean，除此之外还可以在Java的类当中使用@Configuration注解来标识它是一个配置类，还可以通过@Autowired注解来完成一个对象的注入配置，这些信息肯定是要Spring去读取的；</p>
<p>第二步：Spring启动读到Bean配置文件解析出来的信息之后，会将读取到的需要注册的Bean加到Spring容器中（就是IOC容器），在里面会形成一个Bean定义的注册表，然后Spring会根据注册表里面的信息将Bean对象进行实例化，把配置的Bean都要做一次实例化，在实例化的过程中完成依赖注入。</p>
<p>第三步：之后便是将已经实例化的Bean对象放回Spring的容器当中，放到Bean的缓存池里，当我们应用程序需要用到这个Bean的时候，就会调用getBean方法去缓存池中调用。其实都是去的Spring容器中的Bean缓存池里去取的Bean对象。</p>
<h1 id="目前尚未理解的问题有以下："><a href="#目前尚未理解的问题有以下：" class="headerlink" title="目前尚未理解的问题有以下："></a>目前尚未理解的问题有以下：</h1><p>24、Spring如何对Bean进行延迟初始化？<br>25、@Profile有什么用？<br>26、Spring是如何处理带@Configuration @Import的类？<br>27、@Configuration和XML有什么区别？哪种好？</p>
<p>返回首页：<a target="_blank" rel="noopener" href="https://oldou.github.io/">点击此处</a></p>
<p><strong>你现在的每一刻努力，都有可能是未来的你在向你求救。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/12/Spring%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" data-id="ckf1vxjh90035k0uk0bdl3tvx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring%E5%AD%A6%E4%B9%A0/" rel="tag">Spring学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%AE%B9%E5%99%A8/">Java容器</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%AE%B9%E5%99%A8/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/TCP-IP/">TCP/IP</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/TCP-IP/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Zookeeper/">Zookeeper</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Zookeeper/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Zookeeper/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">个人博客</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/">消息中间件</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%AE%B9%E5%99%A8/" rel="tag">Java容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E5%AD%A6%E4%B9%A0/" rel="tag">Linux学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ%E5%AD%A6%E4%B9%A0/" rel="tag">RabbitMQ学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis%E5%AD%A6%E4%B9%A0/" rel="tag">Redis学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring%E5%AD%A6%E4%B9%A0/" rel="tag">Spring学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/" rel="tag">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zookeeper%E5%AD%A6%E4%B9%A0/" rel="tag">Zookeeper学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" rel="tag">个人博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" rel="tag">经验分享</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">Java基础</a> <a href="/tags/Java%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">Java容器</a> <a href="/tags/Linux%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">Linux学习</a> <a href="/tags/RabbitMQ%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">RabbitMQ学习</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Redis%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">Redis学习</a> <a href="/tags/SpringBoot/" style="font-size: 12.5px;">SpringBoot</a> <a href="/tags/Spring%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">Spring学习</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/tags/Zookeeper%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">Zookeeper学习</a> <a href="/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" style="font-size: 10px;">个人博客</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">学习笔记</a> <a href="/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" style="font-size: 10px;">经验分享</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 12.5px;">设计模式</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 17.5px;">面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/09/09/SpringBoot%E4%B8%AD%E4%BD%BF%E7%94%A8Druid%E6%95%B4%E5%90%88JDBC/">SpringBoot整合JDBC</a>
          </li>
        
          <li>
            <a href="/2020/09/08/%E7%AC%AC%E4%B8%80%E4%B8%AASpringBoot%E7%A8%8B%E5%BA%8F%E4%BB%A5%E5%8F%8A%E5%B0%8F%E5%BD%A9%E8%9B%8B/">第一个SpringBoot程序以及启动图标设置</a>
          </li>
        
          <li>
            <a href="/2020/08/16/Redis%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81/">Redis基本事务以及实现乐观锁</a>
          </li>
        
          <li>
            <a href="/2020/08/16/Redis%E7%9A%84%E4%BA%94%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/">Redis的数据类型（5种基础，3种特殊）</a>
          </li>
        
          <li>
            <a href="/2020/08/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BRedis%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D%E3%80%81%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E3%80%81%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/">Redis的常用命令、配置文件介绍、数据持久化方式、集群搭建</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Mr.ou<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>