<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis基本事务以及实现乐观锁</title>
    <url>/2020/08/16/Redis%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本次测试的环境为：<br>Linux：centos 6.5<br>Redis：redis-5.0.7.tar.gz</p>
<h1 id="Redis-的事务管理"><a href="#Redis-的事务管理" class="headerlink" title="Redis 的事务管理"></a>Redis 的事务管理</h1><h2 id="1、什么是事务？"><a href="#1、什么是事务？" class="headerlink" title="1、什么是事务？"></a>1、什么是事务？</h2><ul>
<li>事务的本质<br>一组命令操作，要么全部执行成功，要么撤销不执行。</li>
</ul>
<p>redis的事务中，一次执行多条命令，本质是一组命令的集合，一个事务中所有的命令将被序列化，即按顺序执行而不会被其他命令插入</p>
<p>在redis中，事务的作用就是在一个队列中一次性、顺序性、排他性的执行一系列的命令。</p>
<p>一个事务中的所有命令都会被序列化，在事务执行的过程中，会按照顺序执行。<br>由于命令会在队列中一次性执行（<strong>一次性</strong>），并且会按照顺序执行（<strong>顺序性</strong>），事务在执行的过程中是不允许被别人干扰的（<strong>排他性</strong>），以此来执行一系列的命令。<br><img src="https://img-blog.csdnimg.cn/20200816224744310.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2、Redis中的事务注意事项"><a href="#2、Redis中的事务注意事项" class="headerlink" title="2、Redis中的事务注意事项"></a>2、Redis中的事务注意事项</h2><ul>
<li><strong>Redis单条命令是保持原子性的，但是Redis事务是不保持原子性的。</strong></li>
<li><strong>Redis事务没有隔离级别的概念。</strong></li>
<li><strong>所有命令在事务中，并没有直接被执行，只有发起执行命令的时候才会执行。Exec</strong></li>
</ul>
<h2 id="3、Redis的事务操作"><a href="#3、Redis的事务操作" class="headerlink" title="3、Redis的事务操作"></a>3、Redis的事务操作</h2><p>Redis的事务操作步骤如下所示：</p>
<ul>
<li>（1）开启事务：<code>multi</code></li>
<li>（2）命令入队：…..</li>
<li>（3）执行事务：<code>exec</code></li>
</ul>
<h2 id="4、正常执行事务"><a href="#4、正常执行事务" class="headerlink" title="4、正常执行事务"></a>4、正常执行事务</h2><p><img src="https://img-blog.csdnimg.cn/20200816224946983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>首先连接Redis，当使用<code>multi</code>命令时，Redis就开启了事务操作，并且之后的set、get等命令操作都会依次进入队列当中，此时并不会执行，当执行<code>exec</code>命令的时候，队列中的命令才会依次执行。</p>
<p><strong>注意</strong>：事务执行完毕后，队列中的命令全部消失（一次性），如果还需要执行其它事务，就需要重新再开启事务写入命令去执行。</p>
<h2 id="5、放弃事务（discard）"><a href="#5、放弃事务（discard）" class="headerlink" title="5、放弃事务（discard）"></a>5、放弃事务（discard）</h2><p>如果在命令入列期间，因为一系列原因想放弃本次事务操作，可以使用<code>discard</code>命令进行事务的取消，<strong>当事务取消时，事务队列中的命令都不会被执行</strong>。如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200816225331943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>使用multi开启事务，并且将两个set命令写入队列，但是执行了<code>discard</code>命令后，本次事务取消，队列中的命令会被清空不执行。因此后面的get操作获取不到值。</p>
<h2 id="6、编译型异常（代码有问题，命令有错），事务中的所有命令都不会被执行。"><a href="#6、编译型异常（代码有问题，命令有错），事务中的所有命令都不会被执行。" class="headerlink" title="6、编译型异常（代码有问题，命令有错），事务中的所有命令都不会被执行。"></a>6、编译型异常（代码有问题，命令有错），事务中的所有命令都不会被执行。</h2><p><img src="https://img-blog.csdnimg.cn/2020081622574741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>如图所示：当开启事务之后，在进行写入命令入队列时，写入的命令出现格式错误或者无此命令等等问题，会出现编译时异常，<strong>此时事务队列中的所有命令都不会被执行</strong>。</p>
<h2 id="7、运行时异常（1-0）"><a href="#7、运行时异常（1-0）" class="headerlink" title="7、运行时异常（1/0）"></a>7、运行时异常（1/0）</h2><p><img src="https://img-blog.csdnimg.cn/20200816230126931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>如上图所示：开启事务后，将命令依次写入队列，期间出现如上图所示时，语法上没有什么错误，但是运行时会报异常，这种异常不会影响其它命令的执行。运行时异常，表示命令是正确的，但是不能正确运算，所以此条命令会报错，但是不会影响其它命令的执行，其它命令还是可以执行的。</p>
<p>Redis中的事务和MySQL中的事务不一样，<br>MySQL中的事务要么全部执行成功，要么全部执行失败。<br>MySQL的事务是保证原子性操作的，但是<strong>Redis的事务是不保证原子性操作的</strong>。</p>
<h2 id="8、总结redis事务的三条性质："><a href="#8、总结redis事务的三条性质：" class="headerlink" title="8、总结redis事务的三条性质："></a>8、总结redis事务的三条性质：</h2><ul>
<li>单独的隔离操作：事务中的所有命令会被序列化、按顺序执行，在执行的过程中不会被其他客户端发送来的命令打断</li>
<li>没有隔离级别的概念：队列中的命令在事务没有被提交之前不会被实际执行</li>
<li>不保证原子性：redis中的一个事务中如果存在命令执行失败，那么其他命令依然会被执行，没有回滚机制</li>
</ul>
<h1 id="Redis实现乐观锁（Watch监控）"><a href="#Redis实现乐观锁（Watch监控）" class="headerlink" title="Redis实现乐观锁（Watch监控）"></a>Redis实现乐观锁（Watch监控）</h1><h2 id="1、乐观锁和悲观锁的概念"><a href="#1、乐观锁和悲观锁的概念" class="headerlink" title="1、乐观锁和悲观锁的概念"></a>1、乐观锁和悲观锁的概念</h2><ul>
<li><p><strong>悲观锁</strong>：顾名思义，就是比较悲观的锁，总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如<strong>行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁</strong>。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p>
</li>
<li><p><strong>乐观锁</strong>：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是<strong>在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制version和CAS算法实现</strong>。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p>
</li>
</ul>
<p><strong>Redis的监控机制，一旦事务执行成功，监控就会自动取消掉。</strong></p>
<h2 id="2、Redis的监控测试"><a href="#2、Redis的监控测试" class="headerlink" title="2、Redis的监控测试"></a>2、Redis的监控测试</h2><h3 id="正常执行成功"><a href="#正常执行成功" class="headerlink" title="正常执行成功"></a>正常执行成功</h3><p><img src="https://img-blog.csdnimg.cn/20200816231322273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="测试多线程修改值，监视失败"><a href="#测试多线程修改值，监视失败" class="headerlink" title="测试多线程修改值，监视失败"></a>测试多线程修改值，监视失败</h3><ul>
<li>第一步：启动两个客户端：<br><img src="https://img-blog.csdnimg.cn/20200816231356576.png" alt="在这里插入图片描述"><ul>
<li>第二步：客户端A开启事务进程部分操作，还没进行提交时，客户端B就对变量money进行操作了。</li>
</ul>
<strong>客户端A操作：</strong><br><img src="https://img-blog.csdnimg.cn/20200816231558584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>客户端B在A事务未提交之前操作如下：</strong><br><img src="https://img-blog.csdnimg.cn/202008162316441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>第三步：客户端A去提交事务，但是由客户端B修改了money，所以事务执行失败<br><img src="https://img-blog.csdnimg.cn/202008162317507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>以上总结</strong>：客户端A在未提交事务之前对money和out进行操作的同时，客户端B改变了Money的值，这个时候客户端A去<code>exec</code>提交事务的时候就提交失败。</li>
</ul>
<h3 id="解决以上问题：如果修改失败，重新获取最新的值就好了"><a href="#解决以上问题：如果修改失败，重新获取最新的值就好了" class="headerlink" title="解决以上问题：如果修改失败，重新获取最新的值就好了"></a>解决以上问题：如果修改失败，重新获取最新的值就好了</h3><p><img src="https://img-blog.csdnimg.cn/2020081623192319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>如果事务执行失败，那么首先执行<code>unwatch</code>命令进行解锁，然后重新获取最新的money，并且再次监控，最后提交时对结果进行对比，如果监视的值发生了变化，那就说明有其它线程正在对money进行修改，那么本次事务执行失败，如果该变量未发生变化，那么事务执行成功。</p>
<p>这里的值变化，指的是，比如说现在money为1000，然后我开启事务操作，写入相应命令入队列，并且执行，而在执行事务之前，也就是执行<code>exec</code>之前money的值发生了变化，那么就说明有其它线程正在修改money，那么事务就执行失败了。</p>
<h1 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h1><blockquote>
<p>Redis可以实现乐观锁吗？</p>
</blockquote>
<p>可以。</p>
<blockquote>
<p>Redis的命令是原子性操作，那么Redis的事务也一定是原子性的对不？</p>
</blockquote>
<p>不对，Redis的事务不具有原子性。Redis的命令之所以是原子性的，是因为因为Redis是单线程的，线程是操作系统最小的执行单元，在单线程程序中，任务一个一个地做，必须做完一个任务后，才会去做另一个任务。</p>
<blockquote>
<p>怎么理解Redis的事务？</p>
</blockquote>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其它客户端发送来的命令请求所打断。</li>
<li>没有隔离级别的概念：队列中的命令在事务没有被提交之前不会被实际执行。</li>
<li>不保证原子性：redis中的一个事务中如果存在命令执行失败，那么其他命令依然会被执行，没有回滚机制</li>
</ul>
<blockquote>
<p>说一下Redis事务的生命周期</p>
</blockquote>
<ul>
<li><p>事务的创建：使用MULTI开启一个事务</p>
</li>
<li><p>命令入队列：在开启事务的时候，每次操作的命令将会被插入到一个队列中，同时这个命令并不会被真的执行</p>
</li>
<li><p>EXEC命令进行提交事务</p>
</li>
</ul>
<blockquote>
<p>Redis中关于事务的命令有哪些？</p>
</blockquote>
<ul>
<li><p>MULTI：使用该命令，标记一个事务块的开始，通常在执行之后会回复OK，（但不一定真的OK），这个时候用户可以输入多个操作来代替逐条操作，redis会将这些操作放入队列中。</p>
</li>
<li><p>EXEC：执行这个事务内的所有命令</p>
</li>
<li><p>DISCARD：放弃事务，即该事务内的所有命令都将取消</p>
</li>
<li><p>WATCH：监控一个或者多个key，如果这些key在提交事务（EXEC）之前被其他用户修改过，那么事务将执行失败，需要重新获取最新数据重头操作（类似于乐观锁）。</p>
</li>
<li><p>UNWATCH：取消WATCH命令对多有key的监控，所有监控锁将会被取消。</p>
</li>
</ul>
<blockquote>
<p>Redis中的事务为什么没有原子性与watch锁</p>
</blockquote>
<p>Redis事务可以一次执行多个命令,它先以 MULTI 开始一个事务， 然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务， 一并执行事务中的所有命令，在Redis中，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做，也因此得出 Redis 事务的执行并不是原子性的。</p>
<p>因为在事务中不能改变被锁的值，所以没有watch锁。  </p>
<blockquote>
<p>创作不易，如果本文对你有帮助，可以点个赞支持一下哈。</p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合JDBC</title>
    <url>/2020/09/09/SpringBoot%E4%B8%AD%E4%BD%BF%E7%94%A8Druid%E6%95%B4%E5%90%88JDBC/</url>
    <content><![CDATA[<h2 id="数据库建表语句"><a href="#数据库建表语句" class="headerlink" title="数据库建表语句"></a>数据库建表语句</h2><p>sql文件在resources文件目录下。</p>
<h2 id="创建项目，导入依赖"><a href="#创建项目，导入依赖" class="headerlink" title="创建项目，导入依赖"></a>创建项目，导入依赖</h2><p>添加以下启动器：<br><img src="https://img-blog.csdnimg.cn/20200911204338835.png" alt="在这里插入图片描述"><br>同时添加以下Maven依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 添加数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="编写application-yml文件"><a href="#编写application-yml文件" class="headerlink" title="编写application.yml文件"></a>编写application.yml文件</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="comment"># ?serverTimezone=UTC解决时区的报错</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/oldou?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span> <span class="comment"># 使用druid数据源</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#Spring Boot 默认是不注入这些属性值的，需要自己绑定</span></span><br><span class="line">    <span class="comment">#druid 数据源专有配置</span></span><br><span class="line">    <span class="attr">initialSize:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">minIdle:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">maxActive:</span> <span class="number">20</span></span><br><span class="line">    <span class="comment"># 连接等待超时时间</span></span><br><span class="line">    <span class="attr">maxWait:</span> <span class="number">60000</span></span><br><span class="line">    <span class="comment"># 配置检测可以关闭的空闲连接间隔时间</span></span><br><span class="line">    <span class="attr">timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span></span><br><span class="line">    <span class="comment"># 配置连接在池中的最小生存时间</span></span><br><span class="line">    <span class="attr">minEvictableIdleTimeMillis:</span> <span class="number">300000</span></span><br><span class="line">    <span class="attr">validationQuery:</span> <span class="string">SELECT</span> <span class="number">1</span> <span class="string">FROM</span> <span class="string">DUAL</span></span><br><span class="line">    <span class="attr">testWhileIdle:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">testOnBorrow:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">testOnReturn:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 打开PSCache，并且指定每个连接上PSCache的大小</span></span><br><span class="line">    <span class="attr">poolPreparedStatements:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">max-open-prepared-statements:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">max-pool-prepared-statement-per-connection-size:</span> <span class="number">20</span></span><br><span class="line">    <span class="comment">#配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入</span></span><br><span class="line">    <span class="comment">#如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority</span></span><br><span class="line">    <span class="comment">#则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j</span></span><br><span class="line">    <span class="attr">filters:</span> <span class="string">stat,wall,log4j</span></span><br><span class="line">    <span class="attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">useGlobalDataSourceStat:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">connectionProperties:</span> <span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="书写DAO层代码"><a href="#书写DAO层代码" class="headerlink" title="书写DAO层代码"></a>书写DAO层代码</h2><p>新建一个com.oldou.dao.UserDao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;insert into user (id,name,pwd) values(?,?,?)&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql,user.getId(),user.getName(),user.getPwd());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID更新用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;update user set name=?,pwd=? where id=?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql,user.getName(),user.getPwd(),user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID删除用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;delete from user where id = ?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql,id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询全部用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; QueryAll()&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select * from user&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForList(sql);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID查询用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">QueryUserByID</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select * from user where id = ?&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> RowMapper&lt;User&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> User <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                User user = <span class="keyword">new</span> User();</span><br><span class="line">                user.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                user.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                user.setPwd(rs.getString(<span class="string">&quot;pwd&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="编写业务层代码"><a href="#编写业务层代码" class="headerlink" title="编写业务层代码"></a>编写业务层代码</h2><p>新建一个com.oldou.service.Uservice接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID删除用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询全部用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; QueryAll();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID查询用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">QueryUserByID</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>com.oldou.service.impl.UserServiceImpl实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; QueryAll() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userDao.QueryAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">QueryUserByID</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userDao.QueryUserByID(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao.updateUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编写Controller层"><a href="#编写Controller层" class="headerlink" title="编写Controller层"></a>编写Controller层</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="comment">//查询user表中所有数据</span></span><br><span class="line">    <span class="comment">//List 中的1个 Map 对应数据库的 1行数据</span></span><br><span class="line">    <span class="comment">//Map 中的 key 对应数据库的字段名，value 对应数据库的字段值</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; queryAllUser()&#123;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = userService.QueryAll();</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据ID查询用户</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/query/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserByID</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        User user = userService.QueryUserByID(id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据ID删除用户</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/delete/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        userService.delete(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;删除用户成功！！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加用户</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userService.save(<span class="keyword">new</span> User(<span class="number">6</span>,<span class="string">&quot;ppp&quot;</span>,<span class="string">&quot;1232&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;增加用户成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据ID更新用户</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/update/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">updateUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        userService.updateUser(<span class="keyword">new</span> User(id,<span class="string">&quot;ppp&quot;</span>,<span class="string">&quot;999&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;更新用户成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>启动项目，访问<br>localhost:8080/list     查询全部用户信息<br>localhost:8080/query/1  查询id为1的用户<br>localhost:8080/add  增加用户<br>localhost:8080/update/1  修改id为1的用户<br>localhost:8080/delete/1  删除id为1的用户</p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="配置Druid数据源监控"><a href="#配置Druid数据源监控" class="headerlink" title="配置Druid数据源监控"></a>配置Druid数据源监控</h2><p>Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的 web 页面。</p>
<p>所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理；</p>
<p>新建一个com.oldou.config.DuridConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oldou.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.StatViewServlet;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.WebStatFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuridConfig</span> </span>&#123;</span><br><span class="line">     <span class="comment">/* 将yml文件和这个文件绑定起来</span></span><br><span class="line"><span class="comment">       将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建</span></span><br><span class="line"><span class="comment">       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效</span></span><br><span class="line"><span class="comment">       @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)：作用就是将 全局配置文件中</span></span><br><span class="line"><span class="comment">       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> DataSource <span class="title">druidDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 后台监控    这个就相当于web.xml文件  ServletRegistrationBean</span></span><br><span class="line"><span class="comment">     * 配置 Druid 监控管理后台的Servlet；     DynamicRegistrationBean</span></span><br><span class="line"><span class="comment">     * 内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 的注册 Servlet 方式</span></span><br><span class="line"><span class="comment">     * 替代web.xml的方法：在ServletRegistrationBean中new一个新的方法就可以了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">statViewServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//配置进入后台监控的路径(固定代码)</span></span><br><span class="line">        ServletRegistrationBean&lt;StatViewServlet&gt; bean =</span><br><span class="line">                <span class="keyword">new</span> ServletRegistrationBean&lt;&gt;(<span class="keyword">new</span> StatViewServlet(), <span class="string">&quot;/druid/*&quot;</span>);</span><br><span class="line">        <span class="comment">//后台有人登录，需要账号密码(固定)</span></span><br><span class="line">        Map&lt;String, String&gt; initParameters = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加配置--注意：登录的Key是固定的 loginUsername  loginPassword</span></span><br><span class="line">        initParameters.put(<span class="string">&quot;loginUsername&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        initParameters.put(<span class="string">&quot;loginPassword&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//允许谁可以访问--如果为空表示谁都可以，localhost表示本机，IP地址</span></span><br><span class="line">        initParameters.put(<span class="string">&quot;allow&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//initParams.put(&quot;allow&quot;, &quot;localhost&quot;)：表示只有本机可以访问</span></span><br><span class="line">        <span class="comment">//initParams.put(&quot;allow&quot;, &quot;&quot;)：为空或者为null时，表示允许所有访问</span></span><br><span class="line">        <span class="comment">//禁止谁能访问 initParameters.put(&quot;oldou&quot;,&quot;192.168.15.131&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置初始化参数</span></span><br><span class="line">        bean.setInitParameters(initParameters);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 配置过滤器 filter   可以去查看WebStatFilter下有哪些东西可以配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">webStatFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FilterRegistrationBean bean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        bean.setFilter(<span class="keyword">new</span> WebStatFilter());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以过滤哪些请求？</span></span><br><span class="line">        Map&lt;String, String&gt; initParameters = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以下不进行统计</span></span><br><span class="line">        initParameters.put(<span class="string">&quot;exclusions&quot;</span>,<span class="string">&quot;*.js,*.css,/druid/*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bean.setInitParameters(initParameters);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问：<a href="http://localhost:8080/druid/login.html">http://localhost:8080/druid/login.html</a><br><img src="https://img-blog.csdnimg.cn/20200911224946297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>使用设置的密码登录：admin  123456<br><img src="https://img-blog.csdnimg.cn/20200911225052729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在里面我们就可以实时的监控每条sql的执行信息等等。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper常见面试题整理</title>
    <url>/2020/07/13/Zookeeper%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="1、Zookeeper是什么？"><a href="#1、Zookeeper是什么？" class="headerlink" title="1、Zookeeper是什么？"></a>1、Zookeeper是什么？</h1><p>Zookeeper是Apache的一个分布式服务框架，是Apache Hadoop的一个子项目，同时是一个为分布式应用提供了一致性服务的软件，主要是用来解决分布式应用中经常遇到的一些数据管理问题，所提供的功能包括：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p>
<p>简单来说，<strong>zookeeper=文件系统+通知机制</strong></p>
<h1 id="2、介绍一下Zookeeper的存储结构？"><a href="#2、介绍一下Zookeeper的存储结构？" class="headerlink" title="2、介绍一下Zookeeper的存储结构？"></a>2、介绍一下Zookeeper的存储结构？</h1><p><img src="https://img-blog.csdnimg.cn/20200716231003637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 如上图所示，Zookeeper的底层是树形的数据结构来做存储的，它的每一个节点被称为Znode，在Zookeeper中znode是一个和Unix文件系统路径相似的节点，可以向节点中存储数据或者是获取数据。<br>Zookeeper为了保证高吞吐和低延迟，在内存中维持了树状的的结构，但是这样的结构也让Zookeeper不能用于存放大量的数据，默认的每个Znode节点的数据存放上限为1MB。</p>
<h1 id="3、Zookeeper的文件系统"><a href="#3、Zookeeper的文件系统" class="headerlink" title="3、Zookeeper的文件系统"></a>3、Zookeeper的文件系统</h1><p>Zookeeper的内部提供了一种多层级的节点命名空间，同时节点被称为Znode，和文件系统不一样的是，文件系统不能像Znode那样可以设置关联的数据，它只有文件节点可以存放数据，而目录节点不可以。</p>
<p><strong>需要注意的是：Zookeeper的每个Znode最多只能存放1MB的数据。</strong></p>
<h1 id="4、介绍一下Zookeeper四种类型的数据节点Znode。"><a href="#4、介绍一下Zookeeper四种类型的数据节点Znode。" class="headerlink" title="4、介绍一下Zookeeper四种类型的数据节点Znode。"></a>4、介绍一下Zookeeper四种类型的数据节点Znode。</h1><p>Zookeeper有四种类型的节点，分别是：持久化顺序节点(PERSISTENT)、持久化顺序编号目录节点(PERSISTENT_SEQUENTIAL)、临时目录节点(EPHEMERAL)、临时顺序编号目录节点(EPHEMERAL_SEQUENTIAL)。<br><strong>（1）持久化顺序节点(PERSISTENT)</strong><br>            该节点创建之后，当客户端和Zookeeper断开连接后，该节点依然存在，除非手动删除。<br><strong>（2）持久化顺序编号目录节点(PERSISTENT_SEQUENTIAL)</strong><br>            该节点创建时，Zookeeper会给该节点名称添加一个顺序编号，当客户端和Zookeeper断开连接后，该节点依然存在。<br><strong>（3）临时目录节点(EPHEMERAL)</strong><br>            该节点创建之后，当客户端和Zookeeper断开连接后，该节点就会被删除。<br><strong>（4）临时顺序编号目录节点(EPHEMERAL_SEQUENTIAL)</strong><br>            该节点创建时，Zookeeper会给该节点名称添加一个顺序编号，当客户端和Zookeeper断开连接后，该节点就会被删除掉。</p>
<h1 id="5、说一下Zookeeper常用的命令（详解）"><a href="#5、说一下Zookeeper常用的命令（详解）" class="headerlink" title="5、说一下Zookeeper常用的命令（详解）"></a>5、说一下Zookeeper常用的命令（详解）</h1><p><strong>Zookeeper常用的命令有：ls、create、get、set、delete</strong><br><strong>（1）ls命令</strong><br>基本格式为： ls  /path<br>使用ls命令查看zookeeper节点中的内容，在zookeeper控制客户端中，没有默认列表功能，必须要指定列表资源的位置。比如说：ls  /   或者  ls  /path<br>如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200716234130455.png" alt="在这里插入图片描述"><br>这其实和linux操作系统中查看文件内容是类似的。</p>
<p><strong>（2）create命令</strong><br>基本格式为：create [-e] [-s] /path [data]<br>使用create命令创建一个新的znode，create [-e] [-s] path data - 创建节点，同时我们可以根据后面的参数创建不同类型的节点。<br>A、创建持久化目录节点时不需要给定后面任何参数，create /path  [data]<br>比如：create /test 123   ，其意思就是创建了一个持久化目录节点test，节点携带的信息为123，该节点创建后会一直存在，除非手动删除。</p>
<p>B、创建持久化顺序目录节点时，后面需要给定参数-s，create -s /path [data]<br>比如：create -s /test 456  ，该节点创建后会一直存在，除非手动删除。</p>
<p>C、创建临时目录节点时，后面需要给定参数-e，create -e /path [data]<br>比如：create -e /ssm 666 ，临时节点只在当前会话生命周期中有效，会话结束节点自动删除。</p>
<p>D、创建临时顺序目录节点时，后面需要给定l两个参数-e  -s ,create -e -s /path [data]。临时节点只在当前会话生命周期中有效，会话结束节点自动删除。</p>
<p><strong>（3）get命令</strong><br>基本格式为：get [-s] /path<br>get命令获取Znode中的数据，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200717000307337.png" alt="在这里插入图片描述">同时，如果给定参数-s的话就会查看出Znode全部的信息。<br><img src="https://img-blog.csdnimg.cn/20200717000044872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>oldlu:存放的数据<br>cZxid:创建时 zxid(znode 每次改变时递增的事务 id)<br>ctime:创建时间戳<br>mZxid:最近一次更近的 zxid<br>mtime:最近一次更新的时间戳<br>pZxid:子节点的 zxid<br>cversion:子节点更新次数<br>dataversion:节点数据更新次数<br>aclVersion:节点 ACL(授权信息)的更新次数<br>ephemeralOwner:如果该节点为 ephemeral 节点(临时，生命周期与 session 一样),<br>ephemeralOwner 值表示与该节点绑定的 session id. 如果该节点不是<br>ephemeral 节点, ephemeralOwner 值为 0.<br>dataLength:节点数据字节数<br>numChildren:子节点数量</p>
<p><strong>（4）set命令</strong><br>基本格式为：set /path [data]<br>功能为添加或修改 Znode 中的值。<br><img src="https://img-blog.csdnimg.cn/20200717000409240.png" alt="在这里插入图片描述"><br><strong>（5）delete命令</strong><br>基本格式为：delete /path<br>功能为删除 Znode。<br><img src="https://img-blog.csdnimg.cn/20200717000456541.png" alt="在这里插入图片描述"></p>
<h1 id="6、介绍一下Zookeeper的监听机制？"><a href="#6、介绍一下Zookeeper的监听机制？" class="headerlink" title="6、介绍一下Zookeeper的监听机制？"></a>6、介绍一下Zookeeper的监听机制？</h1><p>Zookeeper的监听机制使用的是观察者模式来进行设计的。当客户端注册监听它关心的目录节点(znode)时，当目录节点（znode）发生变化时(数据变化、被删除、子目录节点增加或者删除)时，Zookeeper会通知客户端。但是watcher通知客户端时，只告诉客户端发生了事件而不会告知其内容，并且无论是客户端还是服务端，一旦一个监听器watcher被触发就会被zookeeper从相应的存储中删除，</p>
<h1 id="7、Zookeeper哪些部署模式？"><a href="#7、Zookeeper哪些部署模式？" class="headerlink" title="7、Zookeeper哪些部署模式？"></a>7、Zookeeper哪些部署模式？</h1><p>Zookeeper有三种部署模式：<br>（1）单机部署：一台集群上运行；<br>（2）集群部署：多台集群上运行；<br>（3）伪集群部署：一台集群上启动多个Zookeeper实例运行。</p>
<h1 id="8、Zookeeper中的服务器角色"><a href="#8、Zookeeper中的服务器角色" class="headerlink" title="8、Zookeeper中的服务器角色"></a>8、Zookeeper中的服务器角色</h1><p><strong>（1）Leader 领导者</strong><br>它是事务请求的唯一调度和处理者，保证集群事务处理的顺序性，同时也是集群内部各服务的调度者。</p>
<p><strong>（2）Follower跟随者</strong><br>主要是处理客户端的非事务请求，转发事务请求给 Leader 服务器，同时参与事务请求 Proposal 的投票，还有参与 Leader 选举投票。</p>
<p><strong>（3）Observer观察者</strong><br>它是3.0 版本以后引入的一个服务器角色，有在不影响集群事务处理能力的基础上提升集群的非事务处理能力，可以处理客户端的非事务请求，转发事务请求给 Leader 服务器，但是它不参与任何形式的投票</p>
<h1 id="9、zookeeper-怎么保证主从节点的状态同步"><a href="#9、zookeeper-怎么保证主从节点的状态同步" class="headerlink" title="9、zookeeper 怎么保证主从节点的状态同步"></a>9、zookeeper 怎么保证主从节点的状态同步</h1><p>zookeeper 的核心是原子广播机制，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者(Leader)崩溃后，zab 就进入了恢复模式，当领导者(Leader)被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p>
<h1 id="10、集群中为什么要有主节点（master）？"><a href="#10、集群中为什么要有主节点（master）？" class="headerlink" title="10、集群中为什么要有主节点（master）？"></a>10、集群中为什么要有主节点（master）？</h1><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，而其他的机器可以共享这个结果，这样就可以大大减少了重复计算，从而提高性能，因此就需要有主节点。</p>
<h1 id="11、集群中有三台服务器，假如其中一个节点宕机了，这个时候的zookeeper还能继续使用吗？"><a href="#11、集群中有三台服务器，假如其中一个节点宕机了，这个时候的zookeeper还能继续使用吗？" class="headerlink" title="11、集群中有三台服务器，假如其中一个节点宕机了，这个时候的zookeeper还能继续使用吗？"></a>11、集群中有三台服务器，假如其中一个节点宕机了，这个时候的zookeeper还能继续使用吗？</h1><p>可以继续使用，Zookeeper本身也是集群，推荐的是配置不少于3台服务器，也就是说Zookeeper自身也要保证当其中一个节点宕机之后其他的节点也能正常的提供服务。Zookeeper的集群机制就是只要超过半数的节点正常，zookeeper就会正常的提供服务，只有当zookeeper节点宕（dang）得太多了，能工作的节点只剩下一半或者是不到一半的时候，集群才会失效。<br>比如说：3个节点的集群最多只能挂掉一个节点，2个节点的集群就不能挂掉任何一个节点。</p>
<h1 id="12、集群最少要几台机器？集群规则是怎样的？集群中有3台服务器，其中有一个节点宕机，这个时候Zookeeper还可以使用吗？"><a href="#12、集群最少要几台机器？集群规则是怎样的？集群中有3台服务器，其中有一个节点宕机，这个时候Zookeeper还可以使用吗？" class="headerlink" title="12、集群最少要几台机器？集群规则是怎样的？集群中有3台服务器，其中有一个节点宕机，这个时候Zookeeper还可以使用吗？"></a>12、集群最少要几台机器？集群规则是怎样的？集群中有3台服务器，其中有一个节点宕机，这个时候Zookeeper还可以使用吗？</h1><p> 集群规则为<strong>2N+1</strong>台，即最少需要3台机器。<br> 可以继续使用，单数服务器只要没超过一半多点服务器宕机就可以继续使用。</p>
<h1 id="13、说一下Zookeeper的应用场景。"><a href="#13、说一下Zookeeper的应用场景。" class="headerlink" title="13、说一下Zookeeper的应用场景。"></a>13、说一下Zookeeper的应用场景。</h1><p>zookeeper是一个经典的发布/订阅模式的分布式服务框架，开发人员经常使用它来进行一些分布式数据的发布/订阅（注册中心），一般有以下几个应用场景：<br>（1）数据发布/订阅；<br>（2）统一命名服务；<br>（3）分布式协调/通知；<br>（4）集群管理；<br>（5）负载均衡；<br>（6）分布式锁；<br>（7）分布式队列</p>
<p>返回首页：<a href="https://oldou.github.io/">点击此处</a></p>
<p><strong>本文全属查阅资料以及平时自己笔记整理所写（不喜勿喷！），如有不正确的地方，请在评论区说明，我会及时进行更正。</strong></p>
<p><strong>现在暂时内容有些少，后面会持续更新……….</strong></p>
<p><strong>互相学习，互相进步！</strong></p>
]]></content>
      <categories>
        <category>Zookeeper</category>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>Zookeeper学习</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记之Linux学习（一）：Linux安装以及目录介绍、Xshell终端的安装</title>
    <url>/2020/07/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ALinux%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D%E3%80%81Xshell%E7%BB%88%E7%AB%AF%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="1、Linux的介绍"><a href="#1、Linux的介绍" class="headerlink" title="1、Linux的介绍"></a>1、Linux的介绍</h1><p><img src="https://img-blog.csdnimg.cn/20200718161819617.png" alt="在这里插入图片描述"></p>
<h1 id="2、Linux的安装文件介绍"><a href="#2、Linux的安装文件介绍" class="headerlink" title="2、Linux的安装文件介绍"></a>2、Linux的安装文件介绍</h1><p>首先介绍一下本次学习需要安装的软件：<br>VMware Workstation Pro   （VMware-workstation-full-12.1.0-3272444）<br>CentOS-6.5-x86_64-bin-DVD1.iso<br>Xshell5.exe<br>下载地址为：<br>链接：<a href="https://pan.baidu.com/s/1QIzxgQAY1wNttaxOxwoZEg">https://pan.baidu.com/s/1QIzxgQAY1wNttaxOxwoZEg</a><br>提取码：pcra</p>
<p>里面有整理好的笔记以及后续学习所需要的安装包，包括有以下：<br>apache-tomcat-7.0.47.tar.gz<br>VMware12及密钥<br>CentOS-6.5-x86_64-bin-DVD1.iso<br>FileZilla_3.23.0.2_win64-setup.exe<br>jdk-8u11-linux-x64.tar.gz<br>mysql-community-release-el6-5.noarch.rpm<br>Xshell5.exe</p>
<p>好了，不多BB了，开始下面的学习。</p>
<h1 id="3、VMware-Workstation-Pro-的安装"><a href="#3、VMware-Workstation-Pro-的安装" class="headerlink" title="3、VMware Workstation Pro 的安装"></a>3、VMware Workstation Pro 的安装</h1><p>打开下载的文件夹，<br>找到VMware12及密钥下的VMware-workstation-full-12.1.0-3272444.exe<br>双击运行。<br><img src="https://img-blog.csdnimg.cn/20200718163329414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后一直点击下一步，选择合适的安装目录，直接安装即可，安装完成之后需要输入密钥，在文件夹中有密钥，复制粘贴即可。<br>VMware 12 专业版永久许可证密钥：<br>5A02H-AU243-TZJ49-GTC7K-3C61N</p>
<p><strong>4、Linux的安装</strong><br>打开安装好的VMware Workstation Pro ，点击新建虚拟机。<br><img src="https://img-blog.csdnimg.cn/20200718163922934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后选择典型，下一步<br><img src="https://img-blog.csdnimg.cn/20200718163957759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里是要选择镜像文件，选择我们下载的镜像文件，在文件夹中，点击下一步<br><img src="https://img-blog.csdnimg.cn/20200718164112604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>填写好用户名和密码，密码建议短一点，不要太长，填写完毕之后点击下一步。<br><img src="https://img-blog.csdnimg.cn/20200718164446997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>之后就是选择安装的位置，建议不要装在C盘，建议在其他盘新建一个文件夹专门用来放虚拟机文件，然后点击下一步<br><img src="https://img-blog.csdnimg.cn/20200718164641109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里我们选择默认的。<br><img src="https://img-blog.csdnimg.cn/20200718164722505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里也选择默认的，点击完成，接下来便是等待安装。<br><img src="https://img-blog.csdnimg.cn/20200718164817743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>安装期间会出现下图所示，这个时候鼠标点进去按回车就行了，鼠标如果想切换出来按<strong>Ctrl+Alt</strong><br><img src="https://img-blog.csdnimg.cn/20200718165116423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>等待的时间可能会稍微有点长，这个时候不要关闭程序，耐心等待…..<br>最后出现以下界面就说明安装成功了，这里我们点击other，输入root<br>和密码，使用root角色进入虚拟机。<br><img src="https://img-blog.csdnimg.cn/20200718165923772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>进入之后出现这个弹框，勾选以后不再弹出就行了。<br><img src="https://img-blog.csdnimg.cn/20200718170057160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这样我们虚拟机就安装完成了。。。。<br><img src="https://img-blog.csdnimg.cn/20200718170143271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="4、Linux目录介绍"><a href="#4、Linux目录介绍" class="headerlink" title="4、Linux目录介绍"></a>4、Linux目录介绍</h1><p><strong>1.1.1 ： /</strong><br>        根目录.Unix 和 Linux 中,没有盘符. 一个硬盘,一个根.</p>
<p><strong>1.1.2 ：/bin</strong><br>        系统的常用命令目录. 包括控制台命令, 系统可执行文件, 系统的核心二进制文件等.</p>
<p><strong>1.1.3 /etc</strong><br>        发布目录, 相当于 windows 系统中的 windows 目录, 保存系统中的所有核心内容.<br>        要求控制权限高, 建议不要随便读写.</p>
<p><strong>1.1.4 /usr</strong><br>        用户目录, 相当于 windows 系统中的 program files 目录.<br>        常用于安装系统所有用户共用的软件,资源的.</p>
<p><strong>1.1.5 /root</strong><br>        root根用户的用户目录.相当于windows系统中的C:/users/administrator 目录.<br>        称为用户主目录.</p>
<p><strong>1.1.6 /home</strong><br>        保存其他用户主目录的目录.<br>        如: Linux 系统中有 oldlu 用户. 那么一定有/home/oldlu 目录存在.<br>        代表用户的主目录.</p>
<p><strong>1.1.7 /var</strong><br>        系统运行过程的数据目录.</p>
<h1 id="5、Xshell终端的安装"><a href="#5、Xshell终端的安装" class="headerlink" title="5、Xshell终端的安装"></a>5、Xshell终端的安装</h1><p>在下载的文件夹中，找到Xshell5.exe，双击运行，一直点击下一步，<strong>中间安装目录</strong>选择在其他盘，最后安装完成后出现下图所示：<br><img src="https://img-blog.csdnimg.cn/20200718170931481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><p>如果不是用的我分享的文件，在安装Linux的时候出现黑屏一直卡在黑屏的界面没有其他的显示，那就说明VMware Workstation Pro和安装的CentOS-6.5-x86_64-bin-DVD1.iso版本不匹配造成的，如果都用的我分享的文件，是不会出现这样的问题的。</p>
<p><strong>软件安装成功之后，接下来便是进入下一个阶段的学习，<br>下一阶段的内容为：</strong><br><strong>1、设计虚拟机网卡</strong><br><strong>2、如何使用Xshell连接虚拟机</strong><br><strong>3、软件上传以及安装、配置JDK</strong><br><strong>4、安装tomcat</strong></p>
<p>返回首页：<a href="#">Post not found: https://oldou.github.io/ 点击此处</a><br>下一篇文章：<a href="/2020/07/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ALinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/" title="学习笔记之Linux学习（二）">学习笔记之Linux学习（二）</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Linux学习</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记之Linux学习（二）：Linux常用命令介绍</title>
    <url>/2020/07/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ALinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章：<a href="/2020/07/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ALinux%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D%E3%80%81Xshell%E7%BB%88%E7%AB%AF%E7%9A%84%E5%AE%89%E8%A3%85/" title="学习笔记之Linux学习（一）">学习笔记之Linux学习（一）</a><br>介绍了VMware Workstation Pro 软件的安装、Linux的安装、Xshell终端的安装以及Linux目录的介绍。</p>
<p>本文主要介绍Linux的常用命令，为后续的学习作准备。</p>
<h1 id="Linux常用命令介绍"><a href="#Linux常用命令介绍" class="headerlink" title="Linux常用命令介绍"></a>Linux常用命令介绍</h1><h1 id="（1）ifconfig"><a href="#（1）ifconfig" class="headerlink" title="（1）ifconfig"></a>（1）ifconfig</h1><pre><code>    查看网络编辑器. 查看网卡信息.</code></pre>
<h1 id="（2）pwd"><a href="#（2）pwd" class="headerlink" title="（2）pwd"></a>（2）pwd</h1><pre><code>    print working directory - 输出当前工作目录,光标所在位置的目录.</code></pre>
<h1 id="（3）cd"><a href="#（3）cd" class="headerlink" title="（3）cd"></a>（3）cd</h1><pre><code>    change directory - 切换目录.
    特殊目录符号 : 当前目录 - ‘.’ , 父目录 - ‘..’(cd ..)
    使用方式
            1  切换固定位置
                    使用根目录作为定位标准, 绝对寻址.
                     如：cd /xxx/yyy/zzz
            2  切换相对位置
                    在当前目录位置开始相对寻址.
                     如：cd xxx/yyy/zzz
            3  进入主目录
                    直接进入用户主目录
                      cd
                      cd ~    这里的~代表的就是root目录</code></pre>
<h1 id="（4）ls"><a href="#（4）ls" class="headerlink" title="（4）ls"></a>（4）ls</h1><p>list - 列表目录中的内容.默认显示当前目录下的文件列表</p>
<pre><code>     使用方式
            列表当前目录 ：ls
            列表指定目录 ：ls 目录位置(绝对路径|相对路径)
            查看全部内容 ：ls -a [目录]---list all - 查看所有, 包括隐藏文件. 
            注意：Linux 中隐藏文件都是以’.’开头的文件.
            列表查看目录内容 ：
                  ls -l [目录]：显示当前目录下的文件属性：大小、权限、日期、符号链接。
                  ll - 简化命令不代表全部 Linxu 系统可用.
                  list list - 以列表的信息,显示指定目录中的内容. 列表代表的是文件的详情.


             类型： - | 1 代表文件
                    d | 2 代表目录, 2+n, n 代表目录中的文件数量.

             容量：单位是字节. 所有的目录固定容量为 4096.

             权限：分为不同的角色: 文件的所有者, 就是创建文件的用户. 
                    所在组,和所有者同一个组的其他用户. 其他用户, 和所有者不在一个组的用户.
                    rwx - read write execut
                   ‘-’ 代表没有对应权限.
     命令参数
          所有以‘-‘ 开头的命令后缀信息, 都是命令参数. 多参数可以并行使用. 如: ls -al</code></pre>
<h1 id="（5）clear"><a href="#（5）clear" class="headerlink" title="（5）clear"></a>（5）clear</h1><pre><code>    clear screen - 清空屏幕.
    清屏命令有两个:clear 和 clear screen</code></pre>
<h1 id="（6）touch"><a href="#（6）touch" class="headerlink" title="（6）touch"></a>（6）touch</h1><pre><code>创建空白文件,在 Linux 系统中,文件不需要强制后缀名.
                    如: 文本文件可以定义为, a | a.txt | a.text
使用方式
            touch 文件名:指的是在当前目录下创建文件
            touch 目录/文件名:基于相对路径 如：touch root/b
            touch /目录/文件名:基于绝对路径 </code></pre>
<h1 id="（7）cat"><a href="#（7）cat" class="headerlink" title="（7）cat"></a>（7）cat</h1><pre><code>查看文件的全部内容.一次性显示文件中所有内容.</code></pre>
<h1 id="（8）more"><a href="#（8）more" class="headerlink" title="（8）more"></a>（8）more</h1><pre><code>分屏显示文件内容, 显示后,使用空格显示下一屏, 
回车显示下一行,q 退出分屏显示.
ctrl+c,退出命令</code></pre>
<h1 id="（9）head"><a href="#（9）head" class="headerlink" title="（9）head"></a>（9）head</h1><pre><code>显示文件的前多少行, 默认显示前 10 行. 如：head -number filename
查看文件中的前多少行.</code></pre>
<h1 id="（10）tail"><a href="#（10）tail" class="headerlink" title="（10）tail"></a>（10）tail</h1><pre><code>显示文件末尾多少行.默认显示末尾 10 行. 如：tail -number filename</code></pre>
<h1 id="（11）mkdir"><a href="#（11）mkdir" class="headerlink" title="（11）mkdir"></a>（11）mkdir</h1><pre><code>make directory - 创建目录.
    10.1  使用方式
            10.1.1  相对创建一个子目录--mkdir directoryName
            10.1.2  绝对创建一个目录 --mkdir /directoryName
            10.1.3  一次性创建多级目录--mkdir -p                
            parentDirectoryName/childDirectoryName</code></pre>
<h1 id="（12）cp"><a href="#（12）cp" class="headerlink" title="（12）cp"></a>（12）cp</h1><pre><code> copy - 复制命令.
  使用方式--copy 源信息 目录信息    copy source target  
  复制文件-copy fileName newFileName
    copy directoryName/fileName directoryName/[newFileName]
    copy /directoryName/fileName /directoryName/[newFileName]
 复制目录
    copy -r directoryName newDirectoryName</code></pre>
<h1 id="（13）-rm"><a href="#（13）-rm" class="headerlink" title="（13） rm"></a>（13） rm</h1><pre><code>remove - 删除
    使用方式 ---rm source ：rm 要删除的资源
    删除文件需提示----rm fileName   
                             rm directoryName/fileName
                             rm / directoryName/fileName
    删除文件不需提示---rm-f fileName
                             rm -f directoryName/fileName
                             rm -f /directoryName/fileName
    删除目录需提示
                            rm -r directoryName
    删除目录不需提示
                            rm -rf directoryName</code></pre>
<h1 id="（14）mv"><a href="#（14）mv" class="headerlink" title="（14）mv"></a>（14）mv</h1><pre><code>move - 移动或重命名. 相当于剪切和重命名.
  使用方式
         mv source target 移动
         mv source newName 重命名
  移动文件到指定位置 ：mv fileName directoryName
  为文件重命名 ：mv fileName newFileName</code></pre>
<h1 id="（15）-vi-vim"><a href="#（15）-vi-vim" class="headerlink" title="（15） vi | vim"></a>（15） vi | vim</h1><pre><code>编辑文件, vim 是增强命令. 
            不代表所有的 Linux 都支持.vim 增强在有高亮显示.
使用方式----vi fileName
命令模式----是控制编辑的文件的状态的,如:保存,退出编辑等.
       进入编辑模式:
        a - append, 追加的方式进入编辑模式
        i - insert, 插入的方式进入编辑模式
        o - under line , 在光标所在位置之下,新增一行,进入编辑模式.
        O - pre line, 在光标所在位置之上,新增一行, 进入编辑模式.
        dd  ：[number] dd - delete line 删除指定行, 默认 1 行
        w   ： write - 保存
        q   ：quit - 退出 vi 编辑器
        wq  ：保存并退出
        q!  ：强制退出不保存.
        set nu  ：显示行号
         /keywords  ：搜索关键字, keywords 是关键字的命名.
        G   ：光标跳转到文件尾
        gg  ：光标跳转到文件头
编辑模式：是编辑文件内容的.进入命令模式 - esc</code></pre>
<h1 id="（16）service"><a href="#（16）service" class="headerlink" title="（16）service"></a>（16）service</h1><pre><code>服务控制命令. 常用服务:iptables - 防火墙, 
vsftpd ftp 文件服务器, mysql防火墙建议关闭. 
否则除 80,22 端口外,其他所有端口无法访问.

关闭操作：（service iptables stop）
使用方式
     1、启动服务
              service 服务名称 start
     2、停止服务
              service 服务名称 stop 
     3、重启服务
              service 服务名称 restart
     4、查看服务状态
              service 服务名称 status</code></pre>
<h1 id="（17）-ps"><a href="#（17）-ps" class="headerlink" title="（17）  ps"></a>（17）  ps</h1><pre><code>进程信息查看命令.
    使用方式
            ps aux [| grep keywords]
             a - 所有进程
             u - 包含用户启动的进程
             x - 正在执行中的进程.</code></pre>
<h1 id="（18）grep"><a href="#（18）grep" class="headerlink" title="（18）grep"></a>（18）grep</h1><pre><code>过滤|筛选, 筛选符合关键字的数据.</code></pre>
<h1 id="（19）tar"><a href="#（19）tar" class="headerlink" title="（19）tar"></a>（19）tar</h1><pre><code>解压缩 : tar 命令
      1  使用方式
          tar [参数] source [target]
          source - 压缩文件
          target - 解压缩后的目标位置, 默认解压到当前目录.
            常用写法 :
                    解压缩 : tar -zxf 压缩文件名
                    解压缩 : tar -zxvf 压缩文件名
                    压缩 : tar -czf 要压缩的目录 压缩后的文件名

        1.1  z
              zip 格式压缩文件, 包含 zip,gz,tar.gz 等格式. 
              不包含 rar.
        1.2  c
              创建压缩包.
        1.3  x
              解压缩
        1.4  f
              指定文件
        1.5  v
             显示解压缩过程.</code></pre>
<h1 id="（20）useradd"><a href="#（20）useradd" class="headerlink" title="（20）useradd"></a>（20）useradd</h1><pre><code>创建新用户 : useradd 命令
    useradd + 用户名</code></pre>
<h1 id="（21）passwd"><a href="#（21）passwd" class="headerlink" title="（21）passwd"></a>（21）passwd</h1><pre><code>为用户添加密码 : passwd 命令
    passwd + 用户名(为哪个用户添加密码)</code></pre>
<h1 id="（22）chkconfig-iptables-off"><a href="#（22）chkconfig-iptables-off" class="headerlink" title="（22）chkconfig iptables off"></a>（22）chkconfig iptables off</h1><pre><code>永久关闭防火墙</code></pre>
<h1 id="（23）reboot"><a href="#（23）reboot" class="headerlink" title="（23）reboot"></a>（23）reboot</h1><pre><code>重启linux(慎用)</code></pre>
<p>返回首页：<a href="https://oldou.github.io/">点击此处</a></p>
<p>上一篇文章：<a href="/2020/07/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ALinux%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D%E3%80%81Xshell%E7%BB%88%E7%AB%AF%E7%9A%84%E5%AE%89%E8%A3%85/" title="学习笔记之Linux学习（一）">学习笔记之Linux学习（一）</a></p>
<p>下一篇文章：<a href="/2020/07/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E5%8D%A1%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E9%85%8D%E7%BD%AEJDK%E3%80%81%E4%BB%A5%E5%8F%8Atomcat%E7%9A%84%E5%AE%89%E8%A3%85/" title="学习笔记之Linux学习（三）">学习笔记之Linux学习（三）</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Linux学习</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客之Windows下如何使用Hexo搭建个人博客</title>
    <url>/2020/07/13/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BWindows%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>身为程序猿，刚入坑Java时，看到别人搭建的个人博客，心里往往都是很羡慕的（反正我是羡慕的），<br>以至于很想拥有一个自己的个人博客，而前一段时间在bilibili上面找到了一个关于个人博客的搭建视频，<br>up主是羊哥，真的特别感谢他，这是他的bilili视频链接：<a href="https://www.bilibili.com/video/BV1Yb411a7ty">https://www.bilibili.com/video/BV1Yb411a7ty</a><br>羊哥使用的是Mac环境下搭建的博客，今天把就从视频中所学到的、我在Windows环境如何搭建个人博客分享出来。</p>
<h1 id="我的个人博客"><a href="#我的个人博客" class="headerlink" title="我的个人博客"></a>我的个人博客</h1><p><a href="https://oldou.github.io/">点这里</a></p>
<h1 id="第一步：下载安装Node-js"><a href="#第一步：下载安装Node-js" class="headerlink" title="第一步：下载安装Node.js"></a>第一步：下载安装Node.js</h1><p>首先我们要安装Node.js，官网的地址为：<a href="https://nodejs.org/en/">nodejs.org</a><br><img src="https://img-blog.csdnimg.cn/20200719000017621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下载LTS版，下载好之后点击安装就好了。<br><img src="https://img-blog.csdnimg.cn/20200719000221845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>安装完成之后是以下界面：<br><img src="https://img-blog.csdnimg.cn/20200719000137602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>安装成功之后可以使用Windows运行CMD打开命令窗口，使用下图中的两个命令查看：<br><img src="https://img-blog.csdnimg.cn/20200719000421740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="第二步-安装cnpm管理器以及hexo框架"><a href="#第二步-安装cnpm管理器以及hexo框架" class="headerlink" title="第二步 安装cnpm管理器以及hexo框架"></a>第二步 安装cnpm管理器以及hexo框架</h1><p><strong>（2.1）安装淘宝的cnpm管理器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;http:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>安装成功之后去查看一下cnpm的版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure>
<p><strong>（2.2）安装hexo框架</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli </span><br></pre></td></tr></table></figure>
<p>安装成功之后查看一下hexo的版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v </span><br></pre></td></tr></table></figure>

<h1 id="第三步-开始搭建博客"><a href="#第三步-开始搭建博客" class="headerlink" title="第三步 开始搭建博客"></a>第三步 开始搭建博客</h1><p>这个时候我们可以现在其他盘中新建一个目录专门用于存放博客文件，我是建在了D:\MyHexoBlogs\blog  ，这里直接手动建文件夹即可，然后在windows命令窗口中执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）先使用  d:   调到D盘</span><br><span class="line">（2）然后再使用   cd D:\MyHexoBlogs\blog   进入到blog目录下</span><br><span class="line">（3）使用命令：hexo init  进行初始化</span><br></pre></td></tr></table></figure>
<p>初始化时可能会有点慢，初始化完毕之后就可以去启动博客了。<br>启动博客的命令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（4）hexo s</span><br></pre></td></tr></table></figure>
<p>之后最后输出的信息会有一个地址：localhost:4000<br>浏览器中输入改地址就可以看见博客页面了。</p>
<h1 id="开始写第一篇博客"><a href="#开始写第一篇博客" class="headerlink" title="开始写第一篇博客"></a>开始写第一篇博客</h1><p>输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new “我的第一篇博客文章”</span><br></pre></td></tr></table></figure>
<p>由于windows不能使用vim命令去编辑，于是我们直接找到博客安装目录<br>D:\MyHexoBlogs\blog\source_posts下找到新建的那个文件，编辑一些内容<br><img src="https://img-blog.csdnimg.cn/20200719002643957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用MarkDown格式随便写点内容进去方便测试，写完之后保存，叉掉。<br>接下来便是在命令窗口中清理一下之前的内容，然后生成、再启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）hexo clean</span><br><span class="line">（2）hexo g</span><br><span class="line">（3）hexo s</span><br></pre></td></tr></table></figure>
<p>然后浏览器访问的那个地址刷新一下就可以看见我们书写的博客了。</p>
<h1 id="将个人博客部署到Github上"><a href="#将个人博客部署到Github上" class="headerlink" title="将个人博客部署到Github上"></a>将个人博客部署到Github上</h1><p>这里要自己先去注册一个Github账号。<br>然后登录之后新建一个仓库，如图所示：<br><img src="https://img-blog.csdnimg.cn/20200719003026824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200719003056385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>根据上图中的内容来，这里特别注意的是地址的前面必须是自己的Github账号名。</strong><br><img src="https://img-blog.csdnimg.cn/20200719003233442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>创建好之后就会生成一个连接，如图中描述，地址一定要记好了。</p>
<p>接下来便是回到我们的命令窗口，要安装一下部署插件。<br>命令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install –save hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p>安装完成之后去编辑D:\MyHexoBlogs\blog目录下的一个_config.yml文件，我们直接鼠标右键打开(这里如果电脑没有编辑这种文件的软件，建议下载一个<a href="https://dl.pconline.com.cn/html_2/1/117/id=10699&pn=0.html">Notepad++</a>）。<br>在文件的底部编辑以下图中的内容：<br><img src="https://img-blog.csdnimg.cn/20200719003904919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>需要注意的是，里面的地址为自己创建好的Github仓库地址，<br>然后中间是有空格的！！！！！！！</strong></p>
<p>接下来便是将博客部署到Github中去，在命令窗口中使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d    部署的意思</span><br></pre></td></tr></table></figure>
<p>然后就会让你输入你的Github的账号和密码，输入完成之后就会进行验证，部署成功之后，去Github创建的仓库中查看就可以看见自己的博客项目了。<br><img src="https://img-blog.csdnimg.cn/2020071900433122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="访问我们部署到Github的博客"><a href="#访问我们部署到Github的博客" class="headerlink" title="访问我们部署到Github的博客"></a>访问我们部署到Github的博客</h1><p>接下来输入自己的github仓库名地址：<a href="https://oldou.github.io/">https://oldou.github.io/</a><br>以上为我的Github地址，大家只要改为自己的即可。以下便是访问到的博客页面。<br><img src="https://img-blog.csdnimg.cn/20200719004824812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="怎么更换博客主题？"><a href="#怎么更换博客主题？" class="headerlink" title="怎么更换博客主题？"></a>怎么更换博客主题？</h1><p>本次介绍的是yilia主题，地址在<a href="https://github.com/litten/hexo-theme-yilia">https://github.com/litten/hexo-theme-yilia</a><br>然后克隆该项目，将地址复制<img src="https://img-blog.csdnimg.cn/20200719005136558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>回到我们的命令窗口，使用shdir可以查看当前目录，这里介绍一下，如果觉得博客没啥用了，可以直接将blog文件夹删除即可。</p>
<p>拷贝了那个链接，接下来我们使用命令将主题克隆过来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia.git themes&#x2F;yilia</span><br></pre></td></tr></table></figure>
<p>由于GitHub仓库是国外的，所以可能会比较慢，耐心等待几分钟<br>克隆好之后Windows直接去D:\MyHexoBlogs\blog\themes文件夹中就可以看见yilia文件已经下载好了。<br><img src="https://img-blog.csdnimg.cn/20200719005616839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下载好了接下来就是将这个主题配置到我们的博客中，<br>找到我们的_config.yml文件，这个文件比较重要，用编辑器打开<br><img src="https://img-blog.csdnimg.cn/20200719005659913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>以后想换主题了就这样还，然后保存退出，之后就是命令的连式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在窗口中使用hexo clean 清理一下</span><br><span class="line">然后重新生成一下hexo g</span><br><span class="line">再重新start一下：hexo s</span><br><span class="line">接下来再去访问losthost:4000就发现主题变了</span><br><span class="line">接下来ctrl+C退出</span><br><span class="line">我们将这个博客再次上传到Github</span><br><span class="line">使用命令hexo d</span><br><span class="line">上传完毕之后我们再去用Github命令访问就发现主题可以了</span><br></pre></td></tr></table></figure>
<p><strong>按照这个顺序来，以后修改主题了一定要到安装的博客目录下执行对应的命令，我的是以下目录。</strong><br><img src="https://img-blog.csdnimg.cn/20200719005943685.png" alt="在这里插入图片描述"></p>
<p><strong>后续我会继续分享我使用个人博客的经验，大家如果喜欢我这次分享的话，就点赞评论一下，大家一起相互学习学习。</strong></p>
]]></content>
      <categories>
        <category>个人博客</category>
        <category>经验分享</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>经验分享</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记之Linux学习（三）：配置虚拟机网卡、文件上传、配置JDK、以及tomcat的安装</title>
    <url>/2020/07/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E5%8D%A1%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E9%85%8D%E7%BD%AEJDK%E3%80%81%E4%BB%A5%E5%8F%8Atomcat%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章：<a href="/2020/07/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ALinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/" title="学习笔记之Linux学习（二）">学习笔记之Linux学习（二）</a><br>介绍了Linux常用命令，为本文以及后面的学习做了准备。<br>本文会详细的介绍Linux网卡配置、使用Xshell连接Linux终端、软件的上传、tomcat的安装、jdk的配置。</p>
<h1 id="一、Linux虚拟网卡的配置"><a href="#一、Linux虚拟网卡的配置" class="headerlink" title="一、Linux虚拟网卡的配置"></a>一、Linux虚拟网卡的配置</h1><p>首先我们打开Linux 的终端，如图所示：<br><img src="https://img-blog.csdnimg.cn/20200718174613722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开终端之后我们输入命令：<strong>ifconfig</strong>   查看网络编辑器. 查看网卡信息.<br>然后<strong>回车</strong>就可以看见我们的虚拟机的ip地址，但是这个是动态的地址，我们需要将它改为静态的。<br><img src="https://img-blog.csdnimg.cn/20200718174802695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来输入命令<strong>cd /etc/sysconfig/network-scripts/</strong><br>进入到该目录下，然后使用命令：<strong>ls</strong>      去查看当前目录下的文件：<br><img src="https://img-blog.csdnimg.cn/20200718175144502.png" alt="在这里插入图片描述"><br>红框圈中的就是我们需要编辑的网卡，使用命令：<strong>vim ifcfg-eth0</strong><br>对网卡进行编辑，执行这个命令之后会进入一个以下界面：<br><img src="https://img-blog.csdnimg.cn/20200718175435411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们按两下D按键就可以删除一行，把里面的内容全部删除，然后复制好以下配置，然后到编辑的那个终端右键选择paste粘贴进去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEVICE&#x3D;eth0</span><br><span class="line">BOOTPROTO&#x3D;static</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">IPADDR&#x3D;192.168.15.130</span><br><span class="line">NETMASK&#x3D;255.255.255.0</span><br><span class="line">GATEWAY&#x3D;192.168.15.2</span><br><span class="line">DNS1&#x3D;114.114.114.114</span><br><span class="line">DNS2&#x3D;4.4.4.4</span><br><span class="line">IPV6INIT&#x3D;no</span><br></pre></td></tr></table></figure>
<p>复制进去之后需要特别注意，一定要先检查一下复制的内容少了没有，如果少了的话就要加进去，这里要按<strong>i</strong>键进入编辑模式，按下<strong>i</strong>键之后左下角会出现<strong>INSERT</strong>说明可以编辑了，这里我们主要修改的地方就是下图所示内容：<br><img src="https://img-blog.csdnimg.cn/20200718180437556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>编辑完成之后先按一下键盘左上角的<strong>ESC</strong>退出编辑模式，<br>然后使用命令  <strong>:wq</strong>   意思是保存并退出。<br>这个时候再使用命令：<strong>service network restart</strong> 将我们的网卡重启一下，然后使用尝试一下ping百度，命令为：<strong>ping <a href="http://www.baidu.com/">www.baidu.com</a></strong><br>停止命令为：<strong>Ctrl+C</strong>，如果能正常上网应该是这样的：<br><img src="https://img-blog.csdnimg.cn/20200718180913108.png" alt="在这里插入图片描述"><br>这样我们的网卡就配置成功了，这个时候使用命令：<strong>ifconfig</strong><br>将我们的IP地址复制，可以将我们左上方的虚拟机名字命名为这个IP地址，复制好我们的IP地址之后，打开我们的Xshell软件。</p>
<h1 id="二、使用Xshell连接Linux终端"><a href="#二、使用Xshell连接Linux终端" class="headerlink" title="二、使用Xshell连接Linux终端"></a>二、使用Xshell连接Linux终端</h1><p>我们发现，在使用linux的终端的时候，我们想切屏啥的都不太习惯，而且我们平时使用的快捷键复制粘贴啥的在Linux里面都不能用，这个时候使用Xshell就解决了这样的一些问题。</p>
<p><strong>打开Xshell软件</strong><br>如果是第一次打开，它会弹出让你新建一个会话连接，并且让你填写一下信息，如图所示：<br><img src="https://img-blog.csdnimg.cn/20200718181632918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>注意：</strong>填写好名称和主机IP之后，点击确认，选择好刚刚创建的点击连接，然后选择接受并一次性保存，之后会弹出让你输入用户和密码，这里我建议使用root用户登录，然后勾选记住用户和密码，方便下次用的时候不用重复输入。</p>
<p>这样我们就可以在Xshell中使用Linux命令去操作Linux了，可以使用我们之前查看IP新的命令看一下：<strong>ifconfig</strong></p>
<p>如果关闭了Xshell软件之后再次打开，就在<strong>文件–&gt;打开</strong>  然后就可以看见我们创建的连接了。</p>
<h1 id="三、文件上传（lrzsz工具）"><a href="#三、文件上传（lrzsz工具）" class="headerlink" title="三、文件上传（lrzsz工具）"></a>三、文件上传（lrzsz工具）</h1><p>首先我们打开Xshell，并且连接上Linux。<br>使用文件上传的方式有很多种，这里我主要介绍一种比较简单的文件上传方式，这种方式需要在Linux中安装lrzsz工具。</p>
<p>输入命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y lrzsz</span><br></pre></td></tr></table></figure>
<p>网速好一下子就安装完成了，这样我们使用rz命令就可以方便的上传文件。</p>
<p>首先我们在root的目录下新建一个文件temp：<br><img src="https://img-blog.csdnimg.cn/20200718190146399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>命令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir temp</span><br></pre></td></tr></table></figure>
<p>然后使用cd命令进入该文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd temp</span><br></pre></td></tr></table></figure>
<p>在该目录下使用命令<strong>rz</strong>，这个时候会弹出一个让你选择文件的框，这里我们后面需要配置JDK和tomcta，选择好文件我们一个一个上传。</p>
<h1 id="四、配置JDK"><a href="#四、配置JDK" class="headerlink" title="四、配置JDK"></a>四、配置JDK</h1><p>文件上传完毕之后我们可以使用<strong>ls</strong>命令查看。<br><img src="https://img-blog.csdnimg.cn/20200718190606722.png" alt="在这里插入图片描述"><br><strong>第一步：</strong><br>这个时候我们开始去解压它，使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxf jdk-8u11-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
<p><strong>注：输入命令时可以按Tab键快速补齐。</strong><br>然后再用ls命令去查看一下当前目录就可以看见多出了一个文件夹。</p>
<p><strong>第二步：</strong><br>将解压后的文件拷贝到/usr/local/目录下，使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp jdk1.8.0_11&#x2F; &#x2F;usr&#x2F;local&#x2F;jdk -rf</span><br></pre></td></tr></table></figure>
<p>后面加的jdk相当于是在目标目录下新建了一个jdk的文件夹。拷贝完成之后可以cd /usr/local/ 目录下使用ls命令查看。返回root目录下使用cd 就行了<br><strong>第三步：</strong><br>使用以下命令去配置jdk：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p>用键盘的上下键移到该文件的最底部，然后按<strong>i</strong>键进入编辑模式，复制以下内容粘贴进去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk</span><br><span class="line">export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200718191833273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>注意：一定要检查好不要写漏或者写错，写完之后ESC退出编辑模式，然后:wq保存并退出。</strong></p>
<p><strong>第四步</strong><br>本来配置完这一步是要重启Linux才能完全让JDK生效的，但是这里我们可以先使用以下命令暂时不重启Linux来查看jdk是否配置好。（注意中间有空格）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">. &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p>然后使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200718192518655.png" alt="在这里插入图片描述"><br>出现以上就说明你的JDK配置成功啦。。。。</p>
<h1 id="五、tomcat的安装"><a href="#五、tomcat的安装" class="headerlink" title="五、tomcat的安装"></a>五、tomcat的安装</h1><p>首先使用<strong>cd /root/temp</strong>到我们的temp目录下，上传文件并且解压。<br>（以下为了多练习一下命令求多加了一步。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解压：tar -zxf  apache-tomcat-7.0.47.tar.gz          </span><br><span class="line">拷贝到：cp apache-tomcat-7.0.47 &#x2F;usr&#x2F;local&#x2F; -rf</span><br><span class="line">改名称：mv apache-tomcat-7.0.47&#x2F; tomcat</span><br></pre></td></tr></table></figure>
<p>然后我们就可以到该目录下去查看了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line">使用ls查看目录结构</span><br></pre></td></tr></table></figure>
<p>启动tomcat的目录就是在bin目录里面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd bin </span><br><span class="line">使用ls命令查看：</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200718193357954.png" alt="在这里插入图片描述"><br><strong>接下来便是去启动tomcat:</strong><br>启动之前首先要关闭防火墙：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关闭防火墙：service iptables stop</span><br><span class="line">启动命令：.&#x2F;startup.sh </span><br><span class="line">停止命令：.&#x2F;shutdown.sh </span><br></pre></td></tr></table></figure>
<p>启动成功之后，会是以下提示：<br><img src="https://img-blog.csdnimg.cn/20200718193531898.png" alt="在这里插入图片描述"><br>接下来我们就去浏览器访问我们Linux的tomcat，在浏览器中输入<br>Linux的ip地址+端口号<br>我的是：<a href="http://192.168.15.132:8080/">http://192.168.15.132:8080</a><br>访问成功之后会出现以下界面：<br><img src="https://img-blog.csdnimg.cn/20200718194011394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>出现以上界面就说明我们的tomcat安装成功了。<br><strong>如果浏览器访问不了就注意一定要关闭Linux 的防火墙。</strong></p>
<p><strong>如果觉得笔记符合需求的话不要忘记点赞收藏哦！</strong></p>
<p>返回首页：<a href="https://oldou.github.io/">点击此处</a></p>
<p>上一篇文章：<a href="/2020/07/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ALinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/" title="学习笔记之Linux学习（二）">学习笔记之Linux学习（二）</a></p>
<p>下一篇文章：<a href="/2020/07/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BZookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AZookeeper%E7%AE%80%E4%BB%8B%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E3%80%81%E7%9B%91%E5%90%AC%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E3%80%81%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E5%AE%89%E8%A3%85/" title="学习笔记之Zookeeper学习（一）">学习笔记之Zookeeper学习（一）</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Linux学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记</title>
    <url>/2020/07/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BRedis%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARedis%E4%BB%8B%E7%BB%8D%E3%80%81%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="一、Redis-介绍"><a href="#一、Redis-介绍" class="headerlink" title="一、Redis 介绍"></a>一、Redis 介绍</h1><h2 id="1、Redis-简介"><a href="#1、Redis-简介" class="headerlink" title="1、Redis  简介"></a>1、Redis  简介</h2><p>Remote Dictionary Server(Redis)是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。<br>它通常被称为数据结构服务器，因为值（value）可以是 <strong>字符串(String), 哈希(Map),列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</strong></p>
<h2 id="2、Redis-的特点"><a href="#2、Redis-的特点" class="headerlink" title="2、Redis  的特点"></a>2、Redis  的特点</h2><p>（1） 支持多种数据结构，如 string(字符串)、 list(双向链表)、dict(hash 表)、set(集合)、zset(排序 set)、hyperloglog(基数估算)<br>（2）支持持久化操作，可以进行 aof 及 rdb 数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。<br>（3）支持通过 Replication 进行数据复制，通过 master-slave 机制，可以实时进行数据的<br>同步复制，支持多级复制和增量复制，master-slave 机制是 Redis 进行 HA 的重要手段。<br>（4）单进程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。</p>
<h1 id="二、安装-Redis-单机版"><a href="#二、安装-Redis-单机版" class="headerlink" title="二、安装 Redis  单机版"></a>二、安装 Redis  单机版</h1><p>本次是在Linux环境下安装Redis，如果没有安装Linux，请安装一下，教程点<a href="/2020/07/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ALinux%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D%E3%80%81Xshell%E7%BB%88%E7%AB%AF%E7%9A%84%E5%AE%89%E8%A3%85/" title="这里">这里</a>。</p>
<p>本次介绍的Redis版本为：redis-3.0.0.tar.gz<br>redis 的版本：副版本号奇数版本号是测试版，不建议在生产环境中使用。偶数版本时稳定版建议在生产环境中使用。<br>3.0 版本更新比较大。集成了集群技术</p>
<p>下载链接在这里：<br>链接：<a href="https://pan.baidu.com/s/1M5Vgh0Ev4PfUka5rq_NdeQ">https://pan.baidu.com/s/1M5Vgh0Ev4PfUka5rq_NdeQ</a><br>提取码：qljm</p>
<h2 id="1、安装gcc"><a href="#1、安装gcc" class="headerlink" title="1、安装gcc"></a>1、安装gcc</h2><p>需要在 linux 系统中安装 gcc，命令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y gcc-c++</span><br></pre></td></tr></table></figure>
<h2 id="2、上传Redis并且解压"><a href="#2、上传Redis并且解压" class="headerlink" title="2、上传Redis并且解压"></a>2、上传Redis并且解压</h2><p>我们在root目录下的temp文件夹中上传并且解压Redis。<br>如果不熟悉上传和基本命令，就去点击<a href="/2020/07/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E5%8D%A1%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E9%85%8D%E7%BD%AEJDK%E3%80%81%E4%BB%A5%E5%8F%8Atomcat%E7%9A%84%E5%AE%89%E8%A3%85/" title="这里">这里</a>学习文件上传，基本命令在这片文章的上一节。</p>
<p>解压命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxf redis-3.0.0.tar.gz </span><br></pre></td></tr></table></figure>
<h2 id="3、编译、安装Redis"><a href="#3、编译、安装Redis" class="headerlink" title="3、编译、安装Redis"></a>3、编译、安装Redis</h2><p>解压完毕之后我们进入到解压后的Redis目录下，使用make命令对redis进行编译，编译成功之后，在redis的根目录下在执行安装命令进行安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">编译命令  make</span><br><span class="line">安装命令  make install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis</span><br></pre></td></tr></table></figure>
<p>意思就是安装在后面给定参数的目录下，没有这个目录就自动创建。<br>执行完毕之后进入到安装目录的bin目录下。<br><img src="https://img-blog.csdnimg.cn/20200720220547913.png" alt="在这里插入图片描述"><br>出现上图就编译成功了。。。。进行下一步安装<br>安装成功之后如下所示：<br><img src="https://img-blog.csdnimg.cn/20200720221040903.png" alt="在这里插入图片描述"></p>
<h2 id="4、启动Redis"><a href="#4、启动Redis" class="headerlink" title="4、启动Redis"></a>4、启动Redis</h2><p>Redis的启动分为前端启动和后端启动。</p>
<h3 id="4-1、前端启动"><a href="#4-1、前端启动" class="headerlink" title="4.1、前端启动"></a>4.1、前端启动</h3><p>去redis的安装目录的bin 目录下执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin</span><br><span class="line"> .&#x2F;redis-server     启动redis</span><br><span class="line"> （ctrl+c）退出 redis</span><br></pre></td></tr></table></figure>
<p>启动成功会看见一个Redis的图标。<br><img src="https://img-blog.csdnimg.cn/20200720221348541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="4-2、后端启动"><a href="#4-2、后端启动" class="headerlink" title="4.2、后端启动"></a>4.2、后端启动</h3><p>停止Redis，我们发现在前端启动不太方便，无法写其他命令，因此我们得修改一下启动方式，将启动方式改为后端启动。</p>
<p>进入到解压后的Redis目录下，进行以下操作：<br><strong>（1）先将 redis 解压目录下的 redis.conf 文件拷贝到 安装好的 redis 的 bin 目录下</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;root&#x2F;temp&#x2F;redis-3.0.0</span><br><span class="line"></span><br><span class="line">命令：cp redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin</span><br></pre></td></tr></table></figure>
<p><strong>（2）修改拷贝过来的 redis.conf 配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进入到cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin</span><br><span class="line">命令：vim redis.conf</span><br><span class="line"></span><br><span class="line">将里面的daemonize的no 改为 yes</span><br><span class="line">然后保存退出</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200720221739609.png" alt="在这里插入图片描述"></p>
<p><strong>（3）再次启动 redis</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在 bin 目录下执行命令：</span><br><span class="line">.&#x2F;redis-server redis.conf</span><br></pre></td></tr></table></figure>
<p><strong>（4）查看 redis 启动是否成功</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入命令：ps aux|grep redis</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200720221955612.png" alt="在这里插入图片描述"><br>如果过启动成功了，那么Redis的线程就会如上图所示。</p>
<p><strong>（5）测试 redis</strong><br>在 bin 目录下启动 redis 自带的客户端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> .&#x2F;redis-cli</span><br><span class="line">常见 redis 命令：</span><br><span class="line">ping---&gt;pong</span><br><span class="line">Ctrl+C退出</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200720222258555.png" alt="在这里插入图片描述"><br><strong>（6）关闭 redis 的命令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;redis-cli shutdown</span><br></pre></td></tr></table></figure>

<h1 id="三、Redis数据类型介绍"><a href="#三、Redis数据类型介绍" class="headerlink" title="三、Redis数据类型介绍"></a>三、Redis数据类型介绍</h1><h2 id="1、String-字符串"><a href="#1、String-字符串" class="headerlink" title="1、String( 字符串)"></a>1、String( 字符串)</h2><p>Redis 字符串是字节序列。Redis 字符串是二进制安全的，这意味着他们有一个已知的长度没有任何特殊字符终止，所以你可以存储任何东西，512 兆为上限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">redis 127.0.0.1:6379&gt; SET name kevin</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; GET name</span><br><span class="line">&quot;kevin&quot;</span><br></pre></td></tr></table></figure>
<p><strong>（1）incr：</strong> 让当前键值以 1 的数量递增，并返回递增后的值</p>
<p><strong>（2）incrby：</strong> 可以指定参数一次增加的数值，并返回递增后的值，(原来的num是2，加10之后变为12)</p>
<p><strong>（3）decr：</strong> 让当前键值以 1 的数量递减 并返回递减后的值</p>
<p><strong>（4）decrby：</strong> 可以指定参数一次递减的数值，并返回递减后的值</p>
<p><strong>（5）incrbyfloat：</strong> 可以递增一个双精度浮点数<br>以上三种方法和上面相加递增是一样的用法。</p>
<p><strong>（6）append：</strong> 作用是向键值的末尾追加 value。如果键不存在则将该键的值设置为 value。返回值是追加后字符串的总长度。<br><img src="https://img-blog.csdnimg.cn/20200720222749384.png" alt="在这里插入图片描述"><br><strong>（7）mget/mset</strong>作用与 get/set 相似，不过 mget/mset 可以同时获得/设置多个键的键值。这两个方法是批量设置和获取键值对。<br><img src="https://img-blog.csdnimg.cn/20200720222844792.png" alt="在这里插入图片描述"><br><strong>（8）del ：根据 key 来删除 value</strong><br><img src="https://img-blog.csdnimg.cn/20200720223021988.png" alt="在这里插入图片描述"><br><strong>（9）flushdb： 清除当前库的所有数据</strong><br><img src="https://img-blog.csdnimg.cn/20200720223042407.png" alt="在这里插入图片描述"></p>
<h2 id="2、Hash-hash-表"><a href="#2、Hash-hash-表" class="headerlink" title="2、Hash(hash  表)"></a>2、Hash(hash  表)</h2><p><img src="https://img-blog.csdnimg.cn/20200720223251751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>Redis 的哈希是键值对的集合。<br>Redis 的哈希值是字符串字段和字符串值之间的映射，因此它们被用来表示对象</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">redis 127.0.0.1:6379&gt; HSET key field value</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; HGET key field</span><br><span class="line">value</span><br></pre></td></tr></table></figure>
<p><strong>（1）hset：</strong> 存储一个哈希键值对的集合<br>基本格式： hset key field value  —–表示的是在key的field下设置一个为“value”的值。<br><img src="https://img-blog.csdnimg.cn/20200720223407790.png" alt="在这里插入图片描述"><br><strong>（2）hget</strong>：获取一个哈希键的值<br>基本格式：hget key field</p>
<p><strong>（3）hmset</strong>： 存储一个或多个哈希是键值对的集合<br>基本格式：hmset key field1 value1 ……fieldN keyN<br><img src="https://img-blog.csdnimg.cn/20200720223533543.png" alt="在这里插入图片描述"><br><strong>（4）hmget</strong>： 获取多个指定的键的值<br>基本格式：hmget key field1 … fieldN</p>
<p><strong>（5）hexists</strong>：判断哈希表中的字段名是否存在，如果存在返回 1 ，否则返回 0<br>基本格式： hexists key field<br><img src="https://img-blog.csdnimg.cn/20200720223642597.png" alt="在这里插入图片描述"><br><strong>（6）hdel</strong>： 删除一个或多个字段<br>基本格式：hdel key field<br><img src="https://img-blog.csdnimg.cn/2020072022373480.png" alt="在这里插入图片描述"><br><strong>（7）hgetall</strong>：获取一个哈希是键值对的集合<br>基本格式：hgetall key<br><img src="https://img-blog.csdnimg.cn/20200720223842172.png" alt="在这里插入图片描述"><br><strong>（8）hvals</strong>： 只返回字段值<br>基本格式：hvals key<br><img src="https://img-blog.csdnimg.cn/20200720223922934.png" alt="在这里插入图片描述"><br><strong>（9）hkeys</strong>： 只返回字段名<br>基本格式： hkeys key<br><img src="https://img-blog.csdnimg.cn/20200720224022331.png" alt="在这里插入图片描述"><br><strong>（10）hlen</strong>： 返回 key 的 hash 的元素个数<br>基本格式： hlen key<br><img src="https://img-blog.csdnimg.cn/20200720224054849.png" alt="在这里插入图片描述"><br>这里是因为user下有两个属性 username和userage</p>
<h2 id="3、List-链表"><a href="#3、List-链表" class="headerlink" title="3、List( 链表)"></a>3、List( 链表)</h2><p><img src="https://img-blog.csdnimg.cn/20200720224157124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Redis 的链表是简单的字符串列表，排序插入顺序。您可以添加元素到 Redis 的列表的头部或尾部<br>Lpush：表示的是向链表的左添加，也就是向链表的头添加；<br>Rpush：表示的是向链表的右添加，也就是向链表的尾添加；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush tutoriallist redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush tutoriallist mongodb</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush tutoriallist rabitmq</span><br><span class="line">(integer) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange tutoriallist 0 10</span><br><span class="line">1) &quot;rabitmq&quot;</span><br><span class="line">2) &quot;mongodb&quot;</span><br><span class="line">3) &quot;redis</span><br></pre></td></tr></table></figure>
<p>拿以上的前三句来解释：执行第一句的时候，相当于在图中的第三个Value添加了redis，然后执行第二句的时候，就在第二个Value处添加了mongodb，然后执行第三句的时候，就在第一个Value出添加了rabitmq，相当于就是左添加。所以执行第四句遍历的时候，从左往右遍历出来的顺序就是那样了。<br>如果第五句执行(rpush tutoriallist java),那么就是在redis的后面。也就是第四个Value处添加了java。</p>
<p><strong>（1）lpush key value</strong>： 向链表左侧添加<br><img src="https://img-blog.csdnimg.cn/20200720224613808.png" alt="在这里插入图片描述"><br><strong>（2）rpush key value</strong>： 向链表右侧添加</p>
<p><strong>（3）lpop key</strong>： 从左边移出一个元素<br>                    就是从最左边的那个节点剔除掉。<br><img src="https://img-blog.csdnimg.cn/20200720224708980.png" alt="在这里插入图片描述"><br><strong>（4）rpop key</strong>： 从右边移出一个元素<br>                    就是从最右边的那个节点剔除掉。<br><img src="https://img-blog.csdnimg.cn/20200720224733425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>（5）llen key</strong>： 返回链表中元素的个数 相当于关系型数据库中 select count(*)<br><img src="https://img-blog.csdnimg.cn/20200720224803187.png" alt="在这里插入图片描述"><br><strong>（6）lrange key start end lrange</strong>： 命令将返回索引从 start 到 stop 之间的所有元素。Redis 的列表起始索引为 0。<br><img src="https://img-blog.csdnimg.cn/20200720224836622.png" alt="在这里插入图片描述"><br>lrange也支持负索引 lrange nn -2 -1<br>如：-1 表示最右边第一个元素 ，-2 表示最右边第二个元素，依次类推。<br><img src="https://img-blog.csdnimg.cn/20200720224851644.png" alt="在这里插入图片描述"><br><strong>（7）lindex key indexnumber</strong>如果要将列表类型当做数组来用，lindex 命令是必不可少的。<br><img src="https://img-blog.csdnimg.cn/20200720224923461.png" alt="在这里插入图片描述"><br>lindex 命令用来返回指定索引的元素，索引从 0 开始，如果是负数表示从右边开始计算的索引，最右边元素的索引是-1。</p>
<p><strong>（8）lset key indexnumber value</strong>： 是另一个通过索引操作列表的命令，它会将索引为 index的元素赋值为 value，原来的值会被覆盖。<br><img src="https://img-blog.csdnimg.cn/20200720225024505.png" alt="在这里插入图片描述"></p>
<h2 id="4、Set-集合"><a href="#4、Set-集合" class="headerlink" title="4、Set( 集合)"></a>4、Set( 集合)</h2><p><img src="https://img-blog.csdnimg.cn/20200720225053826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>Redis 的集合是字符串的无序集合。<br>在Set集合当中，是不允许有重复的。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd tutoriallist redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd tutoriallist mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd tutoriallist rabitmq</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd tutoriallist rabitmq</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; smembers tutoriallist</span><br><span class="line">1) &quot;rabitmq&quot;</span><br><span class="line">2) &quot;mongodb&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></figure>
<p><strong>（1）sadd key value</strong>：<br>添加一个 string 元素到,key 对应的 set 集合中，<br>成功返回 1,如果元素已经在集合中返回 0<br><img src="https://img-blog.csdnimg.cn/20200720225156556.png" alt="在这里插入图片描述"></p>
<p><strong>（2）scard key</strong>： 返回 set 的元素个数，如果 set 是空或者 key 不存在返回 0<br><img src="https://img-blog.csdnimg.cn/20200720225250924.png" alt="在这里插入图片描述"><br><strong>（3）smembers key</strong>： 返回 key 对应 set 的所有元素，结果是无序的<br><img src="https://img-blog.csdnimg.cn/20200720225314417.png" alt="在这里插入图片描述"><br>但是不保证有序。</p>
<p><strong>（4）sismember key value</strong>： 判断 value 是否在 set 中，存在返回 1，0 表示不存在或者 key 不存在<br><img src="https://img-blog.csdnimg.cn/20200720225351398.png" alt="在这里插入图片描述"></p>
<p><strong>（5）srem key value</strong>：<br>从 key 对应 set 中移除给定元素，成功返回 1，<br>如果 value 在集合中不存在或者 key 不存在返回 0</p>
<h2 id="5、SortedSet-有序集合-zset"><a href="#5、SortedSet-有序集合-zset" class="headerlink" title="5、SortedSet( 有序集合)zset"></a>5、SortedSet( 有序集合)zset</h2><p> Redis 的有序集合类似于 Redis 的集合，字符串不重复的集合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd tutoriallist 0 redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd tutoriallist 0 mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd tutoriallist 0 rabitmq</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd tutoriallist 0 rabitmq</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; ZRANGEBYSCORE tutoriallist 0 1000</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;mongodb&quot;</span><br><span class="line">3) &quot;rabitmq&quot;</span><br></pre></td></tr></table></figure>
<p><strong>（1）zadd key score value</strong>： 将一个或多个 value 及其 socre 加入到 set 中<br><img src="https://img-blog.csdnimg.cn/20200720225539875.png" alt="在这里插入图片描述"><br><strong>（2）zrange key start end **：0 和-1 表示从索引为 0 的元素到最后一个元素（同 LRANGE 命令相似）<br><img src="https://img-blog.csdnimg.cn/20200720225605922.png" alt="在这里插入图片描述"><br>**（3）zrange key 0 -1 withscores **<br>也可以连同 score 一块输出，使用 WITHSCORES 参数<br><img src="https://img-blog.csdnimg.cn/20200720225632693.png" alt="在这里插入图片描述"><br>**（4）zremrangebyscore key start end</strong>： 可用于范围删除操作<br><img src="https://img-blog.csdnimg.cn/20200720225706584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>这里只介绍了5种数据类型，后面会持续更新。。。</strong></p>
<p>上一篇学习：学习笔记之</p>
<p>下一篇学习：学习笔记之Redis学习（二）</p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Redis学习</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记之TCP三次握手/四次挥手</title>
    <url>/2020/07/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP/IP 协议族"></a>TCP/IP 协议族</h1><p><strong>概念</strong>：在互联网使用的各种协议中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的 TCP/IP 并不一定是单指 TCP 和 IP 这两个具体的协议，而往往是表示互联网所使用的整个 TCP/IP 协议族。<br><img src="https://img-blog.csdnimg.cn/20200722080136957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>互联网协议套件（英语：Internet Protocol Suite，缩写IPS）是一个网络通讯模型，以及一整个网络传输协议家族，为网际网络的基础通讯架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP。因为该协定家族的两个核心协定：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。</p>
<p><strong>划重点：</strong><br>TCP（传输控制协议）和IP（网际协议） 是最先定义的两个核心协议，所以才统称为 TCP/IP协议族</p>
<h1 id="TCP的三次握手四次挥手"><a href="#TCP的三次握手四次挥手" class="headerlink" title="TCP的三次握手四次挥手"></a>TCP的三次握手四次挥手</h1><p> TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如ip地址、端口号等。</p>
<p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p>
<p> 一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：连接、数据传输、退出（关闭）。通过三次握手建立一个链接，通过四次挥手来关闭一个连接。</p>
<p>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。</p>
<h2 id="TCP报文的头部结构（重点）"><a href="#TCP报文的头部结构（重点）" class="headerlink" title="TCP报文的头部结构（重点）"></a>TCP报文的头部结构（重点）</h2><p><img src="https://img-blog.csdnimg.cn/20200722080458344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上图中有几个字段需要重点介绍下：</p>
<p>（1）<strong>序号：seq序号</strong>，占32位，用来标识从TCP源端向目的端发送的字节流，<br>                      发起方发送数据时对此进行标记。</p>
<p>（2）<strong>确认序号：ack序号</strong>，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。</p>
<p>（3）标志位：共6个，即URG、<strong>ACK</strong>、PSH、RST、<strong>SYN</strong>、<strong>FIN</strong>等，具体含义如下：</p>
<pre><code>            ACK：确认序号有效。
            FIN：释放一个连接。
            PSH：接收方应该尽快将这个报文交给应用层。
            RST：重置连接。
            SYN：发起一个新连接。
            URG：紧急指针（urgent pointer）有效。</code></pre>
<p><strong>需要注意的是：</strong><br>不要将确认序号ack与标志位中的ACK搞混了。<br>确认方ack=发起方seq+1，两端配对。</p>
<p><strong>重点理解加粗的部分，明白它是什么意思，有什么作用，在后面三次握手和四次挥手的时候会用到上面的字段！！！！！</strong></p>
<h2 id="理论解释TCP三次握手"><a href="#理论解释TCP三次握手" class="headerlink" title="理论解释TCP三次握手"></a>理论解释TCP三次握手</h2><pre><code> 三次握手的本质是确认通信双方收发数据的能力</code></pre>
<p><strong>首先，我让信使运输一份信件给对方</strong>，对方收到了，那么<strong>他就知道了我的发件能力和他的收件能力是可以的</strong>。于是他给我回信，我若收到了，<strong>我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以</strong>。<br><strong>然而此时他还不知道他的发件能力和我的收件能力到底可不可以</strong>，于是我最后回馈一次，他若收到了，他便清楚了他的发件能力和我的收件能力是可以的。<br> 这就是三次握手，这样说，你理解了吗？<br><img src="https://img-blog.csdnimg.cn/20200722081039506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <strong>第一次握手</strong>：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。</p>
<p><strong>第二次握手</strong>：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。</p>
<p><strong>第三次握手</strong>：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。</p>
<h2 id="大白话解释TCP的三次握手"><a href="#大白话解释TCP的三次握手" class="headerlink" title="大白话解释TCP的三次握手"></a>大白话解释TCP的三次握手</h2><p>TCP三次握手的基本思想就是“让我知道你已经知道”了。<br>服务器监听请求，客户端发起连接请求（第一次连接），请求在路上可能存在丢失的风险，所以当请求到了服务器后如果服务器同意建立连接会给客户端一个回信（第二次连接），告诉它：我已经收到请求，可以连接。</p>
<p>但是回信也存在一个问题，那就是回信能不能到客户端？它需要客户端给他一个回信说我已经收到批准通知了，如果客户端一直不回复的话意味着客户端没有收到批准通知。</p>
<p>因此客户端一收到批准通知就立马回复（第三次握手）：OK老铁我收到你的批准通知了。至此，三次握手结束。 </p>
<p> 一个很类似的例子就是投简历：先投简历，然后对方公司会通知你通过简历筛选，你收到这个通知后一般会回复一下我知道了。</p>
<p>这种“让我知道你已经知道了”的想法是一种约定俗成的可靠信息交互的基本方式，基于此想法构建的信息交互框架叫做协议。</p>
<h2 id="理论解释TCP四次挥手"><a href="#理论解释TCP四次挥手" class="headerlink" title="理论解释TCP四次挥手"></a>理论解释TCP四次挥手</h2><pre><code>四次挥手的目的是关闭一个连接</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200722081447358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。</p>
<p><strong>第一次挥手</strong>：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含<strong>FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)**。</strong>需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据**；另外FIN报文段即使不携带数据也要占据一个序列号。</p>
<p><strong>第二次挥手</strong>：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含<strong>ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)**。</strong>此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文**，这个状态还要持续一段时间，因为服务端可能还有数据没发完。</p>
<p><strong>第三次挥手</strong>：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文**包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)**。</p>
<p><strong>第四次挥手</strong>：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。</p>
<h2 id="大白话解释四次挥手"><a href="#大白话解释四次挥手" class="headerlink" title="大白话解释四次挥手"></a>大白话解释四次挥手</h2><p>四次挥手的话，就是双方交流得差不多了，此时客户端已经结尾了，要断开通信连接，所以就告诉服务器“我说完了(FIN)”，此时自身行成等待结束连接的状态，但是客户端还可以接受数据，只是不发送数据了，这是第一次挥手；</p>
<p>然后服务器已经知道客户端要断开连接了，但是服务器此时要告诉客户端，<br>我已经知道你要断开连接了，但是我还有话要说，这是第二次挥手；</p>
<p>此时客户端继续保持等待结束状态听服务器把话说完，服务器说完了之后自身此时也处于等待关闭连接状态，就对客户端再发一次信息，“我已经说完了，咱们断开连接了(FIN)”，这是第三次挥手；</p>
<p>然后客户端收到服务器信息之后，也要告诉服务器一下（ACK），这是第四次挥手；</p>
<p>因为连接号呃断开都要双方按下关闭操作才能断开，客户端同时为自己定义一个计时器，因为不知道刚才说的话能不能准确到达服务器(默认时间是两次通信的最大时间和)，超出了这个时间就默认服务器已经收到自己确认信息了，此时客户端就关闭自身链接，服务器一旦接受到客户端发来的确定通知就立刻关闭服务器端的链接。<br><strong>精确的说就是：</strong><br>第一次。A跟B说，我发完我的信息（但是还可以接受信息），我要断开连接了。<br>第二次。B跟A说，好的，我知道了，那我不再接收你的信息了（但是我的信息还没发完，等待关闭）。<br>第三次。B跟A说，我传给你的信息传完了，你可以关闭连接了。<br>第四次。A跟B说，好的，我关闭连接了。</p>
<h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><h2 id="1、TCP和UDP的区别和优缺点是什么？"><a href="#1、TCP和UDP的区别和优缺点是什么？" class="headerlink" title="1、TCP和UDP的区别和优缺点是什么？"></a>1、TCP和UDP的区别和优缺点是什么？</h2><p>（1）TCP是面向连接的，UDP是无连接的；<br>（2）TCP提供可靠的服务，UDP提供不可靠服务；<br>（3）UDP具有较好的实时性，工作效率比TCP高；<br>（4）TCP连接只能做到点到点，而UDP支持一对一，一对多，多对一和多对多的连接；<br>（5）TCP对系统资源要求较多，UDP对系统要求较少；</p>
<h2 id="2、为什么TCP连接的时候是3次？2次不可以吗？"><a href="#2、为什么TCP连接的时候是3次？2次不可以吗？" class="headerlink" title="2、为什么TCP连接的时候是3次？2次不可以吗？"></a>2、为什么TCP连接的时候是3次？2次不可以吗？</h2><p>因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。</p>
<p>如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。</p>
<h2 id="3、为什么TCP连接的时候是3次，关闭的时候却是4次？"><a href="#3、为什么TCP连接的时候是3次，关闭的时候却是4次？" class="headerlink" title="3、为什么TCP连接的时候是3次，关闭的时候却是4次？"></a>3、为什么TCP连接的时候是3次，关闭的时候却是4次？</h2><p>因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。</p>
<h2 id="4、为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"><a href="#4、为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？" class="headerlink" title="4、为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"></a>4、为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</h2><p>这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。</p>
<h2 id="5、如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#5、如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="5、如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>5、如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2><p>TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
]]></content>
      <categories>
        <category>TCP/IP</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记之Zookeeper学习（二）：Zookeeper集群的安装、启动关闭脚本的编写、常用命令介绍</title>
    <url>/2020/07/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BZookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AZookeeper%E7%AE%80%E4%BB%8B%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E3%80%81%E7%9B%91%E5%90%AC%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E3%80%81%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="一、Zookeeper-简介"><a href="#一、Zookeeper-简介" class="headerlink" title="一、Zookeeper 简介"></a>一、Zookeeper 简介</h1><p>Zookeeper 官网： <a href="http://zookeeper.apache.org/">http://zookeeper.apache.org/</a><br>Zookeeper 是 Apache 的一个分布式服务框架，是 Apache Hadoop 的一个子项目。官方<br>文档上这么解释 Zookeeper，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，<br>如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。<br>简单来说 zookeeper=文件系统+监听通知机制。</p>
<h1 id="二、-Zookeeper-存储结构"><a href="#二、-Zookeeper-存储结构" class="headerlink" title="二、 Zookeeper 存储结构"></a>二、 Zookeeper 存储结构</h1><p><img src="https://img-blog.csdnimg.cn/20200719201812653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="（1）Znode"><a href="#（1）Znode" class="headerlink" title="（1）Znode"></a>（1）Znode</h2><p>在 Zookeeper 中，znode 是一个跟 Unix 文件系统路径相似的节点，可以向节点存储数据或者获取数据。<br>Zookeeper 底层是一套数据结构。这个存储结构是一个树形结构，其上的每一个节点，我们称之为“znode”。<br>Zookeeper 中的数据是按照“树”结构进行存储的。而且 znode 节点还分为 4 中不同的类型。<strong>每一个 znode 默认能够存储 1MB 的数据</strong>（对于记录状态性质的数据来说，够了），可以使用 zkCli 命令，登录到 Zookeeper 上，并通过<strong>ls、create、delete、get、set</strong>等命令操作这些 znode 节点。</p>
<h2 id="（2）Znode-节点类型"><a href="#（2）Znode-节点类型" class="headerlink" title="（2）Znode 节点类型"></a>（2）Znode 节点类型</h2><h3 id="（2-1）-PERSISTENT-持久化目录节点"><a href="#（2-1）-PERSISTENT-持久化目录节点" class="headerlink" title="（2.1） PERSISTENT-持久化目录节点"></a>（2.1） PERSISTENT-持久化目录节点</h3><p>客户端与 zookeeper 断开连接后，该节点依旧存在。</p>
<h3 id="（2-2）-PERSISTENT-SEQUENTIAL-持久化顺序编号目录节点"><a href="#（2-2）-PERSISTENT-SEQUENTIAL-持久化顺序编号目录节点" class="headerlink" title="（2.2） PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点"></a>（2.2） PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点</h3><p>客户端与 zookeeper 断开连接后，该节点依旧存在，只是 Zookeeper 给该节点名称进行顺序编号。</p>
<h3 id="（2-3）-EPHEMERAL-临时目录节点"><a href="#（2-3）-EPHEMERAL-临时目录节点" class="headerlink" title="（2.3） EPHEMERAL-临时目录节点"></a>（2.3） EPHEMERAL-临时目录节点</h3><p>客户端与 zookeeper 断开连接后，该节点被删除。</p>
<h3 id="（2-4）-EPHEMERAL-SEQUENTIAL-临时顺序编号目录节点"><a href="#（2-4）-EPHEMERAL-SEQUENTIAL-临时顺序编号目录节点" class="headerlink" title="（2.4） EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点"></a>（2.4） EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</h3><p>客户端与 zookeeper 断开连接后，该节点被删除，只是 Zookeeper 给该节点名称进行顺序编号。</p>
<h1 id="三、-监听通知机制"><a href="#三、-监听通知机制" class="headerlink" title="三、 监听通知机制"></a>三、 监听通知机制</h1><p>Zookeeper 是使用观察者设计模式来设计的。当客户端注册监听它关心的目录节点时，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，Zookeeper 会通知客户端。</p>
<h1 id="四、-安装-zookeeper（单机版）"><a href="#四、-安装-zookeeper（单机版）" class="headerlink" title="四、 安装 zookeeper（单机版）"></a>四、 安装 zookeeper（单机版）</h1><p>官方资源包可在 <a href="https://zookeeper.apache.org/releases.html">https://zookeeper.apache.org/</a> 站点中下载。<br>可以去下载最新版，这里我介绍的zookeeper版本为：3.6.0。</p>
<h2 id="1、安装Linux"><a href="#1、安装Linux" class="headerlink" title="1、安装Linux"></a>1、安装Linux</h2><p>如果不知道该怎么安装Linux，<a href="https://blog.csdn.net/weixin_43246215/article/details/107430831">点击这里</a>。</p>
<h2 id="2、安装JDK"><a href="#2、安装JDK" class="headerlink" title="2、安装JDK"></a>2、安装JDK</h2><p>如果不知道该怎么安装JDK，<a href="https://blog.csdn.net/weixin_43246215/article/details/107432534">点击这里</a>。<br>并且配置jdk的环境变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk</span><br><span class="line">export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>

<h2 id="3、上传-Zookeeper"><a href="#3、上传-Zookeeper" class="headerlink" title="3、上传 Zookeeper"></a>3、上传 Zookeeper</h2><p>在虚拟机的root目录下新建了一个temp目录，我们将文件上传到temp目录下，如果不知道文件该怎么上传的请学习<a href="https://blog.csdn.net/weixin_43246215/article/details/107432534">这个笔记</a>。<br>文件上传之后，将文件解压并且拷贝到/usr/local/zookeeper目录下，命令如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost temp]# tar -zxf zookeeper-3.6.0.tar.gz</span><br><span class="line">[root@localhost temp]# cp zookeeper-3.6.0 &#x2F;usr&#x2F;local&#x2F;zookeeper -r</span><br></pre></td></tr></table></figure>
<p>然后可以进入zookeeper目录下使用ls查看目录结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. bin：放置运行脚本和工具脚本，</span><br><span class="line">2. conf：zookeeper 默认读取配置的目录，里面会有默认的配置文件</span><br><span class="line">3. docs：zookeeper 相关的文档</span><br><span class="line">4. lib：zookeeper 核心的 jar</span><br><span class="line">5. logs：zookeeper 日志</span><br></pre></td></tr></table></figure>
<h2 id="4、配置zookeeper"><a href="#4、配置zookeeper" class="headerlink" title="4、配置zookeeper"></a>4、配置zookeeper</h2><p>Zookeeper 在启动时默认的去 conf 目录下查找一个名称为 zoo.cfg 的配置文件。在 zookeeper 应用目录中有子目录 conf。<br>其中有配置文件模板：zoo_sample.cfg，因此我们进入到该目录下将文件拷贝一份并且重新命名，将zookeeper 应用中的配置文件改为 conf/zoo.cfg。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd zookeeper&#x2F;conf</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>
<p>之后便是修改配置文件 zoo.cfg - 设置数据缓存路径，我们先退回到zookeeper的目录下，使用mkdir命令新建一个文件夹data，使用pwd命令获取当前文件的路径，复制路径，然后再进入到conf目录下编辑配置文件 zoo.cfg。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ..</span><br><span class="line">mkdir data</span><br><span class="line">pwd</span><br><span class="line">cd ..&#x2F;conf</span><br><span class="line">vim zoo.cfg</span><br></pre></td></tr></table></figure>
<p>然后将配置文件作一下修改，然后ESC，保存并退出(:wq)：<br><img src="https://img-blog.csdnimg.cn/20200719204534884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="5、启动Zookeeper"><a href="#5、启动Zookeeper" class="headerlink" title="5、启动Zookeeper"></a>5、启动Zookeeper</h2><p>以上配置完成之后，我们进入到zookeeper/bin目录下，<br>使用以下命令启动zookeeper：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动zookeeper：</span><br><span class="line">.&#x2F;zkServer.sh start</span><br><span class="line"></span><br><span class="line">关闭zookeeper：</span><br><span class="line">.&#x2F;zkServer.sh stop</span><br><span class="line"></span><br><span class="line">查看zookeeper状态：</span><br><span class="line">.&#x2F;zkServer.sh status</span><br></pre></td></tr></table></figure>
<p>默认加载配置文件：./zkServer.sh start：默认的会去 conf 目录下加载 zoo.cfg 配置文件。<br>指定加载配置文件：./zkServer.sh start 配置文件的路径。<br>启动成功图为：<br><img src="https://img-blog.csdnimg.cn/20200719205545618.png" alt="在这里插入图片描述"></p>
<h2 id="6、使用客户端连接单机版-Zookeeper"><a href="#6、使用客户端连接单机版-Zookeeper" class="headerlink" title="6、使用客户端连接单机版 Zookeeper"></a>6、使用客户端连接单机版 Zookeeper</h2><p>前提是先成功启动zookeeper，如果启动不成功请详细检查自己哪一步出错了。</p>
<h3 id="6-1、连接方式一"><a href="#6-1、连接方式一" class="headerlink" title="6.1、连接方式一"></a>6.1、连接方式一</h3><p>到zookeeper的bin目录下使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkCli.sh</span><br></pre></td></tr></table></figure>
<p>默认连接地址为本机地址，默认连接端口为 2181<br>成功连接之后为：<br><img src="https://img-blog.csdnimg.cn/20200719205836271.png" alt="在这里插入图片描述"><br><strong>按Ctrl+C退出，或者输入命令quit</strong></p>
<h3 id="6-2、连接方式二"><a href="#6-2、连接方式二" class="headerlink" title="6.2、连接方式二"></a>6.2、连接方式二</h3><p>这种方式可以远程调用，这里不做详细介绍，<br>还是在bin目录下执行以下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkCli.sh -server ip:port</span><br><span class="line">连接指定 IP 地址与端口</span><br></pre></td></tr></table></figure>
<p>比如说我192.168.15.130的虚拟机下也装了一个zookeeper单机版，那我在启动两个虚拟主机的zookeeper之后，在本机的zookeeper/bin目录下使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkCli.sh -server 192.168.15.130:2181</span><br><span class="line">如果130的那台zookeeper的端口还是2181的话就这样写</span><br></pre></td></tr></table></figure>
<h1 id="五、下篇学习预告"><a href="#五、下篇学习预告" class="headerlink" title="五、下篇学习预告"></a>五、下篇学习预告</h1><p>Zookeeper集群的安装<br>Zookeeper常用命令介绍</p>
<p>上一篇学习：<a href="/2020/07/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E5%8D%A1%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E9%85%8D%E7%BD%AEJDK%E3%80%81%E4%BB%A5%E5%8F%8Atomcat%E7%9A%84%E5%AE%89%E8%A3%85/" title="学习笔记之Linux学习（三）">学习笔记之Linux学习（三）</a></p>
<p>下一篇学习：<a href="/2020/07/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BZookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AZookeeper%E9%9B%86%E7%BE%A4%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E5%90%AF%E5%8A%A8%E5%85%B3%E9%97%AD%E8%84%9A%E6%9C%AC%E7%9A%84%E7%BC%96%E5%86%99%E3%80%81%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/" title="学习笔记之Zookeeper学习（二）">学习笔记之Zookeeper学习（二）</a></p>
<p><strong>如果觉得对自己有帮助，欢迎大家点赞、评论！</strong></p>
]]></content>
      <categories>
        <category>Zookeeper</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Zookeeper学习</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记之Zookeeper学习（二）：Zookeeper集群的安装、启动关闭脚本的编写、常用命令介绍</title>
    <url>/2020/07/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BZookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AZookeeper%E9%9B%86%E7%BE%A4%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E5%90%AF%E5%8A%A8%E5%85%B3%E9%97%AD%E8%84%9A%E6%9C%AC%E7%9A%84%E7%BC%96%E5%86%99%E3%80%81%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章主要介绍了<a href="/2020/07/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BZookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AZookeeper%E7%AE%80%E4%BB%8B%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E3%80%81%E7%9B%91%E5%90%AC%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E3%80%81%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E5%AE%89%E8%A3%85/" title="Zookeeper单机版的安装">Zookeeper单机版的安装</a><br>本篇文章主要讲解Zookeeper集群版以及Zookeeper常用命令介绍。</p>
<h1 id="一、Zookeeper集群"><a href="#一、Zookeeper集群" class="headerlink" title="一、Zookeeper集群"></a>一、Zookeeper集群</h1><h2 id="1、Zookeeper-集群说明"><a href="#1、Zookeeper-集群说明" class="headerlink" title="1、Zookeeper 集群说明"></a>1、Zookeeper 集群说明</h2><h3 id="1-1-Zookeeper-集群中的角色"><a href="#1-1-Zookeeper-集群中的角色" class="headerlink" title="1.1 Zookeeper 集群中的角色"></a>1.1 Zookeeper 集群中的角色</h3><p>Zookeeper 集群中的角色主要有以下三类：<br><img src="https://img-blog.csdnimg.cn/20200719211946488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200719211957325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2、集群的搭建（伪集群）"><a href="#2、集群的搭建（伪集群）" class="headerlink" title="2、集群的搭建（伪集群）"></a>2、集群的搭建（伪集群）</h2><p>使用 3 个 Zookeeper 应用搭建一个伪集群。应用部署位置是：192.168.15.131。<br>客户端监听端口分别为：2181、2182、2183。投票选举端口分别为 2881/3881、2882/3882、2883/3883。</p>
<h3 id="2-1、拷贝文件"><a href="#2-1、拷贝文件" class="headerlink" title="2.1、拷贝文件"></a>2.1、拷贝文件</h3><p>首先在/usr/local/的目录下新建一个文件zookeeperCluster用于存放后续文件，然后将root/temp目录下我们解压的zookeeper文件做拷贝，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local</span><br><span class="line">mkdir zookeeperCluster</span><br><span class="line">cd &#x2F;root&#x2F;temp</span><br><span class="line">cp apache-zookeeper-3.6.0-bin &#x2F;usr&#x2F;local&#x2F;zookeeperCluster&#x2F;zookeeper01 -r</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;zookeeperCluster&#x2F;zookeeper01&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="2-2、提供缓存目录并拷贝应用"><a href="#2-2、提供缓存目录并拷贝应用" class="headerlink" title="2.2、提供缓存目录并拷贝应用"></a>2.2、提供缓存目录并拷贝应用</h3><p>这里我们进入到zookeeperCluster的zookeeper01目录下之后，新建一个data目录，用于缓存应用运行数据，创建之后进入data目录使用pwd命令获取路径，然后复制路径，返回到zookeeperCluster目录下，使用cp命令将zookeeper复制两份，用于模拟集群中的3个节点，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir data</span><br><span class="line">cd data </span><br><span class="line">pwd</span><br><span class="line">cd ..&#x2F;..</span><br><span class="line">cp zookeeper01 zookeeper02 -r</span><br><span class="line">cp zookeeper01 zookeeper03 -r</span><br></pre></td></tr></table></figure>
<h3 id="2-3、提供配置文件、设置缓存路径"><a href="#2-3、提供配置文件、设置缓存路径" class="headerlink" title="2.3、提供配置文件、设置缓存路径"></a>2.3、提供配置文件、设置缓存路径</h3><p>在每个zookeeper应用目录中有子目录 conf，需要配置里面的配置文件，<br>首先进入到zookeeper01/conf目录下将zoo_sample.cfg改为zoo.cfg，然后使用vim命令编辑这个文件，在这个文件中加入dataDir 参数值为应用运行缓存数据保存目录，每个Zookeeper都要这样配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd zookeeper01&#x2F;conf</span><br><span class="line">cp zoo_sample.cfg  zoo.cfg -r</span><br><span class="line">vim zoo.cfg</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200719214210430.png" alt="在这里插入图片描述"><br>这里要将三个zookeeper的配置文件都要改名、然后加入这样的配置。</p>
<h3 id="2-4、提供应用唯一标识"><a href="#2-4、提供应用唯一标识" class="headerlink" title="2.4、提供应用唯一标识"></a>2.4、提供应用唯一标识</h3><p>在 Zookeeper 集群中，每个节点需要一个唯一标识。这个唯一标识要求是自然数。且唯一标识保存位置是：<br>数据缓存目录(dataDir=/usr/local/zookeeper/data)的 myid 文件中。其中“数据缓存目录”为配置文件 zoo.cfg 中的配置参数。<br>执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 1 &gt;&gt; zookeeper01&#x2F;data&#x2F;myid</span><br><span class="line">echo 2 &gt;&gt; zookeeper02&#x2F;data&#x2F;myid</span><br><span class="line">echo 3 &gt;&gt; zookeeper03&#x2F;data&#x2F;myid</span><br></pre></td></tr></table></figure>
<p>然后可以使用cat zookeeper01/data/myid去查看唯一标识。</p>
<h3 id="2-5、修改配置文件-zoo-cfg-设置服务、投票、选举端口"><a href="#2-5、修改配置文件-zoo-cfg-设置服务、投票、选举端口" class="headerlink" title="2.5、修改配置文件 zoo.cfg - 设置服务、投票、选举端口"></a>2.5、修改配置文件 zoo.cfg - 设置服务、投票、选举端口</h3><p>首先要进入到每个zookeeper的conf目录下去编辑zoo.cfg文件，<br>编辑内容如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim zookeeper01&#x2F;conf&#x2F;zoo.cfg</span><br><span class="line">#服务端口根据应用做对应修改,zk01-2181,zk02-2182,zk03-2183</span><br><span class="line">clientPort&#x3D;2181 </span><br><span class="line">server.1&#x3D;192.168.15.131:2881:3881</span><br><span class="line">server.2&#x3D;192.168.15.131:2882:3882</span><br><span class="line">server.3&#x3D;192.168.15.131:2883:3883</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200719215101811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>以上为zookeeper01的设置，如果是zookeeper02，属性clientPort就是2182，如下所示（这里我只演示两个zookeeper的，第三个自己配置）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim zookeeper02&#x2F;conf&#x2F;zoo.cfg</span><br><span class="line">#服务端口根据应用做对应修改,zk01-2181,zk02-2182,zk03-2183</span><br><span class="line">clientPort&#x3D;2182 </span><br><span class="line">server.1&#x3D;192.168.15.131:2881:3881</span><br><span class="line">server.2&#x3D;192.168.15.131:2882:3882</span><br><span class="line">server.3&#x3D;192.168.15.131:2883:3883</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200719215513553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>三个zookeeper都配置完成之后就保存退出，然后就是编写我们的启动和停止脚本了。</p>
<h3 id="2-6、编写启动、关闭集群脚本并且授权"><a href="#2-6、编写启动、关闭集群脚本并且授权" class="headerlink" title="2.6、编写启动、关闭集群脚本并且授权"></a>2.6、编写启动、关闭集群脚本并且授权</h3><p><strong>回到zookeeperCluster目录下</strong>，使用以下命令去创建并编辑脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动脚本</span><br><span class="line">第一步：vim start.sh </span><br><span class="line">第二步复制以下内容粘贴到以上文件中，然后保存退出</span><br><span class="line">zookeeper01&#x2F;bin&#x2F;zkServer.sh start  </span><br><span class="line">zookeeper02&#x2F;bin&#x2F;zkServer.sh start</span><br><span class="line">zookeeper03&#x2F;bin&#x2F;zkServer.sh start</span><br><span class="line"></span><br><span class="line">关闭脚本：</span><br><span class="line">第一步：vim stop.sh </span><br><span class="line">第二步复制以下内容粘贴到以上文件中，然后保存退出</span><br><span class="line">zookeeper01&#x2F;bin&#x2F;zkServer.sh stop </span><br><span class="line">zookeeper02&#x2F;bin&#x2F;zkServer.sh stop</span><br><span class="line">zookeeper03&#x2F;bin&#x2F;zkServer.sh stop</span><br><span class="line"></span><br><span class="line">查看状态的脚本：</span><br><span class="line">第一步：vim status.sh </span><br><span class="line">第二步复制以下内容粘贴到以上文件中，然后保存退出</span><br><span class="line">zookeeper01&#x2F;bin&#x2F;zkServer.sh status</span><br><span class="line">zookeeper02&#x2F;bin&#x2F;zkServer.sh status</span><br><span class="line">zookeeper03&#x2F;bin&#x2F;zkServer.sh status</span><br></pre></td></tr></table></figure>
<p>脚本编写完毕之后，由于没有授权不能运行，因此我们还要进行授权，<br>如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给启动脚本授权：</span><br><span class="line">chmod +x start.sh</span><br><span class="line"></span><br><span class="line">给关闭脚本授权：</span><br><span class="line">chmod +x stop.sh </span><br><span class="line"></span><br><span class="line">给查看状态的脚本授权：</span><br><span class="line">chmod +x  status.sh </span><br></pre></td></tr></table></figure>
<p>授权完毕之后就可以去使用脚本启动zookeeper集群了。<br><strong>注意：脚本文件的配置是在zookeeperCluster目录下进行的，启动关闭也是在该目录下执行。</strong></p>
<p>启动命令：**./start.sh**<br><img src="https://img-blog.csdnimg.cn/20200719220545544.png" alt="在这里插入图片描述"><br>停止命令：**./stop.sh**</p>
<h3 id="2-7、客户端连接Zookeeper集群"><a href="#2-7、客户端连接Zookeeper集群" class="headerlink" title="2.7、客户端连接Zookeeper集群"></a>2.7、客户端连接Zookeeper集群</h3><p>在集群启动的情况下，使用以下命令我们可以在zookeeperCluster目录下连接集群：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式为：zkCli.sh -server host:port</span><br><span class="line">.&#x2F;zookeeper&#x2F;bin&#x2F;zkCli.sh -server 192.168.15.131:2181</span><br></pre></td></tr></table></figure>
<p>连接成功之后是这样的：<br><img src="https://img-blog.csdnimg.cn/20200719221414503.png" alt="在这里插入图片描述"><br><strong>注意：在本机的集群情况下我们可以连接任何一个端口，如果是三个Linux组合成的集群，那么中间的ip地址就可以填对应的linux地址，因为是集群，所以我们链接其中的任何一个都可以。</strong></p>
<h1 id="二、常用命令的介绍"><a href="#二、常用命令的介绍" class="headerlink" title="二、常用命令的介绍"></a>二、常用命令的介绍</h1><h2 id="1-ls-命令"><a href="#1-ls-命令" class="headerlink" title="1 ls 命令"></a>1 ls 命令</h2><p>基本格式为：<strong>ls /path</strong><br>使用 ls 命令查看 zookeeper 中的内容。在 ZooKeeper 控制台客户端中，没有默认列表功能，必须指定要列表资源的位置。 如： ls / 或者 ls /path<br><img src="https://img-blog.csdnimg.cn/20200719221527850.png" alt="在这里插入图片描述"></p>
<h2 id="2-create-命令"><a href="#2-create-命令" class="headerlink" title="2 create 命令"></a>2 create 命令</h2><p><strong>create [-e] [-s] /path [data]</strong><br>使用 create 命令创建一个新的 Znode。create [-e] [-s] path data - 创建节点，如： create /test 123 创建一个/test 节点，节点携带数据信息 123。 </p>
<p>create -e /test 123 创建一个临时节点/test，携带数据为 123，临时节点只在当前会话生命周期中有效，会话结束节点自动删除。</p>
<p>create -s /test 123 创建一个顺序节点/test，携带数据 123，创建的顺序节点由 ZooKeeper 自动为节点增加后缀信息，如-/test00000001 等。-e 和-s 参数可以联合使用。<br><img src="https://img-blog.csdnimg.cn/20200719221631676.png" alt="在这里插入图片描述"></p>
<h2 id="3-get-命令"><a href="#3-get-命令" class="headerlink" title="3 get 命令"></a>3 get 命令</h2><p>基本格式为：<strong>get [-s] /path</strong>  </p>
<p>get 命令获取 Znode 中的数据。<img src="https://img-blog.csdnimg.cn/20200719221732262.png" alt="在这里插入图片描述"><br><strong>get -s /path</strong><br>            -s 查看 Znode 详细信息<br><img src="https://img-blog.csdnimg.cn/20200719221815110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1）oldlu:存放的数据<br>（2）cZxid:创建时 zxid(znode 每次改变时递增的事务 id)<br>（3）ctime:创建时间戳<br>（4）mZxid:最近一次更近的 zxid<br>（5）mtime:最近一次更新的时间戳<br>（6）pZxid:子节点的 zxid<br>（7）cversion:子节点更新次数<br>（8）dataversion:节点数据更新次数<br>（9）aclVersion:节点 ACL(授权信息)的更新次数<br>（10）ephemeralOwner:如果该节点为 ephemeral 节点(临时，生命周期与 session 一样),ephemeralOwner 值表示与该节点绑定的 session id. 如果该节点不是ephemeral 节点, ephemeralOwner 值为 0.<br>（11）dataLength:节点数据字节数<br>（12）numChildren:子节点数量</p>
<h2 id="4-set-命令"><a href="#4-set-命令" class="headerlink" title="4 set 命令"></a>4 set 命令</h2><p>基本格式为：<strong>set /path [data]</strong><br>添加或修改 Znode 中的值<img src="https://img-blog.csdnimg.cn/20200719222038655.png" alt="在这里插入图片描述"></p>
<h2 id="5-delete-命令"><a href="#5-delete-命令" class="headerlink" title="5 delete 命令"></a>5 delete 命令</h2><p>基本格式为：<strong>delete /path</strong><br>删除 Znode。<br><img src="https://img-blog.csdnimg.cn/20200719222110924.png" alt="在这里插入图片描述"></p>
<p>上一篇学习：<a href="/2020/07/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BZookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AZookeeper%E7%AE%80%E4%BB%8B%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E3%80%81%E7%9B%91%E5%90%AC%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E3%80%81%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E5%AE%89%E8%A3%85/" title="学习笔记之Zookeeper学习（一）">学习笔记之Zookeeper学习（一）</a></p>
<p>下一篇学习：学习笔记之Zookeeper学习（三）</p>
<p><strong>喜欢的小伙伴记得点一下赞哦，谢谢！</strong></p>
]]></content>
      <categories>
        <category>Zookeeper</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Zookeeper学习</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式的五种实现方式</title>
    <url>/2020/07/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BA%94%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><p>将设计者的思维融入大家的学习和工作中，更高层次的思考！<br>• 创建型模式：<br>– 单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。</p>
<p>• 结构型模式：<br>– 适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</p>
<p>• 行为型模式：<br>– 模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。</p>
<p><strong>本次文章介绍的是单例模式的五种实现方式</strong>。</p>
<h1 id="单例模式的简介"><a href="#单例模式的简介" class="headerlink" title="单例模式的简介"></a>单例模式的简介</h1><p><strong>• 核心作用：</strong><br>保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。</p>
<p><strong>• 常见应用场景：</strong><br>– Windows的Task Manager（任务管理器）就是很典型的单例模式<br>– windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。<br>– 项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，每次new一个对象去读取。<br>– 网站的计数器，一般也是采用单例模式实现，否则难以同步。<br>– 应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。<br>– 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。<br>– 操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。<br>– Application 也是单例的典型应用（Servlet编程中会涉及到）<br>– 在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理<br>– 在servlet编程中，每个Servlet也是单例<br>– 在spring MVC框架/struts1框架中，控制器对象也是单例</p>
<p><strong>• 单例模式的优点：</strong><br>– 由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，<br>   则可 以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决</p>
<p>– 单例模式可以在系统设置全局的访问点，优化环共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理</p>
<p><strong>• 常见的五种单例模式实现方式：</strong><br>– 主要：<br>        • 饿汉式（线程安全，调用效率高。 但是，不能延时加载。）<br>        • 懒汉式（线程安全，调用效率不高。 但是，可以延时加载。）</p>
<p>– 其他：<br>        • 双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）<br>        • 静态内部类式(线程安全，调用效率高。 但是，可以延时加载)<br>        • 枚举单例(线程安全，调用效率高，不能延时加载)</p>
<h1 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h1><h2 id="实现方式一：饿汉式（单例对象立即加载）"><a href="#实现方式一：饿汉式（单例对象立即加载）" class="headerlink" title="实现方式一：饿汉式（单例对象立即加载）"></a>实现方式一：饿汉式（单例对象立即加载）</h2><p>•  饿汉式单例模式代码中，static变量会在类装载时初始化，此时也不会涉及多个线程对象访问该对象的问题。虚拟机保证只会装载一次该类，肯定不会发生并发访问的问题。因此，可以省略synchronized关键字。<br>•  问题：如果只是加载本类，而不是要调用getInstance()，甚至永远没有调用，则会造成资源浪费！</p>
<p>需要注意的三点：<br>第一点：需要将构造器私有，构造器私有之后别人就访问不了了，只有自己可以用；<br>第二点：提供一个属性，这个属性是static变量，并且是私有的，static变量是类变量，从属于这个类，那么这个类就只有这么一个属性，它就指定了这个对象；<br>第三点：提供一个开放的方法，别人只能从这里取对象。<br>以上三点的描述，详细代码见以下的第一个！！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 测试饿汉式单例模式</span><br><span class="line"> *  --所谓饿汉式，表示的是很饿，上来就把你吃了，相当于当类加载器加载以下类的时候，</span><br><span class="line"> *    加载的时候就把这个对象New出来，初始以下的静态属性，不管你要不要，上来就给建好。</span><br><span class="line"> *    这个就是立即加载。这个就是不好的地方。</span><br><span class="line"> *</span><br><span class="line"> *  --特点：</span><br><span class="line"> *  1.线程安全：方法前不需要加synchronized,因为我们去创建对象时，在类初始化时立刻加载，</span><br><span class="line"> *             在类加载器加载对象时是一个天然的线程安全模式。</span><br><span class="line"> *             不存在创建对象&#x2F;初始化属性多线程不安全的问题，所以天然线程安全。</span><br><span class="line"> *</span><br><span class="line"> *  2.显然不加同步标记的话，效率就高。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonDemo01 &#123;</span><br><span class="line">    &#x2F;&#x2F;类初始化时，立即加载这个对象(没有延时加载的优势)，加载类时，天然的是线程安全的。</span><br><span class="line">    private static SingletonDemo01 instance &#x3D; new SingletonDemo01();</span><br><span class="line"></span><br><span class="line">    private SingletonDemo01()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;方法没有同步，调用效率高</span><br><span class="line">    public static SingletonDemo01 getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现方式二：懒汉式（单例对象延迟加载）"><a href="#实现方式二：懒汉式（单例对象延迟加载）" class="headerlink" title="实现方式二：懒汉式（单例对象延迟加载）"></a>实现方式二：懒汉式（单例对象延迟加载）</h2><p>• 要点：<br>        – lazy load! 延迟加载， 懒加载！ 真正用的时候才加载！</p>
<p>• 问题：<br>        – 资源利用率高了。但是，每次调用getInstance()方法都要同步，并发效率较低。<br>        –调用的效率低。</p>
<p>注意：如果类创建对象时用到的代价很高，那么就使用延时加载，也就是懒汉式；如果类调用效率非常频繁，就用饿汉式。</p>
<p>代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 懒汉式单例模式</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonDemo02 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;类初始化时，不初始化这个对象(实现了延时加载，真正用到的时候才去创建)</span><br><span class="line">    private static SingletonDemo02 instance;</span><br><span class="line"></span><br><span class="line">    private SingletonDemo02()&#123; &#x2F;&#x2F;私有化构造器</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;方法同步，调用效率低</span><br><span class="line">    public static synchronized SingletonDemo02 getInstance()&#123;</span><br><span class="line">        if(instance&#x3D;&#x3D;null)&#123;</span><br><span class="line">            instance &#x3D; new SingletonDemo02();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现方式三：双重检测锁实现（不建议使用）"><a href="#实现方式三：双重检测锁实现（不建议使用）" class="headerlink" title="实现方式三：双重检测锁实现（不建议使用）"></a>实现方式三：双重检测锁实现（不建议使用）</h2><p>• 这个模式将同步内容下方到if内部，提高了执行的效率不必每次获取对象时都进行同步，<br>  只有第一次才同步创建了以后就没必要了。<br>• 问题：由于编译器优化原因和JVM底层内部模型原因，偶尔会出问题。不建议使用。<br>代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 双重检查锁模式</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonDemo06 &#123;</span><br><span class="line"></span><br><span class="line">    private volatile static SingletonDemo06 instance;</span><br><span class="line"></span><br><span class="line">    private SingletonDemo06()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonDemo06 getInstance()&#123;</span><br><span class="line">        &#x2F;&#x2F;先判断对象是否已经实例化过，没有实例化才能进入加锁代码</span><br><span class="line">        if(instance&#x3D;&#x3D;null)&#123;</span><br><span class="line">            &#x2F;&#x2F;对类对象加锁</span><br><span class="line">            synchronized(SingletonDemo06.class)&#123;</span><br><span class="line">                if(instance &#x3D;&#x3D; null)&#123;</span><br><span class="line">                    instance &#x3D; new SingletonDemo06();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现方式四：静态内部类实现方式-懒加载方式"><a href="#实现方式四：静态内部类实现方式-懒加载方式" class="headerlink" title="实现方式四：静态内部类实现方式(懒加载方式)"></a>实现方式四：静态内部类实现方式(懒加载方式)</h2><p><strong>基本思路</strong>：首先是静态内部类，在里面定义单例对象，然后也提供一个方法getInstance()，通过调用静态内部的方法进行访问，构造器私有，这种方式不仅线程安全，还是懒加载模式。</p>
<p>当我们第一次去初始化这个类的时候，并不会立即初始化它的静态内部类，当真正要用的时候，才会通过getInstance()这个方法去调用SingletonClassInstance.instance;从而去加载内部类中的代码，使用时也不存在同步的问题。调用效率也不错，很多开源的都用这个。</p>
<p><strong>• 要点</strong>：<br>– 外部类没有static属性，则不会像饿汉式那样立即加载对象。<br>– 只有真正调用getInstance(),才会加载静态内部类。加载类时是线程安全的。 instance是static final类型，保证了内存中只有这样一个实例存在，而且只能被赋值一次，从而保证了线程安全性.<br>– 兼备了并发高效调用和延迟加载的优势！</p>
<p><strong>优点</strong>：<br>1、线程安全，还是懒加载模式<br>2、调用效率高<br>3、实现了延时加载<br>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 静态内部类实现单例模式</span><br><span class="line"> *</span><br><span class="line"> * 优点：</span><br><span class="line"> * 1、线程安全，还是懒加载模式</span><br><span class="line"> * 2、调用效率高</span><br><span class="line"> * 3、实现了延时加载</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonDemo03 &#123;</span><br><span class="line"></span><br><span class="line">    private static class SingletonClassInstance&#123;</span><br><span class="line">        private static final SingletonDemo03 instance &#x3D; new SingletonDemo03();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonDemo03 getInstance()&#123;</span><br><span class="line">        return SingletonClassInstance.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SingletonDemo03()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现方式五：枚举"><a href="#实现方式五：枚举" class="headerlink" title="实现方式五：枚举"></a>实现方式五：枚举</h2><p>• 优点：<br>        – 实现简单<br>        – 枚举本身就是单例模式。由JVM从根本上提供保障！避免通过反射和反序列化的漏洞！</p>
<p>• 缺点：<br>        – 无延迟加载</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 使用枚举方式实现单例模式</span><br><span class="line"> • 优点：</span><br><span class="line"> – 实现简单</span><br><span class="line"> – 枚举本身就是单例模式。由JVM从根本上提供保障！避免通过反射和反序列化的漏洞！</span><br><span class="line"> *&#x2F;</span><br><span class="line">public enum  SingletonDemo04 &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     *  定义一个枚举元素，它就代表了Singleton的一个实例</span><br><span class="line">     *&#x2F;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     *  单例可以有自己的操作</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void singletonOperation()&#123;</span><br><span class="line">        &#x2F;&#x2F;功能处理</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单例模式总结"><a href="#单例模式总结" class="headerlink" title="单例模式总结"></a>单例模式总结</h1><p><strong>• 常见的五种单例模式实现方式</strong><br>– 主要：<br><strong>• 饿汉式（线程安全，调用效率高。 但是，不能延时加载。）</strong><br><strong>• 懒汉式（线程安全，调用效率不高。 但是，可以延时加载。）</strong><br>– 其他：<br>• 双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）<br><strong>• 静态内部类式(线程安全，调用效率高。 但是，可以延时加载)</strong><br>• 枚举式(线程安全，调用效率高，不能延时加载。并且可以天然的防止反射和反序列化漏洞！)</p>
<p><strong>• 如何选用?</strong><br>– 单例对象 占用 资源 少，不需要 延时加载：<br>        • 枚举式 好于 饿汉式</p>
<p>– 单例对象 占用 资源 大，需要 延时加载：<br>        • 静态内部类式 好于 懒汉式</p>
<p><strong>寄言：</strong><br>学习设计模式时一定要动手去敲代码，再加以理解，尤其是饿汉式和懒汉式，一定要熟悉到自己能够手写出来，因为面试的时候经常会让你手写出来（亲测）。</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之工厂模式的三种实现方式</title>
    <url>/2020/07/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="工厂模式简介"><a href="#工厂模式简介" class="headerlink" title="工厂模式简介"></a>工厂模式简介</h1><p>（1）<strong>工厂模式</strong>：</p>
<ul>
<li>实现了创建者和调用者的分离。</li>
</ul>
<p>（2）<strong>详细分类</strong>：</p>
<ul>
<li><p>简单工厂模式<br>用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）。</p>
</li>
<li><p>工厂方法模式<br>用来生产同一等级结构中的固定产品。（支持增加任意产品）。</p>
</li>
<li><p>抽象工厂模式<br>用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）。</p>
</li>
</ul>
<p>（3）<strong>核心本质</strong>：<br>        – 实例化对象，用工厂方法代替new操作。<br>        – 将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。</p>
<h1 id="面向对象设计的基本原则"><a href="#面向对象设计的基本原则" class="headerlink" title="面向对象设计的基本原则"></a>面向对象设计的基本原则</h1><p>面向对象设计的基本原则，这里介绍以下三种：</p>
<ul>
<li><p><strong>OCP（开闭原则，Open-Closed Principle）</strong>：一个软件的实体应当对扩展开放，对修改关闭。<br><strong>注意</strong>：当要对项目增加新的功能，就增加一个类，而不要在原类上修改。</p>
</li>
<li><p><strong>DIP（依赖倒转原则，Dependence Inversion Principle）</strong>：要针对接口编程，不要针对实现编程。依赖于抽象，不要依赖于具体，<br><strong>注意</strong>：比如说我要调用一个类的时候，这个类实现了一个接口，那么我们就去与接口扯上关系，不要去与实现扯上关系。</p>
</li>
<li><p><strong>LoD（迪米特法则，Law of Demeter）</strong>：只与你直接的朋友通信，而避免和陌生人通信。<br><strong>注意</strong>：以上原则的意思是我这个类尽量少和其他类扯上关系，尽量少依赖其他类，实现解耦。</p>
</li>
</ul>
<h1 id="工厂模式要点"><a href="#工厂模式要点" class="headerlink" title="工厂模式要点"></a>工厂模式要点</h1><ul>
<li><p>简单工厂模式(静态工厂模式)<br>虽然某种程度不符合设计原则，但<strong>实际使用最多</strong>。</p>
</li>
<li><p>工厂方法模式<br>不修改已有类的前提下，通过增加新的工厂类实现扩展。</p>
</li>
<li><p>抽象工厂模式<br>不可以增加产品，可以增加产品族！</p>
</li>
</ul>
<h1 id="工厂模式的应用场景"><a href="#工厂模式的应用场景" class="headerlink" title="工厂模式的应用场景"></a>工厂模式的应用场景</h1><ul>
<li>JDK中Calendar的getInstance方法</li>
<li>JDBC中Connection对象的获取</li>
<li>Hibernate中SessionFactory创建Session</li>
<li>spring中IOC容器创建管理bean对象</li>
<li>XML解析时的DocumentBuilderFactory创建解析器对象</li>
<li>反射中Class对象的newInstance()</li>
</ul>
<h1 id="一、工厂模式的实现方式"><a href="#一、工厂模式的实现方式" class="headerlink" title="一、工厂模式的实现方式"></a>一、工厂模式的实现方式</h1><p><strong>（1）新建一个Car接口</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public interface Car &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（2）新建两个接口的实现类</strong>：<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class Byd implements Car &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;比亚迪在跑。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class Audi implements Car &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;奥迪在跑！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="没有工厂模式的时候"><a href="#没有工厂模式的时候" class="headerlink" title="没有工厂模式的时候"></a>没有工厂模式的时候</h2><p><strong>（3）创建调用者进行测试</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client01 &#123; &#x2F;&#x2F;调用者</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Car c1 &#x3D; new Audi();</span><br><span class="line">        Car c2 &#x3D; new Byd();</span><br><span class="line"></span><br><span class="line">        c1.run();</span><br><span class="line">        c2.run();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）输出：<br><img src="https://img-blog.csdnimg.cn/20200811002742572.png" alt="在这里插入图片描述"><br>（5）UML类图<br><img src="https://img-blog.csdnimg.cn/20200811002832292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（6）问题：</p>
<ul>
<li>Client01相当于调用者，调用者知道的信息太多了，既要知道接口还要知道实体类；</li>
<li>具体类的创建都暴露出来了，如果创建实体类非常复杂，还需要准备很多参数；</li>
</ul>
<h2 id="实现方式一：简单工厂模式（使用较多）"><a href="#实现方式一：简单工厂模式（使用较多）" class="headerlink" title="实现方式一：简单工厂模式（使用较多）"></a>实现方式一：简单工厂模式（使用较多）</h2><p><strong>要点</strong>：</p>
<ul>
<li>简单工厂模式也叫静态工厂模式，就是工厂类一般是使用静态方法，</li>
<li>通过接收的参数的不同来返回不同的对象实例。</li>
<li>对于增加新产品无能为力！不修改代码的话，是无法扩展的。</li>
</ul>
<p><strong>（1）还是使用Car接口和两个实现类Audi和Byd</strong><br><strong>（2）新建一个工厂类（方式一）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 简单工厂模式</span><br><span class="line"> * 缺点：违反了开闭原则</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CarFactory &#123; &#x2F;&#x2F;创建者</span><br><span class="line"></span><br><span class="line">    public static Car createCar(String type)&#123;</span><br><span class="line">        if(&quot;奥迪&quot;.equals(type))&#123;</span><br><span class="line">            return new Audi();</span><br><span class="line">        &#125;else if(&quot;比亚迪&quot;.equals(type))&#123;</span><br><span class="line">            return new Byd();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（3）新建一个工厂类（方式二）更推荐</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public  class CarFactory02 &#123; &#x2F;&#x2F;创建者</span><br><span class="line"></span><br><span class="line">    public static Car createAudi()&#123;</span><br><span class="line">        return new Audi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Car createByd()&#123;</span><br><span class="line">        return new Byd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（4）创建测试代码（调用者）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client02 &#123; &#x2F;&#x2F;调用者</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Car c1 &#x3D; CarFactory.createCar(&quot;奥迪&quot;);</span><br><span class="line">        Car c2 &#x3D; CarFactory.createCar(&quot;比亚迪&quot;);</span><br><span class="line"></span><br><span class="line">        c1.run();</span><br><span class="line">        c2.run();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过新增加了一个工厂类，实现了更加详细的分工，CarFactory类专门用于创建Car接口的实现类实例，相当于创建者，而调用者只需要和创建者打交道就可以了，使用工厂模式使得代码较之前更加容易扩展。<br><strong>（5）简单工厂模式UML类图</strong><br><img src="https://img-blog.csdnimg.cn/20200811003315111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>（6）缺点</strong><br>如果我们还需要新增新的功能，那么还需要再CarFactory类中去修改代码，因此违反了当需要新增一个功能的时候，去新增一个类，而不是去修改源代码这一条开闭原则，因此简单工厂是有这么一个小问题的。</p>
<h2 id="实现方式二：工厂方法模式"><a href="#实现方式二：工厂方法模式" class="headerlink" title="实现方式二：工厂方法模式"></a>实现方式二：工厂方法模式</h2><ul>
<li>为了避免简单工厂模式的缺点，使代码更符合设计原则，现在介绍以下工厂方法模式。</li>
<li>工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个<pre><code> （对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。 </code></pre>
</li>
</ul>
<p><strong>（1）首先还是使用Car接口还有两个实现类Audi、Byd进行测试。</strong><br><strong>（2）创建一个CarFactory接口</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface CarFactory &#123;</span><br><span class="line">    Car createCar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（3）新建一个AudiFactory类，去实现CarFactory接口</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AudiFactory implements CarFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Car createCar() &#123;</span><br><span class="line">        return new Audi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（4）新建一个BydFactory类，去实现CarFactory接口</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class BydFactory implements CarFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Car createCar() &#123;</span><br><span class="line">        return new Byd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（5）编写调用者</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Car c1 &#x3D; new BydFactory().createCar();</span><br><span class="line">        Car c2 &#x3D; new AudiFactory().createCar();</span><br><span class="line"></span><br><span class="line">        c1.run();</span><br><span class="line">        c2.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="https://img-blog.csdnimg.cn/20200811003639715.png" alt="在这里插入图片描述"><br>现在如果需要新增一个新的功能，只需要新增一个车的类和这个车的工厂类就可以了，不需要修改业务代码，解决了简单工厂模式的缺点，符合了开闭原则，但是缺点就是新增的类会比较多。</p>
<p><strong>（6）工厂方法模式UML类图</strong><br><img src="https://img-blog.csdnimg.cn/20200811003736278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>（7）总结</strong><br>根据UML类图可以知道，我们的调用者如果需要创建某个车的实例，只需要调用相应的工厂类就行了，调用者就直接和工厂打交道，而不会和子类打交道，虽然说满足了开闭原则，但是变得更加复杂了，所以还是使用简单工厂模式比较多。</p>
<h2 id="实现方式三：抽象工厂模式（多个接口）"><a href="#实现方式三：抽象工厂模式（多个接口）" class="headerlink" title="实现方式三：抽象工厂模式（多个接口）"></a>实现方式三：抽象工厂模式（多个接口）</h2><p>当一个产品需要创建多个接口的情况下，简单工厂模式和工厂方法模式就无能无力了，这个时候就使用抽象方法模式。</p>
<ul>
<li>用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）</li>
<li>抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时，</li>
<li>通过抽象工厂模式产生需要的对象是一种非常好的解决方式。<br><img src="https://img-blog.csdnimg.cn/20200811101756658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>现在通过代码来实现上图中的产品概念。<br>代码：<br><strong>（1）首先新建一个Engine接口，发动机接口，在解决中有run()和start()两个方法。</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public interface Engine &#123;</span><br><span class="line">    void run(); &#x2F;&#x2F;发动机的运行</span><br><span class="line">       void start(); &#x2F;&#x2F;发动机的启动</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>（2）编写一个高级发动机LuxuryEngine类，并且实现发动机接口。</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class LuxuryEngine implements Engine&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;转得快..&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;启动快..可以自动启停&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>（3）编写一个低级发动机LowEngine类，并且实现发动机接口。</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class LowEngine implements Engine&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;转得慢..&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;启动慢..&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>（4）新增一个座椅接口Seat，并且编写一个按摩方法。</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public interface Seat &#123;</span><br><span class="line">    void massage(); &#x2F;&#x2F;按摩方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>（5）编写一个高端座椅LuxurySeat类，并且实现座椅接口</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class LuxurySeat implements Seat&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void massage() &#123;</span><br><span class="line">        System.out.println(&quot;高端按摩椅--可以自动按摩。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>（6）编写一个低端座椅LowSeat类，并且实现座椅接口</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class LowSeat implements Seat&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void massage() &#123;</span><br><span class="line">        System.out.println(&quot;低端按摩椅--不可以按摩。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>（7）新增一个轮胎接口Tyre，并且编写一个revolve方法。</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public interface Tyre &#123;</span><br><span class="line">    void revolve();&#x2F;&#x2F;转速</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>（8）编写一个高端座椅LuxuryTyre类，并且实现轮胎接口</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class LuxuryTyre implements Tyre&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void revolve() &#123;</span><br><span class="line">        System.out.println(&quot;高端轮胎——————旋转磨损小。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>（9）编写一个低端座椅LowTyre类，并且实现轮胎接口</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class LowTyre implements Tyre&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void revolve() &#123;</span><br><span class="line">        System.out.println(&quot;低端轮胎——————旋转磨损大。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>（10）新建一个CarFactory工厂接口，并且里面有创建发动机、座椅、轮胎的方法。</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public interface CarFactory &#123;</span><br><span class="line">    Engine createEngine();&#x2F;&#x2F;创建发动机的方法</span><br><span class="line">    Seat createSeat();&#x2F;&#x2F;创建座椅的方法</span><br><span class="line">    Tyre createTyre();&#x2F;&#x2F;创建轮胎的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>（11）编写一个创建高端汽车的方法LuxuryCarFactory，并且实现CarFactory接口</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class LuxuryCarFactory implements CarFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Engine createEngine() &#123;</span><br><span class="line">        return new LuxuryEngine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Seat createSeat() &#123;</span><br><span class="line">        return new LuxurySeat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Tyre createTyre() &#123;</span><br><span class="line">        return new LuxuryTyre();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>（12）再创建一个低端汽车工厂方法LowCarFactory，并且实现CarFactory接口</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class LowCarFactory implements CarFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Engine createEngine() &#123;</span><br><span class="line">        return new LowEngine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Seat createSeat() &#123;</span><br><span class="line">        return new LowSeat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Tyre createTyre() &#123;</span><br><span class="line">        return new LowTyre();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>（13）编写调用者测试</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CarFactory carFactory &#x3D; new LuxuryCarFactory();</span><br><span class="line">        Engine e &#x3D; carFactory.createEngine();</span><br><span class="line">        e.run();</span><br><span class="line">        e.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出：<br><img src="https://img-blog.csdnimg.cn/20200811102106816.png" alt="在这里插入图片描述"><br><strong>（14）UML类图</strong><br><img src="https://img-blog.csdnimg.cn/20200811102126509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>测试代码中的调用者，去创建了一个高端汽车，并且各个组件之间可以搭配组合，这样就实现了产品族的概念，实际生活中使用抽象工厂模式比较少，但是在一些开源的产品项目中可能遇见的比较多，这里理解这个思想即可。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="简单工厂模式和工厂方法模式PK"><a href="#简单工厂模式和工厂方法模式PK" class="headerlink" title="简单工厂模式和工厂方法模式PK:"></a>简单工厂模式和工厂方法模式PK:</h2><ul>
<li><p><strong>结构复杂度</strong></p>
<pre><code> 从这个角度比较，显然**简单工厂模式要占优**。简单工厂模式只需一个工厂类，而工厂方法模式的工厂类随着产品类个数增加而增加，这无疑会使类的个数越来越多，从而增加了结构的复杂程度。</code></pre>
</li>
<li><p><strong>代码复杂度</strong></p>
<pre><code> 代码复杂度和结构复杂度是一对矛盾，既然简单工厂模式在结构方面相对简洁，那么它在代码方面肯定是比工厂方法模式复杂的了。简单工厂模式的工厂类随着产品类的增加需要增加很多方法（或代码），而工厂方法模式每个具体工厂类只完成单一任务，代码简洁。</code></pre>
</li>
<li><p><strong>客户端编程难度</strong></p>
<pre><code> 工厂方法模式虽然在工厂类结构中引入了接口从而满足了OCP，但是在客户端编码中需要对工厂类进行实例化。而简单工厂模式的工厂类是个静态类，在客户端无需实例化，这无疑是个吸引人的优点。</code></pre>
</li>
<li><p><strong>管理上的难度</strong></p>
<pre><code> 这是个关键的问题。</code></pre>
<p>我们先谈扩展。众所周知，工厂方法模式完全满足OCP，即它有非常良好的扩展性。那是否就说明了简单工厂模式就没有扩展性呢？答案是否定的。简单工厂模式同样具备良好的扩展性——扩展的时候仅需要修改少量的代码（修改工厂类的代码）就可以满足扩展性的要求了。尽管这没有完全满足OCP，但我们不需要太拘泥于设计理论，要知道，sun提供的java官方工具包中也有想到多没有满足OCP的例子啊。然后我们从维护性的角度分析下。假如某个具体产品类需要进行一定的修改，很可能需要修改对应的工厂类。当同时需要修改多个产品类的时候，对工厂类的修改会变得相当麻烦（对号入座已经是个问题了）。反而简单工厂没有这些麻烦，当多个产品类需要修改是，简单工厂模式仍然仅仅需要修改唯一的工厂类（无论怎样都能改到满足要求吧？大不了把这个类重写）。</p>
</li>
<li><p>工厂模式一般会和其他设计模式搭配使用。</p>
</li>
<li><p>如果以后遇见后缀是factory结尾的，基本上是使用工厂模式来设计的。</p>
</li>
<li><p>根据设计理论建议：工厂方法模式。但实际上，<strong>我们一般都用简单工厂模式。</strong></p>
</li>
</ul>
<p><strong>学习工厂模式时，多去手动敲代码是必不可少的，同时多去画一下UML类图以理解它们之间的关系，同时锻炼自己的能力。</strong></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个SpringBoot程序以及启动图标设置</title>
    <url>/2020/09/08/%E7%AC%AC%E4%B8%80%E4%B8%AASpringBoot%E7%A8%8B%E5%BA%8F%E4%BB%A5%E5%8F%8A%E5%B0%8F%E5%BD%A9%E8%9B%8B/</url>
    <content><![CDATA[<h2 id="SpringBoot的简介"><a href="#SpringBoot的简介" class="headerlink" title="SpringBoot的简介"></a>SpringBoot的简介</h2><p>Spring Boot 是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简化是指简化了 Spring 众多框架中所需的大量且繁琐的配置文件，所以 Spring Boot 是一个服务于框架的框架，服务范围是简化配置文件。所以从本质上来说，Spring Boot 其实就是 Spring<br>框架的另一种表现形式。</p>
<h2 id="Spring-Boot-的特征"><a href="#Spring-Boot-的特征" class="headerlink" title="Spring Boot 的特征"></a>Spring Boot 的特征</h2><ul>
<li>使用 Spring Boot 可以创建独立的 Spring 应用程序</li>
<li>在Spring Boot中直接嵌入了Tomcat、Jetty、Undertow等Web容器，所以在使用SpringBoot做 Web 开 发时不需要部署 WAR 文件</li>
<li>通过提供自己的启动器(Starter)依赖，简化项目构建配置</li>
<li>尽量的自动配置 Spring 和第三方库</li>
<li>提供了生产就绪特征，如：度量指标，运行状况检查和外部化配置</li>
<li>绝对没有代码生成，也不需要 XML 配置文件</li>
</ul>
<h2 id="Spring-Boot-的版本介绍"><a href="#Spring-Boot-的版本介绍" class="headerlink" title="Spring Boot 的版本介绍"></a>Spring Boot 的版本介绍</h2><p>SNAPSHOT：快照版，即开发版。<br>CURRENT：最新版，但是不一定是稳定版。<br>GA：GeneralAvailability，正式发布的版本。</p>
<h2 id="使用脚手架创建第一个SpringBoot项目"><a href="#使用脚手架创建第一个SpringBoot项目" class="headerlink" title="使用脚手架创建第一个SpringBoot项目"></a>使用脚手架创建第一个SpringBoot项目</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们将学习如何快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>
<p>我的电脑环境为：JDK1.8、Maven3.5.4、SpringBoot2.3.x（最新版）</p>
<p>开发工具：IDEA</p>
<h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>打开IDEA，创建一个新项目，以下使用图片说明：<br><img src="https://img-blog.csdnimg.cn/20200911200058428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200911200109888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200911200118962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="pom文件分析"><a href="#pom文件分析" class="headerlink" title="pom文件分析"></a>pom文件分析</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">	<span class="comment">&lt;!--父依赖--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--web启动器--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--SpringBoot的单元测试--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--剔除依赖--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--打包插件--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在父依赖spring-boot-starter-parent中提供了非常多的Maven依赖以及配置，关于配置可以点进spring-boot-starter-parent中进行查看，里面包含了资源拷贝插件等等配置，不仅如此，里面还提供了大量的Maven依赖，详情可以点进行spring-boot-starter-parent下的spring-boot-dependencies去查看。</p>
<p>下面我们开始编写我们第一个SpringBoot程序。</p>
<h2 id="编写一个http接口"><a href="#编写一个http接口" class="headerlink" title="编写一个http接口"></a>编写一个http接口</h2><p>1、在主程序的同级目录下，新建一个controller包，一定要在同级目录下，否则识别不到<br><img src="https://img-blog.csdnimg.cn/20200911200139593.png" alt="在这里插入图片描述"><br>2、在包中新建一个HelloController类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello My First SpringBoot Code !!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回；控制台输出了 Tomcat 访问的端口号！<br><img src="https://img-blog.csdnimg.cn/20200911200349222.png" alt="在这里插入图片描述"><br>简单几步，就完成了一个web接口的开发，SpringBoot就是这么简单。所以我们常用它来建立我们的微服务项目！</p>
<h2 id="更改启动图标"><a href="#更改启动图标" class="headerlink" title="更改启动图标"></a>更改启动图标</h2><p>如何更改启动时显示的字符拼成的字母呢？<br>其实那是banner图案，要实现自定义的图案，只需要进行一步操作：到项目下的 resources 目录下新建一个banner.txt 即可。</p>
<p>图案的话可以到：<a href="https://www.bootschool.net/ascii">https://www.bootschool.net/ascii</a> 这个网站生成，然后拷贝到文件中即可！</p>
<p><img src="https://img-blog.csdnimg.cn/20200911200752645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础常见面试题</title>
    <url>/2020/07/20/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="1、JDK和JRE有什么区别？"><a href="#1、JDK和JRE有什么区别？" class="headerlink" title="1、JDK和JRE有什么区别？"></a>1、JDK和JRE有什么区别？</h1><p>JDK就是Java Development Kit 。JDK是面向开发人员使用的SDK，它提供了Java的开发环境和运行环境。SDK是Software Development Kit 一般指软件开发包，可以包括函数库、编译程序等。</p>
<p>JRE是Java Runtime Enviroment是指Java的运行环境，是面向Java程序的使用者，而不是开发者。</p>
<h1 id="2、-和-equals-的区别是什么？"><a href="#2、-和-equals-的区别是什么？" class="headerlink" title="2、== 和 equals 的区别是什么？"></a>2、== 和 equals 的区别是什么？</h1><p>（1）== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。<br>(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)</p>
<p>（2）equals() : 它的作用也是判断两个对象是否相等。<br>但它一般有两种使用情况：<br>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</p>
<p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p>
<h1 id="3、两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#3、两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="3、两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？"></a>3、两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</h1><p>如果两个对象相等，则hashcode一定也是相同的</p>
<p>两个对象相等，对两个对象分别调用equals方法都返回true</p>
<p>两个对象有相同的hashcode值，它们也不一定是相等的</p>
<p>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</p>
<p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
<h1 id="4、final-在-java-中有什么作用？"><a href="#4、final-在-java-中有什么作用？" class="headerlink" title="4、final 在 java 中有什么作用？"></a>4、final 在 java 中有什么作用？</h1><p>用于修饰类、属性和方法；</p>
<p>被final修饰的类不可以被继承<br>被final修饰的方法不可以被重写<br>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</p>
<h1 id="5、java-中的-Math-round-1-5-等于多少？-Math-round-1-5-等于多少？"><a href="#5、java-中的-Math-round-1-5-等于多少？-Math-round-1-5-等于多少？" class="headerlink" title="5、java 中的 Math.round(1.5) 等于多少？ Math.round(-1.5) 等于多少？"></a>5、java 中的 Math.round(1.5) 等于多少？ Math.round(-1.5) 等于多少？</h1><p>Math.round(1.5)等于2，Math.round(-1.5)等于-1，四舍五入是在原来的基础上加上0.5向下取整。</p>
<h1 id="6、说出以下代码的输出结果。"><a href="#6、说出以下代码的输出结果。" class="headerlink" title="6、说出以下代码的输出结果。"></a>6、说出以下代码的输出结果。</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class A &#123;</span><br><span class="line">   static&#123;</span><br><span class="line">      System.out.println(&quot;static in class A&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public A()&#123;</span><br><span class="line">      System.out.println(&quot;class A&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class SubA extends A &#123;</span><br><span class="line">   static &#123;</span><br><span class="line">      System.out.println(&quot;static in class SubA&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public SubA() &#123;</span><br><span class="line">      super();</span><br><span class="line">      System.out.println(&quot;class SubA&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public SubA(String sa) &#123;</span><br><span class="line">      System.out.println(&quot;class SubA &quot; + sa);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class StaticTest &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      SubA subA1 &#x3D; new SubA(&quot;111111&quot;);</span><br><span class="line">      SubA subA2 &#x3D; new SubA(&quot;222222&quot;);</span><br><span class="line">      SubA subA3 &#x3D; new SubA(&quot;333333&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出结果为：</span><br><span class="line"> static in class A</span><br><span class="line">static in class SubA</span><br><span class="line">class A</span><br><span class="line">class SubA 111111</span><br><span class="line">class A</span><br><span class="line">class SubA 222222</span><br><span class="line">class A</span><br><span class="line">class SubA 333333</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong><br>子类构造方法调用规则：<br>（1）如果子类的构造方法中没有通过 super 显式调用父类的有参构造方法，<br>        也没有通过 this 显式调用自身的其他构造方法，则系统会默认先调用父类的无参构造方法。<br>        这种情况下，写不写 super(); 语句，效果是一样的<br>（2）如果子类的构造方法中通过 super 显式调用父类的有参构造方法，<br>         将执行父类相应的构造方法，不执行父类无参构造方法<br>（3）如果子类的构造方法中通过 this 显式调用自身的其他构造方法，将执行类中相应的构造方法<br>（4）如果存在多级继承关系，在创建一个子类对象时，以上规则会多次向更高一级父类应用，<br>         一直到执行顶级父类 Object 类的无参构造方法为止<br><strong>结论：</strong><br>类的实例化方法调用顺序：<br>类加载器实例化时进行的操作步骤：加载 -&gt; 连接 -&gt; 初始化<br>（1）父类静态代变量<br>（2）父类静态代码块<br>（3）子类静态变量<br>（4）子类静态代码块<br>（5）父类非静态变量（父类实例成员变量）<br>（6）父类构造函数<br>（7）子类非静态变量（子类实例成员变量）<br>（8）子类构造函数</p>
<h1 id="7、Java中，基本的数据类型有哪些？"><a href="#7、Java中，基本的数据类型有哪些？" class="headerlink" title="7、Java中，基本的数据类型有哪些？"></a>7、Java中，基本的数据类型有哪些？</h1><p>基本数据类型有byte、short、int、long、float、double、char、boolean八种基本数据类型。<br>byte：1个字节，8位<br>short：2个字节，16位<br>int：4个字节，32位<br>long：8个字节，64位<br>float：4个字节，32位<br>double：8个字节，64位<br>boolean：逻辑上理解是占用 1位，但是实际中会考虑计算机高效存储因素<br>char：2个字节，16位</p>
<h1 id="8、String-属于基础的数据类型吗？"><a href="#8、String-属于基础的数据类型吗？" class="headerlink" title="8、String 属于基础的数据类型吗？"></a>8、String 属于基础的数据类型吗？</h1><p>不属于，Java中基本数据类型只有byte、short、int、long、float、double、char、boolean八种数据类型。<br>String在Java中属于对象，底层实现是char数组，使用final修饰。</p>
<h1 id="9、switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上？"><a href="#9、switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上？" class="headerlink" title="9、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？"></a>9、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？</h1><p>在Java5以前，switch(expr)中的expr只能是byte、char、short、int四种数据类型。从Java5以后引入了枚举，expr可以是enum类型，Java7开始，expr就可以支持String字符串了，但是目前还不能使用long类型的。</p>
<h1 id="10、java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#10、java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="10、java 中操作字符串都有哪些类？它们之间有什么区别？"></a>10、java 中操作字符串都有哪些类？它们之间有什么区别？</h1><p>Java中操作字符串的类有String、StringBuffer、StringBuilder三个类。<br><strong>三者的相同点：</strong><br>（1）都可以存储和操作字符串；<br>（2）底层都使用了final修饰，不能被继承。<br>（3）提供了API相似。<br><strong>三者的区别：</strong><br>（1）String是不可变字符序列，String内容是不能被改变的；<br>（2）StringBuffer和StringBuilder是可变字符序列，他们都可以对字符串内容进行修改，<br>   并且修改之后的内存地址不会发生改变；<br>（3）StringBuilder是JDK1.5的，效率高，但是它的线程不安全，<br>          StringBuffer是JDK1.0的，效率低，但是它是线程安全的(方法加了Synchronized)。</p>
<p><strong>对于三者使用的总结</strong></p>
<p>如果要操作少量的数据用 = String</p>
<p>单线程操作字符串缓冲区 下操作大量数据 = StringBuilder</p>
<p>多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</p>
<h1 id="11、String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#11、String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="11、String str=”i”与 String str=new String(“i”)一样吗？"></a>11、String str=”i”与 String str=new String(“i”)一样吗？</h1><p>不一样，因为内存的分配方式不一样，String str = “i”的方式，Java虚拟机会将其分配到常量池中；而String str = new String(“i”) 则会被分配到堆内存中。</p>
<p>提问：String s = new String(“abc”)创建了几个对象呢？<br>答案是两个对象，一个是静态区的”abc”，另外一个是用new创建在堆上的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str1 &#x3D; &quot;hello&quot;; &#x2F;&#x2F;str1指向静态区</span><br><span class="line">String str2 &#x3D; new String(&quot;hello&quot;);  &#x2F;&#x2F;str2指向堆上的对象</span><br><span class="line">String str3 &#x3D; &quot;hello&quot;;</span><br><span class="line">String str4 &#x3D; new String(&quot;hello&quot;);</span><br><span class="line">System.out.println(str1.equals(str2)); &#x2F;&#x2F;true</span><br><span class="line">System.out.println(str2.equals(str4)); &#x2F;&#x2F;true</span><br><span class="line">System.out.println(str1 &#x3D;&#x3D; str3); &#x2F;&#x2F;true</span><br><span class="line">System.out.println(str1 &#x3D;&#x3D; str2); &#x2F;&#x2F;false</span><br><span class="line">System.out.println(str2 &#x3D;&#x3D; str4); &#x2F;&#x2F;false</span><br><span class="line">System.out.println(str2 &#x3D;&#x3D; &quot;hello&quot;); &#x2F;&#x2F;false</span><br><span class="line">str2 &#x3D; str1;</span><br><span class="line">System.out.println(str2 &#x3D;&#x3D; &quot;hello&quot;); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
<h1 id="13、如何将字符串反转？"><a href="#13、如何将字符串反转？" class="headerlink" title="13、如何将字符串反转？"></a>13、如何将字符串反转？</h1><p>使用StringBuffer或者StringBuilder中的reverse()方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; StringBuffer reverse</span><br><span class="line"> StringBuffer stringBuffer &#x3D; new StringBuffer();</span><br><span class="line"> stringBuffer. append(&quot;abcdefg&quot;);</span><br><span class="line"> System. out. println(stringBuffer. reverse()); &#x2F;&#x2F; gfedcba</span><br><span class="line">&#x2F;&#x2F; StringBuilder reverse</span><br><span class="line"> StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line"> stringBuilder. append(&quot;abcdefg&quot;);</span><br><span class="line"> System. out. println(stringBuilder. reverse()); &#x2F;&#x2F; gfedcba</span><br></pre></td></tr></table></figure>
<h1 id="14、String-类的常用方法都有那些？"><a href="#14、String-类的常用方法都有那些？" class="headerlink" title="14、String 类的常用方法都有那些？"></a>14、String 类的常用方法都有那些？</h1><p>（1）String 类的常用方法都有那些？<br>（2）indexOf()：返回指定字符的索引。<br>（3）charAt()：返回指定索引处的字符。<br>（4）replace()：字符串替换。<br>（5）trim()：去除字符串两端空白。<br>（6）split()：分割字符串，返回一个分割后的字符串数组。<br>（7）getBytes()：返回字符串的 byte 类型数组。<br>（8）length()：返回字符串长度。<br>（9）toLowerCase()：将字符串转成小写字母。<br>（10）toUpperCase()：将字符串转成大写字符。<br>（11）substring()：截取字符串。<br>（12）equals()：字符串比较。</p>
<h1 id="15、HashMap中使用String做key有什么好处？"><a href="#15、HashMap中使用String做key有什么好处？" class="headerlink" title="15、HashMap中使用String做key有什么好处？"></a>15、HashMap中使用String做key有什么好处？</h1><pre><code>    HashMap内部实现是通过key的hashcode来确定value的存储位置，因为字符串是不可变的，并且使用字符串时会在字符串常量池中进行缓存，所以当创建字符串的时候，hashcode会被缓存下来，不需要再次计算，所以相比于其他对象来说快一些。</code></pre>
<h1 id="16、抽象类必须要有抽象方法吗？"><a href="#16、抽象类必须要有抽象方法吗？" class="headerlink" title="16、抽象类必须要有抽象方法吗？"></a>16、抽象类必须要有抽象方法吗？</h1><p>抽象类不一定要有抽象方法，但是抽象方法必要要有抽象类。</p>
<h1 id="17、普通类和抽象类有哪些区别？"><a href="#17、普通类和抽象类有哪些区别？" class="headerlink" title="17、普通类和抽象类有哪些区别？"></a>17、普通类和抽象类有哪些区别？</h1><p>（1）抽象类不能被实例化；<br>（2）抽象类可以有抽象方法，但是普通类没有；<br>（3）含有抽象方法的类必须是抽象类；<br>（4）抽象方法不能被声明为静态；<br>（5）抽象方法不能被private；<br>（6）抽象方法不能被final修饰。</p>
<h1 id="18、抽象类能使用-final-修饰吗？"><a href="#18、抽象类能使用-final-修饰吗？" class="headerlink" title="18、抽象类能使用 final 修饰吗？"></a>18、抽象类能使用 final 修饰吗？</h1><p>不能，因为被final修饰的类不能被继承，而定义抽象类就是为了让其他类去继承的，如果使用final修饰了就矛盾了，因此不能被final修饰。</p>
<h1 id="19、接口和抽象类有什么区别？"><a href="#19、接口和抽象类有什么区别？" class="headerlink" title="19、接口和抽象类有什么区别？"></a>19、接口和抽象类有什么区别？</h1><p>（1）实现：抽象类的子类使用extends来继承，而接口就必须使用implements来实现接口；<br>（2）构造函数：抽象类可以有构造函数，但是接口没有；<br>（3）实现数量：类可以实现很多个接口，但是只能继承一个抽象类；<br>（4）访问修饰符：接口的方法默认使用的是public修饰，而抽象类中的方法可以是任意访问修饰符；</p>
<h1 id="20、内部类有哪几种？详细说明一下。"><a href="#20、内部类有哪几种？详细说明一下。" class="headerlink" title="20、内部类有哪几种？详细说明一下。"></a>20、内部类有哪几种？详细说明一下。</h1><p>内部类的定义：可以将一个类的定义放在另外一个类的定义内部；<br>内部类的种类：成员内部类、局部内部类、匿名内部类、静态内部类。</p>
<p>（1）静态内部类：定义在类内部的静态类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line"></span><br><span class="line">   private static int radius &#x3D; 1;</span><br><span class="line"></span><br><span class="line">   static class StaticInner &#123;</span><br><span class="line">      public void visit() &#123;</span><br><span class="line">         System.out.println(&quot;visit outer static  variable:&quot; + radius);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，new 外部类.静态内部类()，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Outer.StaticInner inner &#x3D; new Outer.StaticInner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure>
<p>（2）成员内部类：定义在类内部，成员位置上的非静态类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class Outer &#123;</span><br><span class="line"></span><br><span class="line">   private static  int radius &#x3D; 1;</span><br><span class="line">   private int count &#x3D;2;</span><br><span class="line"></span><br><span class="line">   class Inner &#123;</span><br><span class="line">      public void visit() &#123;</span><br><span class="line">         System.out.println(&quot;visit outer static  variable:&quot; + radius);</span><br><span class="line">         System.out.println(&quot;visit outer   variable:&quot; + count);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式外部类实例.new 内部类()，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Outer outer &#x3D; new Outer();</span><br><span class="line">Outer.Inner inner &#x3D; outer.new Inner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure>
<p>（3）局部内部类：定义在方法的内部，就是局部内部类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class Outer &#123;</span><br><span class="line"></span><br><span class="line">   private  int out_a &#x3D; 1;</span><br><span class="line">   private static int STATIC_b &#x3D; 2;</span><br><span class="line"></span><br><span class="line">   public void testFunctionClass()&#123;</span><br><span class="line">      int inner_c &#x3D;3;</span><br><span class="line">      class Inner &#123;</span><br><span class="line">         private void fun()&#123;</span><br><span class="line">            System.out.println(out_a);</span><br><span class="line">            System.out.println(STATIC_b);</span><br><span class="line">            System.out.println(inner_c);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Inner  inner &#x3D; new Inner();</span><br><span class="line">      inner.fun();</span><br><span class="line">   &#125;</span><br><span class="line">   public static void testStaticFunctionClass()&#123;</span><br><span class="line">      int d &#x3D;3;</span><br><span class="line">      class Inner &#123;</span><br><span class="line">         private void fun()&#123;</span><br><span class="line">            &#x2F;&#x2F; System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量</span><br><span class="line">            System.out.println(STATIC_b);</span><br><span class="line">            System.out.println(d);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Inner  inner &#x3D; new Inner();</span><br><span class="line">      inner.fun();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，new 内部类()，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public static void testStaticFunctionClass()&#123;</span><br><span class="line">   class Inner &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   Inner  inner &#x3D; new Inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）匿名内部类：没有名字的内部类，日常开发中使用的比较多。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class Outer &#123;</span><br><span class="line"></span><br><span class="line">   private void test(final int i) &#123;</span><br><span class="line">      new Service() &#123;</span><br><span class="line">         public void method() &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">               System.out.println(&quot;匿名内部类&quot; );</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;.method();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;匿名内部类必须继承或实现一个已有的接口 </span><br><span class="line">interface Service&#123;</span><br><span class="line">   void method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了没有名字，<strong>匿名内部类还有以下特点：</strong><br>A、匿名内部类必须继承一个抽象类或者实现一个接口。<br>B、匿名内部类不能定义任何静态成员和静态方法。<br>C、当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。<br>D、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">匿名内部类创建方式：</span><br><span class="line"> new 类&#x2F;接口&#123;</span><br><span class="line">      &#x2F;&#x2F;匿名内部类实现部分</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h1 id="21、内部类有哪些使用场景？你在哪些地方使用到了内部类？"><a href="#21、内部类有哪些使用场景？你在哪些地方使用到了内部类？" class="headerlink" title="21、内部类有哪些使用场景？你在哪些地方使用到了内部类？"></a>21、内部类有哪些使用场景？你在哪些地方使用到了内部类？</h1><p>（1）在设计模式中使用静态内部类实现单例模式；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SingletonDemo03 &#123;</span><br><span class="line"></span><br><span class="line">    private static class SingletonClassInstance&#123;</span><br><span class="line">        private static final SingletonDemo03 instance &#x3D; new SingletonDemo03();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonDemo03 getInstance()&#123;</span><br><span class="line">        return SingletonClassInstance.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SingletonDemo03()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）其他的忘记了，，，等记得来的时候再补上0.0</p>
<h1 id="22、Files的常用方法都有哪些？"><a href="#22、Files的常用方法都有哪些？" class="headerlink" title="22、Files的常用方法都有哪些？"></a>22、Files的常用方法都有哪些？</h1><p>（1）Files. exists()：检测文件路径是否存在。<br>（2）Files. createFile()：创建文件。<br>（3）Files. createDirectory()：创建文件夹。<br>（4）Files. delete()：删除一个文件或目录。<br>（5）Files. copy()：复制文件。<br>（6）Files. move()：移动文件。<br>（7）Files. size()：查看文件个数。<br>（8）Files. read()：读取文件。<br>（9）Files. write()：写入文件。</p>
<h1 id="23、Date类常用方法都有哪些？"><a href="#23、Date类常用方法都有哪些？" class="headerlink" title="23、Date类常用方法都有哪些？"></a>23、Date类常用方法都有哪些？</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----日期类型如何格式化？</span><br><span class="line">      ***************************************************************************************</span><br><span class="line">      DateFormat  sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line">      String s &#x3D; sdf.format(new Date());&#x2F;&#x2F;日期转字符串</span><br><span class="line">      ***************************************************************************************</span><br><span class="line">      -----字符串如何转日期？</span><br><span class="line">      ***************************************************************************************</span><br><span class="line">      DateFormat  sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line">      String s &#x3D; &quot;2019-10-31 22:53:10&quot;;</span><br><span class="line">      Date date &#x3D; sdf.parse(s);</span><br><span class="line">      ***************************************************************************************</span><br><span class="line">      -----如何取得当前年、月、日、时、分、秒、毫秒？</span><br><span class="line">      年：Calendar.getInstance().get(Calendar.YEAR)；</span><br><span class="line">      或者Year.now()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line">      还有LocalDate.now().getYear();&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line"></span><br><span class="line">      月：Calendar.getInstance().get(Calendar.MONTH)+1；</span><br><span class="line">      MonthDay.now().getMonthValue()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line">      LocalDate.now().getMonthValue()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line"></span><br><span class="line">      日：Calendar.getInstance().get(Calendar.DAY_OF_MONTH)；</span><br><span class="line">      MonthDay.now().getDayOfMonth()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line">      LocalDate.now().getDayOfMonth()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line"></span><br><span class="line">      时：Calendar.getInstance().get(Calendar.HOUR_OF_DAY)；</span><br><span class="line">      LocalTime.now().getHour()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line"></span><br><span class="line">      分：Calendar.getInstance().get(Calendar.MINUTE)；</span><br><span class="line">      LocalTime.now().getMinute()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line"></span><br><span class="line">      秒：Calendar.getInstance().get(Calendar.SECOND)；</span><br><span class="line">      LocalTime.now().getSecond()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line"></span><br><span class="line">      毫秒：Calendar.getInstance().get(Calendar.MILLISECOND)；</span><br><span class="line">      ***************************************************************************************</span><br><span class="line">--如何取得从1970年1月1日0时0分0秒到现在的毫秒数？</span><br><span class="line">      System.currentTimeMillis();</span><br><span class="line">      Calendar.getInstance().getTimeInMillis();</span><br><span class="line">--如何格式化日期？</span><br><span class="line">      new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date())；</span><br><span class="line">      &#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line">      LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;))；</span><br></pre></td></tr></table></figure>


<h1 id="24、java-中-IO-流分为几种？"><a href="#24、java-中-IO-流分为几种？" class="headerlink" title="24、java 中 IO 流分为几种？"></a>24、java 中 IO 流分为几种？</h1><p>（1）按照流向可以分为输入流和输出流；<br>（2）按照操作单元划分可以分为字节流和字符流；<br>（3）按照流的角色划分可分为节点流和处理流；</p>
<h1 id="25、BIO、NIO、AIO-有什么区别？"><a href="#25、BIO、NIO、AIO-有什么区别？" class="headerlink" title="25、BIO、NIO、AIO 有什么区别？"></a>25、BIO、NIO、AIO 有什么区别？</h1><p><strong>简答：</strong></p>
<p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>
<p><strong>详细回答：</strong></p>
<p>BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p>
<p>NIO (New I/O): NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。</p>
<p>AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。</p>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring常见面试题</title>
    <url>/2020/07/12/Spring%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="1、Spring是什么？"><a href="#1、Spring是什么？" class="headerlink" title="1、Spring是什么？"></a>1、Spring是什么？</h1><p> Sprin是一个轻量级的IOC和AOP容器框架，它能够解决企业级应用开发的业务逻辑层和其他各层之间的耦合问题，简化企业级应用程序开发的复杂性，即简化Java开发。<br> Spring有两个核心特性分别是：IOC(控制反转)和AOP(面向切面编程)。</p>
<h1 id="2、使用Spring有什么优点？解释一下为什么要使用Spring？"><a href="#2、使用Spring有什么优点？解释一下为什么要使用Spring？" class="headerlink" title="2、使用Spring有什么优点？解释一下为什么要使用Spring？"></a>2、使用Spring有什么优点？解释一下为什么要使用Spring？</h1><p>（1）方便解耦，简化开发<br>                Spring就像是一个大工厂，可以将所有对象的创建和依赖关系的维护都交给Spring管理，从而减低组件的耦合性；<br>（2）AOP编程的支持<br>                Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控、扩展程序功能等等；<br>（3）声明式事务的支持<br>                只需要通过配置就可以完成对事务的管理，无需手动编程；<br>（4）方便程序的测试<br>                Spring对Junit4的支持，可以通过注解方便的测试Spring程序；<br>（5）方便集成各种优秀的框架</p>
<h1 id="3、Spring有哪些主要模块？"><a href="#3、Spring有哪些主要模块？" class="headerlink" title="3、Spring有哪些主要模块？"></a>3、Spring有哪些主要模块？</h1><p>（1）Spring Core ：框架最基础的部分，提供IOC容器，对bean进行管理；</p>
<p>（2）Spring Context：基于bean，提供上下文对象，扩展出JNDI、EJB、电子邮件、校验调度等功能。</p>
<p>（3）Spring DAO：提供了JDBC的抽象层，它可以消除冗(rong)长的JDBC编码和解析数据库厂商特有的错误代码，还提供了声明式事务管理方法。</p>
<p>（4）Spring ORM：提供了常用的“对象/关系”映射APIs的集成。其中包括JPA、JDO、Mybatis等。</p>
<p>（5）Spring AOP：提供了符合AOP Alliance规范的面向切面的编程实现。</p>
<p>（6）Spring Web：提供了基础的Web开发的上下文信息，可与其他web进行集成。</p>
<p>（7）Spring Web MVC：提供了Web应用的Model-View-Controller全功能的实现。</p>
<h1 id="4、介绍一下SpringIOC，使用IOC有什么好处？"><a href="#4、介绍一下SpringIOC，使用IOC有什么好处？" class="headerlink" title="4、介绍一下SpringIOC，使用IOC有什么好处？"></a>4、介绍一下SpringIOC，使用IOC有什么好处？</h1><p>IOC，Inversion of Control（控制反转），它是一种设计思想，就是将你设计好的对象交给容器控制，而不是自己去创建。把创建和查找依赖对象的控制权交给IOC容器，由IOC容器进行注入、组合对象。</p>
<p> 优点：实现了对象与对象之间的松耦合、便于测试、功能可复用，减少了对象的创建和内存的消耗，使得程序的整体结构变得更方便维护、灵活性更高、扩展性更强。</p>
<p>大白话解释：<br>IOC就是控制反转，就是让一个对象的创建不用自己去new了，使用Spring之后对象可以自动的产生，这其实就是利用了java中的反射，反射其实就是在运行时动态的去创建、调用对象，Spring就是在运行的时候，在Spring的配置文件，也就是XML文件中来动态的创建对象和调用对象中的方法。</p>
<p>ioc的思想最核心的地方在于，资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处。<br>第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。</p>
<p>举例子说：<br>比如甲方需要一双袜子，而乙方它卖一双袜子，它要把袜子卖出去，但是乙方要告诉别人我要卖一双袜子。甲乙双方进行交易活动，但是他们都不需要自己直接去找卖家，相当于程序内部开放接口，卖家由第三方作为参数传入。甲乙互相不依赖，而且只有在进行交易活动的时候，甲才和乙产生联系。反之亦然。这样做什么好处么呢，甲乙可以在对方不真实存在的情况下独立存在，而且保证不交易时候无联系，想交易的时候可以很容易的产生联系。甲乙交易活动不需要双方见面，避免了双方的互不信任造成交易失败的问题。因为交易由第三方来负责联系，而且甲乙都认为第三方可靠。那么交易就能很可靠很灵活的产生和进行了。</p>
<h1 id="5、SpringIOC创建对象的方式有哪些？"><a href="#5、SpringIOC创建对象的方式有哪些？" class="headerlink" title="5、SpringIOC创建对象的方式有哪些？"></a>5、SpringIOC创建对象的方式有哪些？</h1><p>（1）通过无参构造器创建对象；<br>（2）通过有参构造器创建对象；<br>（3）通过工厂模式创建对象。</p>
<h1 id="6、SpringIOC的三种注入方式分别是什么？"><a href="#6、SpringIOC的三种注入方式分别是什么？" class="headerlink" title="6、SpringIOC的三种注入方式分别是什么？"></a>6、SpringIOC的三种注入方式分别是什么？</h1><p>（1）通过构造器注入；<br>（2）通过set方法注入；<br>（3）通过注解自动注入；</p>
<h1 id="7、介绍一下Spring-AOP。"><a href="#7、介绍一下Spring-AOP。" class="headerlink" title="7、介绍一下Spring AOP。"></a>7、介绍一下Spring AOP。</h1><p> AOP全名为Aspect Oriented Programming，面向切面编程。<br>作为面向对象的一种补充，用于将那些与业务无关，但是却对多个对象产生影响的公共行为和逻辑，抽取并封装成一个可重用的模块，这个模块被命名为切面（Aspect），减少了系统的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p>
<p>SpringAOP实现的关键在于代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表就是AspectJ；动态代理则以SpringAOP为代表。</p>
<h1 id="8、Spring-AOP中的几个名词解释。"><a href="#8、Spring-AOP中的几个名词解释。" class="headerlink" title="8、Spring AOP中的几个名词解释。"></a>8、Spring AOP中的几个名词解释。</h1><p>（1）切面（Aspect）：切面其实就是切点和通知的结合。切点和通知共同定义了切面中的内容，在SpringAOP中切面可以使用通用类(基于模板风格)或者是在普通类中使用@AspectJ注解来实现。</p>
<p>（2）连接点（Join point）：指的是方法，在SpringAOP中一个连接点总是代表着一个方法的执行。</p>
<p>（3）通知（Advice）：在切面上某个连接点上执行的动作，通俗的说就是我们需要扩展的功能代码，通知又分为前置通知（before）、后置通知（after）、环绕通知（around）、异常通知等。</p>
<p>（4）切入点（Pointcut）：指的是我们需要对哪些连接点进行拦截，通过切入点表达式可以指定拦截的方法。</p>
<p>（5）引入（Introduction）：引入允许我们想现有类添加新方法或者属性；</p>
<p>（6）目标对象（Target Object）：被一个或者多个切面所通知的对象。通常为一个代理对象。</p>
<p>（7）织入（Weaving）：织入就是把切面应用到目标对象并创建新的代理对象的过程，Spring在运行时完成织入。</p>
<h1 id="9、介绍一下SpringAOP的动态代理模式。"><a href="#9、介绍一下SpringAOP的动态代理模式。" class="headerlink" title="9、介绍一下SpringAOP的动态代理模式。"></a>9、介绍一下SpringAOP的动态代理模式。</h1><p> SpringAOP的动态代理模式主要有两种，分别是JDK动态代理和CGLIB动态代理。<br>（1）JDK动态代理只提供接口的代理，不支持类代理。核心为InvocationHandler接口和Proxy类，InvocationHandler接口通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务逻辑编织在一起，接着Proxy就利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。</p>
<p>（2）CGLIB动态代理，代理类没有实现InvocationHandler接口，它是一个代码生成的类库，可以在运行时动态地生产指定类的一个子类对象，并且覆盖其中特定方法来增强代码，从而实现代理；CGLIB是通过继承的方式做的动态代理，如果某个类被标记为final，那么它就无法使用CGLIB做动态代理的。</p>
<p>静态代理和动态代理的区别在于生成代理对象的时机不一样，相对来说静态代理AspectJ的静态代理方式具有更好的性能。</p>
<h1 id="10、Spring的bean是什么？它是线程安全的吗？"><a href="#10、Spring的bean是什么？它是线程安全的吗？" class="headerlink" title="10、Spring的bean是什么？它是线程安全的吗？"></a>10、Spring的bean是什么？它是线程安全的吗？</h1><p>Spring bean是那些形成Spring应用主干的Java对象，它们被SpringIOC容器初始化、装配和管理，这些beans通过在容器中配置的元数据创建。<br>        默认的Spring容器中的bean是单例的，当单例中存在竞争条件时，会有线程安全问题。<br>        Spring管理的bean的线程安全跟bean的创建作用域和bean所在的使用环境是否存在竞争有关，Spring并不能保证bean的线程安全。</p>
<h1 id="11、Spring支持几种bean的作用域？"><a href="#11、Spring支持几种bean的作用域？" class="headerlink" title="11、Spring支持几种bean的作用域？"></a>11、Spring支持几种bean的作用域？</h1><p>（1）Singleton：单例模式，在整个SpringIOC容器中，使用singleton定义的bean只有一个实例；</p>
<p>（2）prototype：原型模式，每次通过容器的getbean方式获取prototype定义的bean时，都产生了一个新的bean实例。</p>
<p>只有在Web应用中使用Spring时，request、session、global-session作用域才会生效。<br>（3）request：对于每次HTTP请求，使用request定义的bean都将产生一个新实例，即每次HTTP请求将会产生不同的bean实例。</p>
<p>（4）session：同一个Session共享一个bean实例。</p>
<p>（5）global-session：同session作用域不同的是，所有的Session共享一个Bean实例。</p>
<h1 id="12、Spring自动装配bean有哪些方式？"><a href="#12、Spring自动装配bean有哪些方式？" class="headerlink" title="12、Spring自动装配bean有哪些方式？"></a>12、Spring自动装配bean有哪些方式？</h1><p>（1）no方式，默认的方式，不自动装配，需要使用到<ref/>节点或者参数；</p>
<p>（2）byName：根据bean的名称进行装配；</p>
<p>（3）byType：通过参数的数据类型进行装配；</p>
<p>（4）constructor：根据构造函数进行装配。</p>
<p>（5）Spring配置文件中<bean>节点的Autowire参数可以控制bean自动装配的方式。</p>
<h1 id="13、介绍一下Spring支持的事务管理类型？"><a href="#13、介绍一下Spring支持的事务管理类型？" class="headerlink" title="13、介绍一下Spring支持的事务管理类型？"></a>13、介绍一下Spring支持的事务管理类型？</h1><p>   Spring支持两种两种事物管理，一种是编程式事务管理，另外一种是声明式事务管理。<br>（1）编程式事务管理：指的是通过编码方式实现事务，允许用户在代码中精确定义事务的边界。即类似于JDBC编程实现事务管理。</p>
<p>（2）声明式事务管理：管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。</p>
<p>声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中。</p>
<p>声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式，使业务代码不受污染，只要加上注解就可以获得完全的事务支持。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p>
<h1 id="14、介绍一下Spring的事务隔离级别？（重点）"><a href="#14、介绍一下Spring的事务隔离级别？（重点）" class="headerlink" title="14、介绍一下Spring的事务隔离级别？（重点）"></a>14、介绍一下Spring的事务隔离级别？（重点）</h1><p>   Spring有五大事务隔离级别，其中Spring默认的事务隔离级别为：ISOLATION_DEFAULT（使用的是数据库的设置），其他的四个事务隔离级别和数据库的隔离级别一致。<br><strong>（1）ISOLATION_DEFAULT</strong>：用的底层数据库的设置隔离级别，数据库设置的是什么就用什么。</p>
<p><strong>（2）ISOLATION_READ_UNCOMMITTED</strong>：未提交读，最低的事务隔离级别，事务未提交前就可以被其他事务读取，会出现幻读、脏读，不可重复读。</p>
<p><strong>（3）ISOLATION_READ_COMMITTED</strong> ：已提交读，一个事务提交后才能被其他事务读取到（可能会造成幻读、不可重复读），SQL Server的默认级别（Oracle的默认隔离级别）。</p>
<p><strong>（4）ISOLATION_REPEATABLE_READ</strong>：可重复读，保证多次读取同一个数据时，其值都和事务开始的时候的内容一致，禁止读取到别的事务未提交的数据（可能会造成幻读），这是MYSQL的默认隔离级别。</p>
<p><strong>（5）ISOLATION_SERIALIZABLE</strong>：序列化，代价最高的但是最可靠的隔离级别，该级别能够防止脏读、不可重复读、幻读。</p>
<p><strong>脏读</strong>：表示一个事务能够读取另一个事务未提交的数据；<br><strong>幻读</strong>：指的是同一个事务多次查询返回的结果集不一样。<br><strong>不可重复读</strong>：指的是在一个事务中多次读取同一个数据。</p>
<h1 id="15、介绍一下关于事务的四个特性（ACID）"><a href="#15、介绍一下关于事务的四个特性（ACID）" class="headerlink" title="15、介绍一下关于事务的四个特性（ACID）"></a>15、介绍一下关于事务的四个特性（ACID）</h1><p>事务有四个特性（ACID），分别是原子性、一致性、隔离性、持久性。<br><strong>（1）原子性（Atomicity）</strong>：事务是一个原子操作，由一系列动作组成。事务的原子性能够确保动作（增、删、改）要么全部完成，要么不起作用。</p>
<p><strong>（2）一致性（Consistency）</strong>：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败，在现实中的数据不应该被破坏。</p>
<p><strong>（3）隔离性（Isolation）</strong>：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，以此防止数据损坏。</p>
<p><strong>（4）持久性（Durability）</strong>：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下事务的结果被写到持久化存储器中。</p>
<h1 id="16、Spring的事务传播行为介绍"><a href="#16、Spring的事务传播行为介绍" class="headerlink" title="16、Spring的事务传播行为介绍"></a>16、Spring的事务传播行为介绍</h1><p>Spring的事务传播行为说的是当多个事务同时存在的时候，Spring是如何处理这些事务的行为的。<br><strong>（1）PROPAGATION_REQUIRED</strong>：如果当前没有事务就创建一个新的事务，如果当前存在事务就加入该事务，该设置是最常用的设置，同时也是默认值；</p>
<p><strong>（2）PROPAGATION_SUPPORTS</strong>：支持当前事务，如果当前存在事务就加入当前事务，如果当前不存在事务就以非事务执行；</p>
<p>（3）PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务就加入该事务，如果当前不存在事务就抛出异常；</p>
<p>（4）PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务都创建新事务；</p>
<p>（5）PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起；</p>
<p>（6）PROPAGATION_NEVER：以非事务的方式执行，如果当前存在事务，则抛出异常；</p>
<p>（7）PROPAGATION_NESTED：如果当前存在事务，则嵌套事务内执行，如果当前没有事务就按REQUIRED属性执行。</p>
<h1 id="17、Spring的注解介绍"><a href="#17、Spring的注解介绍" class="headerlink" title="17、Spring的注解介绍"></a>17、Spring的注解介绍</h1><p>Spring常见的注解及其作用：<br><strong>（1）@Conponent</strong>：创建类对象，相当于配置<bean/>，bean的ID默认为类名首字母小写，同时也可以指定ID，例如@Conponent(“stu”)；</p>
<p><strong>（2）@Service</strong>：作用和@Conponent一样，创建类对象，但是它是作用在业务层实现类上；</p>
<p><strong>（3）@Repository</strong>：作用和@Conponent一样，也是创建类对象，但是它是作用在数据访问层上；</p>
<p><strong>（4）@Controller</strong>：作用和@Conponent一样，创建类对象，作用在控制器类上；</p>
<p><strong>（5）@Resource</strong>：使用了这个注解之后就不需要写对象的get/set方法了，它是Java的注解，默认是按照byName方式注入，如果没有名称对象就按照byType注入，使用这个注解的时候建议把对象名称写成和Spring容器中对象名一致。</p>
<p><strong>（6）@Autowired</strong>：自动注入，使用了这个注解同样不需要写对象的get、set方法了，它是Spring的注解，同样也是最常用的注解之一，默认是按照byType进行注入。</p>
<p>（7）@Value()：这个注解是获取properties配置文件中的内容。</p>
<p><strong>（8）@RequestMapping</strong>：此注解用于将特定的HTTP请求映射到将处理相应请求的控制器中的特定类/方法。此注解可应用于两个级别：<br>        A、类级别：映射请求的URL；<br>        B、方法级别：映射URL以及HTTP请求方法。</p>
<p><strong>（9）@Configuration</strong>：该注解用于定义配置类，可替换xml配置文件，被该注解标注的类内部包含一个或者多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，从而初始化Spring容器。<br>@Configuration标注在类上，相当于把该类作为spring的xml配置文件中的<beans>，作用为：配置spring容器(应用上下文)。</p>
<h1 id="18、-Autowired-、-Inject、-Resource-之间有什么区别？"><a href="#18、-Autowired-、-Inject、-Resource-之间有什么区别？" class="headerlink" title="18、 @Autowired 、 @Inject、@Resource 之间有什么区别？"></a>18、 @Autowired 、 @Inject、@Resource 之间有什么区别？</h1><p>（1）@Autowired是Spring提供的注解，而@Inject和@Resource是java规范的；<br>（2）@Autowired和@Inject基本是一样的，都是使用AutowiredAnnotationBeanPostProcessor来处理依赖注入，但是@Resouece是个例外，它是由CommonAnnotationBeanPostProcessor来处理依赖注入的；<br>（3）@Autowired是spring实现的，@Inject是jsr330实现的，@Resouece是jsr250实现的。</p>
<h1 id="19、-Configuration-如何嵌套？-Configuration-使用上有哪些约束？"><a href="#19、-Configuration-如何嵌套？-Configuration-使用上有哪些约束？" class="headerlink" title="19、@Configuration 如何嵌套？@Configuration 使用上有哪些约束？"></a>19、@Configuration 如何嵌套？@Configuration 使用上有哪些约束？</h1><p>@Configuration注解作用在类上，就和普通类一样能够进行相互嵌套，定义内部类就可以进行相互嵌套。<br>这个注解的使用约束如下所示：<br>（1）必须以类的方式提供（而不是从工厂方法返回的实例）；<br>（2）被@Configuration注解的类必须是非final的；<br>（3）任何嵌套的@Configuration都必须是static的；<br>（4）@Bean方法可能不会反过来创建更多配置类；<br>（5）配置类必须是本地的（可能不在方法中声明），native标注的方法。</p>
<h1 id="20、Spring项目怎么进行单元测试？"><a href="#20、Spring项目怎么进行单元测试？" class="headerlink" title="20、Spring项目怎么进行单元测试？"></a>20、Spring项目怎么进行单元测试？</h1><p>首先加载Spring的jar包，Spring-test-4.0.4-RELEASE.jar和commons-logging-1.2.jar<br>然后再applicationContext.xml中扫描service实现包，<br>&lt;context:component-scan base-package=”service.impl”&gt;</context:component-scan><br>之后在UserServiceImpl实现类上使用springmvc 注解@Service(“userService”)<br>编写spring单元测试，点击运行。<br><img src="https://img-blog.csdnimg.cn/20200717224221927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>@RunWith(SpringJUnit4ClassRunner.class) 上面已做介绍。<br>@ContextConfiguration(locations={“classpath:applicationContext.xml”})加载配置文件，locations参数是一个数组，可以加载多个，配置文件。<br>@Resource 自动注入Ioc容器的对应的bean。<br>@Test 我们的测试方法。</p>
<h1 id="21、Spring-框架中都用到了哪些设计模式？"><a href="#21、Spring-框架中都用到了哪些设计模式？" class="headerlink" title="21、Spring 框架中都用到了哪些设计模式？"></a>21、Spring 框架中都用到了哪些设计模式？</h1><p>（1）工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</p>
<p>（2）单例模式：Bean默认为单例模式。</p>
<p>（3）代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</p>
<p>（4）模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</p>
<p>（5）观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，<br>                 所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</p>
<h1 id="22、Spring如何处理线程并发问题？"><a href="#22、Spring如何处理线程并发问题？" class="headerlink" title="22、Spring如何处理线程并发问题？"></a>22、Spring如何处理线程并发问题？</h1><p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，<br>在Spring中，绝大部分Bean都可以声明为singleton作用域，<br>因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p>
<h1 id="23、Spring项目是如何启动的？"><a href="#23、Spring项目是如何启动的？" class="headerlink" title="23、Spring项目是如何启动的？"></a>23、Spring项目是如何启动的？</h1><p><img src="https://img-blog.csdnimg.cn/2020071816102833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如上图所示，Spring项目在启动时，首先会去读取应用程序提供的Bean配置信息，并且会在Spring容器中生成一份对应的Bean配置注册表，然后根据这张注册表实例化Bean，装配好Bean之间的依赖关系，为上层应用提供准备就绪的运行环境。</p>
<p>关于图中步骤的详细说明：<br>第一步：<strong>读取Bean的配置信息</strong>，对于Bean的配置有很多种方式，比如说可以在Spring的XML文件当中使用<bean/>标签声明一个bean，除此之外还可以在Java的类当中使用@Configuration注解来标识它是一个配置类，还可以通过@Autowired注解来完成一个对象的注入配置，这些信息肯定是要Spring去读取的；</p>
<p>第二步：Spring启动读到Bean配置文件解析出来的信息之后，会将读取到的需要注册的Bean加到Spring容器中（就是IOC容器），在里面会形成一个Bean定义的注册表，然后Spring会根据注册表里面的信息将Bean对象进行实例化，把配置的Bean都要做一次实例化，在实例化的过程中完成依赖注入。</p>
<p>第三步：之后便是将已经实例化的Bean对象放回Spring的容器当中，放到Bean的缓存池里，当我们应用程序需要用到这个Bean的时候，就会调用getBean方法去缓存池中调用。其实都是去的Spring容器中的Bean缓存池里去取的Bean对象。</p>
<h1 id="目前尚未理解的问题有以下："><a href="#目前尚未理解的问题有以下：" class="headerlink" title="目前尚未理解的问题有以下："></a>目前尚未理解的问题有以下：</h1><p>24、Spring如何对Bean进行延迟初始化？<br>25、@Profile有什么用？<br>26、Spring是如何处理带@Configuration @Import的类？<br>27、@Configuration和XML有什么区别？哪种好？</p>
<p>返回首页：<a href="https://oldou.github.io/">点击此处</a></p>
<p><strong>你现在的每一刻努力，都有可能是未来的你在向你求救。</strong></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Spring学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的数据类型（5种基础，3种特殊）</title>
    <url>/2020/08/16/Redis%E7%9A%84%E4%BA%94%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。<br>它支持多种类型的数据结构，如 <strong>字符串（strings），散列（hashes）， 列表（lists），集合（sets），有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询</strong>。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</p>
<p><a href="https://redis.io/">Redis的英文官网</a><br><a href="http://www.redis.cn/">Redis的中文官网</a><br><a href="https://www.redis.net.cn/order/">Redis的中文命令手册</a></p>
<p><strong>本文主要介绍Redis五种常用的数据类型、三种特殊的数据类型的使用、应用场景。</strong></p>
<h1 id="Redis五种基本数据类型"><a href="#Redis五种基本数据类型" class="headerlink" title="Redis五种基本数据类型"></a>Redis五种基本数据类型</h1><h2 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h2><p> Redis 字符串是字节序列。Redis 字符串是二进制安全的，这意味着他们有一个已知的长度没有任何特殊字符终止，所以你可以存储任何东西，512 M为上限，主要的还是操作键值对。<br> String的数据结构是简单的Key-Value模型，Value可以是字符串，也可以是数字。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><strong>添加元素（SET命令）</strong></li>
</ul>
<p><strong>格式：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set key value [expiration EX seconds|PX milliseconds] [NX|XX]</span><br><span class="line"></span><br><span class="line">ex:秒级过期时间,nx:键不存在时才能设置成功,xx键存在时才能设置成功</span><br></pre></td></tr></table></figure>
<p><strong>(1)普通添加：</strong><code>set key value</code><br><img src="https://img-blog.csdnimg.cn/20200816200125801.png" alt="在这里插入图片描述"><br><strong>(2)设置过期时间  setex：</strong><code>setex key seconds value</code><br><img src="https://img-blog.csdnimg.cn/20200816200630140.png" alt="在这里插入图片描述"><br>上图中：设置一个键为key1，值为hello，并且30秒后过期。<br>使用<code>ttl命令</code>可以查看该键还有多少时间过期。</p>
<p><strong>(3)不存在设置  setnx（set if not exist）</strong>：<code>setnx key value </code><br>如果key不存在，则创建一个key，如果key存在，则创建失败并返回0。<br><img src="https://img-blog.csdnimg.cn/20200816201210597.png" alt="在这里插入图片描述"><br>上图中，执行第一条命令时，由于key2不存在，所以就创建一个key2，执行第二句命令时，由于key2前面已经创建了，已经存在了，所以就创建失败，并且返回0。</p>
<p><strong>setnx在分布式锁中经常使用到</strong></p>
<hr>
<ul>
<li><strong>获取值 （GET命令）</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name oldou</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name   #获取name中的值</span><br><span class="line">&quot;oldou&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ul>
<li><strong>mset/mget命令</strong><br>同时设置/获取一个或者多个键值对，主要就是批量设置和获取键值对。<br><img src="https://img-blog.csdnimg.cn/20200816203054986.png#pic_center" alt="在这里插入图片描述"></li>
</ul>
<hr>
<ul>
<li><p><strong>msetnx  key1 value1 key2 value2……</strong><br>同时设置多个值，如果其中有一个存在，那么就都创建失败。<br>要么一起成功，要么一起失败，这是一个<strong>原子性操作</strong>。</p>
</li>
<li><p><strong>incr命令</strong><br>让当前键值以 1 的数量递增，并返回递增后的值。相当于Java中的自增，每次使用改命令都能让变量自增1。<br><img src="https://img-blog.csdnimg.cn/20200816201914606.png" alt="在这里插入图片描述"><br><strong>应用场景：（一般可用于设置浏览量、阅读量）</strong></p>
</li>
</ul>
<hr>
<ul>
<li><strong>incrby命令</strong><br>可以指定参数一次增加的数值，并返回递增后的值，(原来的num是2，加10之后变为12)<br><img src="https://img-blog.csdnimg.cn/20200816202214633.png" alt="在这里插入图片描述"></li>
</ul>
<hr>
<ul>
<li><strong>decr命令</strong><br>可以指定参数一次递减的数值，并返回递减后的值，每次使用该命令都自减1，相当于Java中的自减。<br><img src="https://img-blog.csdnimg.cn/20200816202652893.png#pic_center" alt="在这里插入图片描述"></li>
</ul>
<hr>
<ul>
<li><strong>decrby</strong><br>可以指定参数一次递减的数值，并返回递减后的值<br><img src="https://img-blog.csdnimg.cn/20200816202829704.png#pic_center" alt="在这里插入图片描述"></li>
</ul>
<hr>
<ul>
<li><strong>append命令</strong><br>向键值的末尾追加 value。如果键不存在则将该键的值设置为 value。<br>返回值是追加后字符串的总长度。<br><img src="https://img-blog.csdnimg.cn/2020081620325564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<hr>
<ul>
<li><strong>strlen命令</strong> ：获取字符串长度<br><img src="https://img-blog.csdnimg.cn/20200816203413601.png#pic_center" alt="在这里插入图片描述"></li>
</ul>
<hr>
<ul>
<li><strong>getrange命令：</strong>截去指定索引的字符串<br><img src="https://img-blog.csdnimg.cn/20200816203532497.png#pic_center" alt="在这里插入图片描述"></li>
</ul>
<hr>
<ul>
<li><strong>setrange命令</strong>：从指定索引开始替换字符串<br><img src="https://img-blog.csdnimg.cn/2020081620365839.png#pic_center" alt="在这里插入图片描述"><br>以上表示从索引为0开始的元素替换为QQQQQ</li>
</ul>
<hr>
<ul>
<li><strong>del命令</strong>： 根据key删除一个或者多个元素<br><img src="https://img-blog.csdnimg.cn/20200816203836916.png" alt="在这里插入图片描述"></li>
</ul>
<hr>
<ul>
<li>设置对象<br><code>set user:1 &#123;name:zhangsan,age:3&#125;</code><br>设置一个user:1对象，值为json字符串来保存一个对象。<br>这是一个巧妙的设计：<code>user:&#123;id&#125;:&#123;field&#125;  </code>  如此设置在Redis中是完全OK的。<br><img src="https://img-blog.csdnimg.cn/20200816204120592.png#pic_center" alt="在这里插入图片描述"></li>
</ul>
<hr>
<ul>
<li><strong>getset命令</strong>：先get然后再set<br>如果设置的键不存在值，则设置值，并且返回nil<br>如果设置的键存在值，则返回该值，并设置新的值<br><img src="https://img-blog.csdnimg.cn/20200816204212552.png" alt="在这里插入图片描述"><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3></li>
<li>计数器—点赞,视频播放量,每播放一次就+1</li>
<li>统计多单位的数量</li>
<li>粉丝数</li>
<li>对象缓存存储</li>
</ul>
<h2 id="Hash散列表"><a href="#Hash散列表" class="headerlink" title="Hash散列表"></a>Hash散列表</h2><p><img src="https://img-blog.csdnimg.cn/20200816204651889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Redis 的哈希是键值对的集合。<br>Redis 的哈希值是字符串字段和字符串值之间的映射，因此它们被用来表示对象，还有用户信息之类的，经常变动的信息。<br>Hash更适合用于对象的存储，String更适合字符串存储。</p>
<hr>
<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>（1）<code>hset命令</code>：存储一个哈希键值对的集合<br>格式为：hset key field value  —–表示的是在key的field下设置一个为“value”的值。<ul>
<li>（2）<code>hget命令</code>：获取一个哈希键的值<br>格式为：hget key field<br><img src="https://img-blog.csdnimg.cn/20200816204924830.png" alt="在这里插入图片描述"></li>
<li>（3）<code>hmset</code>： 存储一个或多个哈希是键值对的集合<br>格式为：hmset key field1 value1 ……fieldN keyN</li>
<li>（4）<code>hmget</code>： 获取多个指定的键的值<br>格式为：hmget key field1 … fieldN<br><img src="https://img-blog.csdnimg.cn/2020081620514726.png#pic_center" alt="在这里插入图片描述"></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>(5)<code>hexists</code>： 判断哈希表中的字段名是否存在 如果存在返回 1 否则返回 0<br>格式为：hexists key field<br><img src="https://img-blog.csdnimg.cn/20200816205235529.png" alt="在这里插入图片描述"></li>
<li>（6）<code>hdel</code>： 删除一个或多个字段<br>格式为：hdel key field<br> <img src="https://img-blog.csdnimg.cn/20200816205335351.png" alt="在这里插入图片描述"></li>
<li>（7）<code>hgetall</code>： 获取一个哈希是键值对的集合<br>格式为：hgetall key<br><img src="https://img-blog.csdnimg.cn/20200816205425227.png" alt="在这里插入图片描述"></li>
<li>（8）<code>hvals</code>： 只返回字段值<br>格式为：hvals key<br><img src="https://img-blog.csdnimg.cn/20200816205506650.png" alt="在这里插入图片描述"></li>
<li>（9）<code>hkeys</code>： 只返回字段名<br>格式为：hkeys key<br><img src="https://img-blog.csdnimg.cn/20200816205542342.png" alt="在这里插入图片描述"></li>
<li>（10）<code>hlen</code>： 返回 key 的 hash 的元素个数<br>格式为：hlen key<img src="https://img-blog.csdnimg.cn/20200816205631341.png" alt="在这里插入图片描述"><br>这里是因为user下有两个属性 username和userage</li>
</ul>
<hr>
<ul>
<li>（11）<code>hincrby key field value </code>:   指定增量value<br><img src="https://img-blog.csdnimg.cn/20200816205746174.png" alt="在这里插入图片描述"></li>
<li>（12）<code>hsetnx  key field value </code>:  如果该键不存在就创建，如果该键存在就创建失败。<br><img src="https://img-blog.csdnimg.cn/2020081620581427.png" alt="在这里插入图片描述"><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><strong>主要用于存储部分变更数据，比如存储用户信息等等</strong></li>
</ul>
<h2 id="List链表"><a href="#List链表" class="headerlink" title="List链表"></a>List链表</h2><p><img src="https://img-blog.csdnimg.cn/2020081621010277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Redis 的链表是简单的字符串列表，排序插入顺序。您可以添加元素到 Redis 的列表的头部或尾部<br>Lpush：表示的是向链表的左添加，也就是向链表的头添加；<br>Rpush：表示的是向链表的右添加，也就是向链表的尾添加；</p>
<h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><p>（1）<code>lpush key value</code>： 向链表左侧添加—头插法<br><img src="https://img-blog.csdnimg.cn/2020081621031829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>（2）<code>rpush key value</code>： 向链表右侧添加–尾插法<br><img src="https://img-blog.csdnimg.cn/20200816210446796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>（3）<code>lpop key</code>： 从左边移出一个元素，就是从最左边的那个节点剔除掉。<br><img src="https://img-blog.csdnimg.cn/20200816210638241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>（4）<code>rpop key</code>： 从右边移出一个元素，就是从最右边的那个节点剔除掉。<br><img src="https://img-blog.csdnimg.cn/20200816210836153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>（5）<code>lrange key start end lrange</code>: 命令将返回索引从 start 到 stop 之间的所有元素。Redis 的列表起始索引为 0。<br>如果是要获取全部的元素：<code>lrange key 0 -1</code></p>
</li>
<li><p>（6）<code>llen key</code>： 返回链表中元素的个数 相当于关系型数据库中 select count(*)<br><img src="https://img-blog.csdnimg.cn/20200816211138885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>（7）<code>lindex key indexnumber</code> :lindex 命令用来返回指定索引的元素，索引从 0 开始，如果是负数表示从右边开始计算的索引，最右边元素的索引是-1。如果要将列表类型当做数组来用，lindex 命令是必不可少的。<br><img src="https://img-blog.csdnimg.cn/20200816211420456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>（8）<code>lset key indexnumber value</code>： 是另一个通过索引操作列表的命令，它会将索引为 index的元素赋值为 value，原来的值会被覆盖。如果该列表不存在就会报错。所以使用这个命令之前先使用exists判断一下。<br><img src="https://img-blog.csdnimg.cn/20200816211506993.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>（9）<code>lrem key count value  </code>:  移除key链表中count个元素的value值，精确匹配，如果链表中可以有多个重复的值，这里的count指的是可以删除多个相同key的值。<br><img src="https://img-blog.csdnimg.cn/20200816211653807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>（10）<code>ltrim  list  startIndex   endIndex </code> ：通过下标截取指定的长度，这个时候list已经改变了，只剩下截断的元素。<br><img src="https://img-blog.csdnimg.cn/20200816211748816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>（11）<code>rpoplpush  source  destination</code> ：移除当前的source链表中的最后一个元素，并且将该元素移动到destination链表当中。<br><img src="https://img-blog.csdnimg.cn/20200816211829334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>（12）<code>linsert key BEFORE|AFTER pivot value</code>：在key列表的pivot元素的前/后面插入元素value。<br><img src="https://img-blog.csdnimg.cn/20200816211910252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>小结：</p>
</li>
<li><p>实际上list是一个链表，before  node  after，left ，right都可以插入值；</p>
</li>
<li><p>如果key不存在，就创建新的链表；</p>
</li>
<li><p>如果key存在就创建新的值；</p>
</li>
<li><p>如果移除了所有的值，空链表，也就代表不存在；</p>
</li>
<li><p>在两边插入或者改动值，效率最高，中间元素相对来说效率会低一点。</p>
</li>
</ul>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>消息队列：利用List的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作List中某一段的api，你可以直接查询，删除List中某一段的元素。</li>
<li>消息排队，消息队列（Lpush、Rpop）、栈（Lpush、Lpop）</li>
<li>使用list可以构建队列系统，使用sorted set甚至可以构建有优先级的队列系统。<h2 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set( 集合)"></a>Set( 集合)</h2><img src="https://img-blog.csdnimg.cn/20200816212031712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Redis 的集合是字符串的无序集合。<br>在Set集合当中，是不允许有重复的。<br>set是通过hash table实现的，可以进行添加、删除和查找。对集合我们可以取并集，交集，差集.<h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>（1）<code>sadd key value</code>：添加一个 string 元素到,key 对应的 set 集合中， 成功返回 1,如果元素已经在集合中返回 0<br><img src="https://img-blog.csdnimg.cn/2020081621224418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
</li>
<li>（2）<code>scard key</code>： 返回 set 的元素个数，如果 set 是空或者 key 不存在返回 0<br><img src="https://img-blog.csdnimg.cn/20200816212314774.png" alt="在这里插入图片描述"><ul>
<li>（3）<code>smembers key</code>： 返回 key 对应 set 的所有元素，结果是无序的<br><img src="https://img-blog.csdnimg.cn/2020081621235251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
</li>
<li>（4）<code>sismember key value</code>： 判断 value 是否在 set 中，存在返回 1，0 表示不存在或者 key 不存在<br><img src="https://img-blog.csdnimg.cn/20200816212426599.png" alt="在这里插入图片描述"></li>
<li>（5）<code>srem key value</code>： 从 key 对应 set 中移除给定元素，成功返回 1，如果 value 在集合中不存在或者 key 不存在返回 0<br><img src="https://img-blog.csdnimg.cn/20200816212505417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>（6）<code>srandmember  key  nums </code>    :   从key集合中随机抽取nums个元素。<br><img src="https://img-blog.csdnimg.cn/20200816212547394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>（7）<code>spop key </code>：随机删除一些key集合中的元素。<br><img src="https://img-blog.csdnimg.cn/20200816212620863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>（8）<code>smove source destination member </code> ：将原集合source中的member元素移动到destination集合中。<br><img src="https://img-blog.csdnimg.cn/20200816212700862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<hr>
<ul>
<li>（9）<code>sdiff  key1  key2 </code>：取出key1中与key2集合的不同元素，差集<br><img src="https://img-blog.csdnimg.cn/20200816212803996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>（10）<code>sinter key1 key2</code> ：取key1与key2两个集合中相同的元素，交集<br><img src="https://img-blog.csdnimg.cn/20200816212834867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>（11）<code>sunion key1  key2</code>：将key1与key2两个集合中的元素合在一起，并集<br><img src="https://img-blog.csdnimg.cn/20200816212902838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3></li>
<li>微博、用户将所有关注的人都放入到一个set集合当中，将它的粉丝也放在一个集合中。</li>
<li>共同关注、共同爱好、二度好友、QQ的好友推荐（六度分割理论）</li>
</ul>
<h2 id="SortedSet-有序集合-zset"><a href="#SortedSet-有序集合-zset" class="headerlink" title="SortedSet( 有序集合)  zset"></a>SortedSet( 有序集合)  zset</h2><p>Redis 的有序集合类似于 Redis 的集合，字符串不重复的集合。</p>
<h3 id="常用命令介绍"><a href="#常用命令介绍" class="headerlink" title="常用命令介绍"></a>常用命令介绍</h3><ul>
<li><p>（1）<code>zadd key score value</code>： 将一个或多个 value 及其 socre 加入到 set 中<br><img src="https://img-blog.csdnimg.cn/20200816213307464.png" alt="在这里插入图片描述"></p>
</li>
<li><p>（2）<code>zrange key start end </code>：0 和-1 表示从索引为 0 的元素到最后一个元素（同 LRANGE 命令相似）<br><img src="https://img-blog.csdnimg.cn/20200816213337690.png" alt="在这里插入图片描述"></p>
</li>
<li><p>（3）<code>zrange key 0 -1 withscores</code> 也可以连同 score 一块输出，使用 WITHSCORES 参数<br><img src="https://img-blog.csdnimg.cn/20200816213404516.png" alt="在这里插入图片描述"></p>
</li>
<li><p>（4）<code>zremrangebyscore key start end </code>：可用于范围删除操作<br><img src="https://img-blog.csdnimg.cn/20200816213444634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>（5）<code>zrangebyscore  key  min max</code>: 升序排序操作，将key按最小值到最大值进行输出。<br><code>zrevrange salary 0 -1 </code>：这个是倒序全部输出<br><img src="https://img-blog.csdnimg.cn/20200816213525208.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200816213543265.png#pic_center" alt="在这里插入图片描述"><br>以上是从小到大排序，也就是升序排序。</p>
</li>
<li><p>（6）<code>zrevrangebyscore key max min </code>：倒序排序操作，将key按照从大到小排序输出<br><img src="https://img-blog.csdnimg.cn/20200816213621171.png" alt="在这里插入图片描述"></p>
</li>
<li><p>（6）<code>zrem  key  value</code> :  删除指定的元素<br><img src="https://img-blog.csdnimg.cn/20200816213652797.png" alt="在这里插入图片描述"></p>
</li>
<li><p>（7）<code>zcard key</code> ：获取有序集合中的个数<br><img src="https://img-blog.csdnimg.cn/20200816213716899.png" alt="在这里插入图片描述"></p>
</li>
<li><p>（8）<code>zcount key min  max </code>: 获取指定区间的成员数量<br><img src="https://img-blog.csdnimg.cn/20200816213741884.png" alt="在这里插入图片描述"></p>
<h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3></li>
<li><p>存储班级成绩表、工资表排序</p>
</li>
</ul>
<h1 id="Redis三种特殊的数据类型"><a href="#Redis三种特殊的数据类型" class="headerlink" title="Redis三种特殊的数据类型"></a>Redis三种特殊的数据类型</h1><p>本次介绍的三种特殊类型为：</p>
<ul>
<li>Geospatial 地理位置</li>
<li>Hyperloglog 基数统计</li>
<li>Bitmap位图场景</li>
</ul>
<h2 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial 地理位置"></a>Geospatial 地理位置</h2><p>我们日常生活中的定位、查看附近的人、朋友的定位、打车距离计算等等，基本上都是使用Geospatial 。</p>
<p>Redis的Geo在Redis3.2版本就推出了这个功能，这个功能可以推算出地理位置的信息，两地之间的距离，方圆几里的人。</p>
<p><a href="https://www.redis.net.cn/order/3687.html">链接地址点这里</a><br>它主要有以下六个命令：<br><img src="https://img-blog.csdnimg.cn/20200816214825251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h3><ul>
<li>（1）<code>geoadd命令</code>：将指定的地理空间位置（纬度、经度、名称）添加到指定的key中。<br><strong>格式</strong>：<code>geoadd   key   经度   纬度   地理位置   </code><br>例如：geoadd china:city 116.40 39.90 beijing<br>有效的经度从-180度到180度。<br>有效的纬度从-85.05112878度到85.05112878度。<br>当坐标位置超出上述指定范围时，该命令将会返回下述错误。<br><code>(error) ERR invalid longitude,latitude pair 39.900000,116.400000</code></li>
</ul>
<p>同时，这个命令还可以添加多个元素，例如：<br><code>geoadd china:city 116.40 39.90 beijing  121.47 32.23 shanghai</code><br><img src="https://img-blog.csdnimg.cn/20200816215259235.png#pic_center" alt="在这里插入图片描述"><br><strong>规则：两级（南极北极）是无法直接添加的，一般会下载城市数据，直接通过Java程序一次性导入。</strong></p>
<ul>
<li><p>（2）<code>geopos命令</code>：从key里返回所有给定位置元素的位置（经度和纬度）。<br><strong>格式</strong>：<code>geopos  key member  </code><br>例如：<code>geopos china:city beijing</code><br>返回值：GEOPOS 命令返回一个数组， 数组中的每个项都由两个元素组成： 第一个元素为给定位置元素的经度， 而第二个元素则为给定位置元素的纬度。<br>当给定的元素不存在时，对应的数组项为空值。<br><img src="https://img-blog.csdnimg.cn/20200816215427706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>（3）<code>geodist命令</code>：返回两个给定位置之间的直线距离，如果两个位置之间的其中一个不存在，那么命令就返回空值。<br><strong>格式：</strong><code>geodist   key member1  member2  [unit]       </code><br>指定单位的参数 unit 必须是以下单位的其中一个：<br>m 表示单位为米。<br>km 表示单位为千米。<br>mi 表示单位为英里。<br>ft 表示单位为英尺。<br>如果用户没有显式地指定单位参数， 那么 <strong>GEODIST 默认使用米作为单位</strong>。<br><img src="https://img-blog.csdnimg.cn/20200816215539104.png#pic_center" alt="在这里插入图片描述"><br>GEODIST 命令在计算距离时会假设地球为完美的球形， 在极限情况下， 这一假设最大会造成 0.5% 的误差。</p>
</li>
<li><p>（4）<code>georadius命令</code>：以给定的经纬度为中心，找出某一半径内的元素。<br>以给定的经纬度为中心，返回键包含的位置元素当中，与中心的距离不超过给定最大距离的所有位置元素。<br><strong>格式</strong>：<code>georadius key longitude latitude radius m|km|ft|mi  </code><br>例如： georadius china:city 110 23 1000 km<br>key为键，longitude、latitude表示当前位置的经纬度，radius表示搜索半径，m|km|ft|mi表示单位。<br><img src="https://img-blog.csdnimg.cn/20200816215724208.png#pic_center" alt="在这里插入图片描述"><br>上图的代码解释：<br>以110  23为经纬度查询方圆1000km内的城市。前提是所有的数据录入了china:city中。</p>
</li>
</ul>
<p>其余参数解释：<br><code>georadius key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE k]</code><br>在给定以下可选项时， 命令会返回额外的信息：<br><code>WITHDIST</code>: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。显示到中间距离的位置。<br><code>WITHCOORD</code>: 将位置元素的经度和维度也一并返回。显示他人的定位信息。<br><code>WITHHASH</code>: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。<br>命令默认返回未排序的位置元素。 通过以下两个参数， 用户可以指定被返回位置元素的排序方式：</p>
<p><code>ASC</code>: 根据中心的位置， 按照从近到远的方式返回位置元素。<br><code>DESC</code>: 根据中心的位置， 按照从远到近的方式返回位置元素。<br>在默认情况下， GEORADIUS 命令会返回所有匹配的位置元素。 虽然用户可以使用<code>COUNT &lt;count&gt; </code>选项去获取前 N 个匹配元素， 但是因为命令在内部可能会需要对所有被匹配的元素进行处理， 所以在对一个非常大的区域进行搜索时， 即使只使用 COUNT 选项去获取少量元素， 命令的执行速度也可能会非常慢。 但是从另一方面来说， 使用 COUNT 选项去减少需要返回的元素数量， 对于减少带宽来说仍然是非常有用的。<br>获得指定的人数：2人<br><img src="https://img-blog.csdnimg.cn/20200816215835495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>应用场景：附近的人。。</p>
<ul>
<li>（5）<code>georadiusbymember命令</code>：找出位于指定范围内的元素，中心点是由给定的位置元素决定。<br>这个命令和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 GEORADIUSBYMEMBER 的中心点是由给定的位置元素决定的， 而不是像 GEORADIUS 那样， 使用输入的经度和纬度来决定中心点<br><strong>格式</strong>：<code>georadiusbymember key member radius m|km|ft|mi</code><br>例如：<code>georadiusbymember china:city shanghai 1000 km</code><br>后面的参数，可以参考GEORADIUS命令。<br><img src="https://img-blog.csdnimg.cn/20200816215951512.png#pic_center" alt="在这里插入图片描述"></li>
<li>（6）<code>geohash命令</code>：返回一个或多个位置元素的Geohash字符串。<br>该命令返回11个字符的Geohash字符串，命令返回的 geohash 的位置与用户给定的位置元素的位置一一对应。<br><img src="https://img-blog.csdnimg.cn/20200816220018469.png#pic_center" alt="在这里插入图片描述"><br>将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近。</li>
</ul>
<h3 id="底层实现原理"><a href="#底层实现原理" class="headerlink" title="底层实现原理"></a>底层实现原理</h3><p>GEO底层的实现原理其实就是Zset，我们可以使用Zset命令来操作GEO。<br><img src="https://img-blog.csdnimg.cn/20200816220104665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="Hyperloglog-基数统计"><a href="#Hyperloglog-基数统计" class="headerlink" title="Hyperloglog 基数统计"></a>Hyperloglog 基数统计</h2><ul>
<li><p>什么是基数？<br>一个可重复集合内不重复元素的个数就是基数。</p>
</li>
<li><p>简介<br>Redis 2.8.9版本就更新了Hyperloglog数据结构。<br>Redis Hyperloglog基数统计的算法。</p>
</li>
<li><p>优点：占用的内存是固定的，2^64不同元素的技术，只需要费12KB内存。如果要从内存角度来比较的话，Hyperloglog是首选。</p>
</li>
<li><p>举例：网页的UV（一个人访问一个网站多次，但是还是算作一个人）</p>
</li>
</ul>
<p>传统的方式：使用set保护用户的ID，然后就可以统计set中的元素数量作为标准判断，这个方式如果保存大量的用户id，就会比较麻烦。</p>
<p>我们的目的是为了计数，而不是存储用户id。</p>
<h3 id="命令介绍-1"><a href="#命令介绍-1" class="headerlink" title="命令介绍"></a>命令介绍</h3><ul>
<li>（1）<code>pfadd key  member1 member2 .... </code>：添加一个或者多个元素</li>
<li>（2）<code>pfcount key </code>：统计key集合中基数的个数<br><img src="https://img-blog.csdnimg.cn/20200816220232560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>（3）<code>pfmerge newKey  key1  key2 ...  </code>：合并key1和key2中的元素，并且剔除其中重复的元素，产生新的集合newKey。<br><img src="https://img-blog.csdnimg.cn/20200816220314566.png#pic_center" alt="在这里插入图片描述"><br>key1中的元素有：a b c d e f g<br>key2中的元素有：h i j a e q n m c<br>重复的元素有：a e c<br>产生的newKey中的元素有：a b c d e f g h i j q n m </li>
</ul>
<h3 id="应用场景：适合做页面统计。"><a href="#应用场景：适合做页面统计。" class="headerlink" title="应用场景：适合做页面统计。"></a>应用场景：适合做页面统计。</h3><p>如果允许容错，那么一定要使用Hyperloglog；<br>如果不允许容错，就使用set或者自己的数据类型即可。<br>（容错就是当由于种种原因在系统中出现了数据、文件损坏或丢失时，系统能够自动将这些损坏或丢失的文件和数据恢复到发生事故以前的状态，使系统能够连续正常运行的一种技术，很简单的意思）</p>
<h2 id="Bitmap位图场景"><a href="#Bitmap位图场景" class="headerlink" title="Bitmap位图场景"></a>Bitmap位图场景</h2><ul>
<li>概括<br>Bitmap是位图，数据结构，都是操作二进制位来进行记录，就只有0和1两个状态。<br>365天 = 365bit      1字节 = 8bit      大约45个字节左右</li>
</ul>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul>
<li><p>（1）<code>setbit key offset value </code>：value只能是0或者1，如下例子所示：<br><img src="https://img-blog.csdnimg.cn/20200816220436540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>使用bitmap来记录周一到周日的打卡。<br>上图中的offeset表示周几，value的0表示未打卡，1表示打开成功。<br>周一0：1，周二1：0，周三2：1，周四3：1，……….</p>
</li>
<li><p>（2）<code>getbit key offset</code>：获取key中的offset值，查看某一天是否打卡<br><img src="https://img-blog.csdnimg.cn/20200816220459366.png#pic_center" alt="在这里插入图片描述"><br>以上表示的是查看周四是否打卡，周日是否打卡。</p>
</li>
<li><p>（3）<code>bitcount key </code>：统计操作，统计打开的天数，相当于统计sign中value为1的元素个数<img src="https://img-blog.csdnimg.cn/20200816220528963.png" alt="在这里插入图片描述"></p>
<h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><p>统计用户信息、活跃、不活跃、登录、未登录、打卡等等….. 两个状态的都可以使用Bitmap。</p>
</li>
</ul>
<p>在生活或者开发中都有十分多的应用场景。</p>
<h1 id="面试题常问的数据类型"><a href="#面试题常问的数据类型" class="headerlink" title="面试题常问的数据类型"></a>面试题常问的数据类型</h1><blockquote>
<p>1、Redis 的数据类型有哪些？ </p>
</blockquote>
<ul>
<li><p>Redis支持五种数据类型：String（字符串）、hash（哈希）、list（列表）、set（集合）以及zsetsorted set（有序集合）。</p>
</li>
<li><p>我们实际项目中比较常用的是String和hash，如果你是Redis的中高级用户，还需要加上以下几种数据类型，分别是：HyperLogLog、Geo、Pub/Sub。</p>
</li>
<li><p>如果你玩过Redis Module，像BloomFilter、RedisSearch、Redis-ML，，等等，是加分项。</p>
</li>
</ul>
<blockquote>
<p>2、一个字符串类型的值能存储最大容量是多少？ </p>
</blockquote>
<p>一个字符串类型的值能存储的最大容量为512M。</p>
<blockquote>
<p>3、Redis key 的过期时间和永久有效分别怎么设置？</p>
</blockquote>
<ul>
<li><p>使用expire命令对key的过期时间进行设置；</p>
</li>
<li><p>使用persist命令对key永久有效进行设置；</p>
</li>
</ul>
<blockquote>
<p>4、一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set他们最多能存放多少元素？</p>
</blockquote>
<p>理论上Redis可以处理多达232个keys，并且在实际中进行了测试，每个实例至少存放了2亿5千万的keys。</p>
<p>任何list、set和sorted set都可以放232个元素，换句话说，Redis的存储极限是系统中的可用内存值。</p>
<blockquote>
<p>5、Redis 最适合的场景？ </p>
</blockquote>
<ul>
<li>（1）会话缓存（最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？ 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为人知的商业平台Magento 也提供 Redis 的插件。</li>
<li>（2）全页缓存（FPC）<br>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。 再次以 Magento 为例，Magento提供一个插件来使用 Redis 作为全页缓存后端。 此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</li>
<li>（3）队列<br>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop 操作。 如果你快速的在 Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用 Redis 作为 broker，你可以从这里去查看。</li>
<li>（4）排行榜/计数器<br>Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的 10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可以在这里看到。</li>
<li>（5）发布/订阅<br>最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用 Redis 的发布/订阅功能来建立聊天系统！）</li>
</ul>
<blockquote>
<p>6、假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？ </p>
</blockquote>
<p>使用keys指令可以扫出指定模式的key列表。</p>
<blockquote>
<p>7、如果这个Redis正在给线上的业务提供服务，那使用keys指令会有什么问题？<br>这个时候就要回答：Redis是单线程的，keys指令会导致线程阻塞一段时间，线上服务会停顿，知道指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取指令模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
</blockquote>
<blockquote>
<p>8、如果有大量的 key 需要设置同一时间过期，一般需要注意什么？ </p>
</blockquote>
<p>如果大量的key过期时间设置过于集中，那么到过期的那个时间点，Redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一点。</p>
<blockquote>
<p>9、使用过 Redis 做异步队列么，你是怎么用的？</p>
</blockquote>
<p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。<br>当lpop没有消息的时候，要适当sleep一会儿再重试。</p>
<blockquote>
<p>追问：可不可以不使用sleep呢？</p>
</blockquote>
<p>list还有个指令叫blpop，在没有消息的时候，它会阻塞住，直到消息到来。</p>
<blockquote>
<p>再追问：能不能生产一次，消费多次呢？</p>
</blockquote>
<p>使用pub/sub主题订阅者模式，可以使用1:N的消息队列。</p>
<blockquote>
<p>再问：pub/sub有什么缺点？</p>
</blockquote>
<p>在消费者下线的情况下，生产的消息会丢失，解决这样的问题得使用专业的消息队列，如RabbitMQ等。</p>
<blockquote>
<p>Redis如何实现延时队列呢？</p>
</blockquote>
<p>使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangbyscore指令获取N秒之前的数据轮询进行处理。</p>
<blockquote>
<p>10、使用过 Redis 分布式锁么，它是什么回事？</p>
</blockquote>
<p>先拿setnx来争抢锁，抢到之后再用expire给锁加一个过期时间防止锁忘记了释放。</p>
<blockquote>
<p>问：如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？</p>
</blockquote>
<p>这个时候确实锁会永远得不到释放了，但是set指令有个非常复杂的参数是可以同时把setnx和expire合成一条指令来用的。</p>
<h1 id="寄言"><a href="#寄言" class="headerlink" title="寄言"></a>寄言</h1><p>学习Redis建议看官网的文档进行学习，Redis还有许多的命令未介绍出来，如果在工作中使用到了，可以去Redis官方文档中查看，这里介绍一个Redis的<a href="https://www.redis.net.cn/order/">中文命令手册</a>点击即达。</p>
<blockquote>
<p>创作不易，如果觉得对你有帮助，可以点个赞支持一下哈。</p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的常用命令、配置文件介绍、数据持久化方式、集群搭建</title>
    <url>/2020/08/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BRedis%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D%E3%80%81%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E3%80%81%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="上篇简述"><a href="#上篇简述" class="headerlink" title="上篇简述"></a>上篇简述</h1><p>上篇介绍了Redis的基本情况、单机版的安装以及基本数据类型，详情请点击<a href="/2020/07/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BRedis%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARedis%E4%BB%8B%E7%BB%8D%E3%80%81%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D/" title="这里">这里</a>。</p>
<p>本篇文章主要介绍Redis的常用命令、redis.conf配置文件的介绍、数据持久化的两种方式以及集群的搭建。</p>
<p>集群搭建所需文件：<br>链接：<a href="https://pan.baidu.com/s/1kVOpe2hO1wAXn6mfvBoZXw">https://pan.baidu.com/s/1kVOpe2hO1wAXn6mfvBoZXw</a><br>提取码：hxfe</p>
<h1 id="一、Redis的常用命令"><a href="#一、Redis的常用命令" class="headerlink" title="一、Redis的常用命令"></a>一、Redis的常用命令</h1><ul>
<li><p><code>ping</code> ： 测试 redis 是否链接 如果已链接返回 PONG</p>
</li>
<li><p><code>echo value</code> ： 测试 redis 是否链接 如果已链接返回 echo 命令后给定的值</p>
</li>
<li><p><code>keys *  </code>：返回所有的 key，可以加*通配   <strong>(重点掌握)</strong></p>
</li>
<li><p><code>exists key </code>： 判断 string 类型一个 key 是否存在 如果存在返回 1 否则返回 0</p>
</li>
<li><p><code>expire key time(s) </code>： 设置一个 key 的过期时间 单位秒。时间到达后会删除 key 及 value    <strong>(重点掌握)</strong></p>
</li>
<li><p><code>ttl key</code> ：查询已设置过期时间的 key 的剩余时间 如果返回-2 表示该键值对已经被删除，如果没有设置失效时间，会返回-1       <strong>(重点掌握)</strong></p>
</li>
<li><p><code>persist </code>： 移除给定 key 的过期时间         <strong>(重点掌握)</strong></p>
</li>
<li><p><code>select dbindex</code> ： 选择数据库(0-15)</p>
</li>
<li><p><code>move key dbIndex </code>： 将当前数据库中的 key 转移到其他数据库中</p>
</li>
<li><p><code>dbsize</code> ： 返回当前数据库中的 key 的数目</p>
</li>
<li><p><code>info</code> ： 获取服务器的信息和统计</p>
</li>
<li><p><code>flushdb </code>： 删除当前选择的数据库中的 key</p>
</li>
<li><p><code>flushall </code>： 删除所有数据库中的所有 key</p>
</li>
<li><p><code>quit</code> ： 退出连接，这时候redis还在后台运行。</p>
<pre><code>     ./redis-cli shutdown   才是真正的结束redis</code></pre>
</li>
</ul>
<h1 id="二、Redis的配置文件介绍"><a href="#二、Redis的配置文件介绍" class="headerlink" title="二、Redis的配置文件介绍"></a>二、Redis的配置文件介绍</h1><p>由于配置文件比较长，这里将配置文件的中文注释全部给出来。<br>在redis的安装目录下的bin目录中有一个redis.conf文件，使用vim编辑查看即可，稍微重要一点的我会用空格换行加横线进行表明，具体内容如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#redis.conf</span><br><span class="line"># Redis configuration file example.</span><br><span class="line"># .&#x2F;redis-server &#x2F;path&#x2F;to&#x2F;redis.conf</span><br><span class="line">################################## INCLUDES</span><br><span class="line">###################################</span><br><span class="line">#这在你有标准配置模板但是每个 redis 服务器又需要个性设置的时候很有用。</span><br><span class="line"># include &#x2F;path&#x2F;to&#x2F;local.conf</span><br><span class="line"># include &#x2F;path&#x2F;to&#x2F;other.conf</span><br><span class="line">################################ GENERAL #####################################</span><br><span class="line"></span><br><span class="line">#——————————————————————————————</span><br><span class="line">#是否在后台执行，yes：后台运行；no：不是后台运行（老版本默认）</span><br><span class="line">daemonize yes</span><br><span class="line">#——————————————————————————————</span><br><span class="line"></span><br><span class="line">#3.2 里的参数，是否开启保护模式，默认开启。要是配置里没有指定 bind 和密码。开启该参数后，redis</span><br><span class="line">只会本地进行访问，拒绝外部访问。要是开启了密码 和 bind，可以开启。否则最好关闭，设置为no。</span><br><span class="line">protected-mode yes</span><br><span class="line">#redis 的进程文件</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis&#x2F;redis-server.pid</span><br><span class="line"></span><br><span class="line">#——————————————————————————————</span><br><span class="line">#redis 监听的端口号。</span><br><span class="line">port 6379</span><br><span class="line">#——————————————————————————————</span><br><span class="line"></span><br><span class="line">#此参数确定了 TCP 连接中已完成队列(完成三次握手之后)的长度， 当然此值必须不大于 Linux 系统定</span><br><span class="line">义的&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn 值，默认是 511，而 Linux 的默认参数值是 128。当系统并</span><br><span class="line">发量大并且客户端速度缓慢的时候，可以将这二个参数一起参考设定。该内核参数默认值一般是 128，对</span><br><span class="line">于负载很大的服务程序来说大大的不够。一般会将它修改为 2048 或者更大。在&#x2F;etc&#x2F;sysctl.conf 中</span><br><span class="line">添加:net.core.somaxconn &#x3D; 2048，然后在终端中执行 sysctl -p。</span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line">#——————————————————————————————</span><br><span class="line">#指定 redis 只接收来自于该 IP 地址的请求，如果不进行设置，那么将处理所有请求</span><br><span class="line">#bind 127.0.0.1</span><br><span class="line">#——————————————————————————————</span><br><span class="line"></span><br><span class="line">#配置 unix socket 来让 redis 支持监听本地连接。</span><br><span class="line"># unixsocket &#x2F;var&#x2F;run&#x2F;redis&#x2F;redis.sock</span><br><span class="line">#配置 unix socket 使用文件的权限</span><br><span class="line"># unixsocketperm 700</span><br><span class="line"># 此参数为设置客户端空闲超过 timeout，服务端会断开连接，为 0 则服务端不会主动断开连接，不能小于 0。</span><br><span class="line">timeout 0</span><br><span class="line">#tcp keepalive 参数。如果设置不为 0，就使用配置 tcp 的 SO_KEEPALIVE 值，使用 keepalive 有</span><br><span class="line">两个好处:检测挂掉的对端。降低中间设备出问题而导致网络看似连接却已经与对端端口的问题。在 Linux</span><br><span class="line">内核中，设置了 keepalive，redis 会定时给对端发送 ack。检测到对端关闭需要两倍的设置值。</span><br><span class="line">tcp-keepalive 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#——————————————————————————————</span><br><span class="line">#指定了服务端日志的级别。级别包括：debug（很多信息，方便开发、测试），verbose（许多有用的</span><br><span class="line">信息，但是没有 debug 级别信息多），notice（适当的日志级别，适合生产环境），warn（只有非常重要的信息）</span><br><span class="line">loglevel notice</span><br><span class="line">#——————————————————————————————</span><br><span class="line">#——————————————————————————————</span><br><span class="line">#指定了记录日志的文件。空字符串的话，日志会打印到标准输出设备。后台运行的 redis 标准输出是&#x2F;dev&#x2F;null。</span><br><span class="line">logfile &#x2F;var&#x2F;log&#x2F;redis&#x2F;redis-server.log</span><br><span class="line">#——————————————————————————————</span><br><span class="line"></span><br><span class="line">#是否打开记录 syslog 功能</span><br><span class="line"># syslog-enabled no</span><br><span class="line">#syslog 的标识符。</span><br><span class="line"># syslog-ident redis</span><br><span class="line">#日志的来源、设备</span><br><span class="line"># syslog-facility local0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#——————————————————————————————</span><br><span class="line">#数据库的数量，默认使用的数据库是 DB 0。可以通过”SELECT “命令选择一个 db</span><br><span class="line">databases 16</span><br><span class="line">#——————————————————————————————</span><br><span class="line"></span><br><span class="line">#——————————————————————————————</span><br><span class="line">################################ SNAPSHOTTING ################################</span><br><span class="line"># 快照配置</span><br><span class="line"># 注释掉“save”这一行配置项就可以让保存数据库功能失效</span><br><span class="line"># 设置 sedis 进行数据库镜像的频率。</span><br><span class="line"># 900 秒（15 分钟）内至少 1 个 key 值改变（则进行数据库保存--持久化）</span><br><span class="line"># 300 秒（5 分钟）内至少 10 个 key 值改变（则进行数据库保存--持久化）</span><br><span class="line"># 60 秒（1 分钟）内至少 10000 个 key 值改变（则进行数据库保存--持久化）</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">#——————————————————————————————</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#当 RDB 持久化出现错误后，是否依然进行继续进行工作，yes：不能进行工作，no：可以继续进行工作，</span><br><span class="line">可以通过 info 中的 rdb_last_bgsave_status 了解 RDB 持久化是否有错误</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">#使用压缩 rdb 文件，rdb 文件压缩使用 LZF 压缩算法，yes：压缩，但是需要一些 cpu 的消耗。no：不压缩，需要更多的磁盘空间</span><br><span class="line">rdbcompression yes</span><br><span class="line">#是否校验 rdb 文件。从 rdb 格式的第五个版本开始，在 rdb 文件的末尾会带上 CRC64 的校验和。这跟有利于文件的容错性，</span><br><span class="line">但是在保存 rdb 文件的时候，会有大概 10%的性能损耗，所以如果你追求高性能，可以关闭该配置。</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line">#——————————————————————————————</span><br><span class="line">#rdb 文件的名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">#数据目录，数据库的写入会在这个目录。rdb、aof 文件也会写在这个目录</span><br><span class="line">dir &#x2F;root&#x2F;temp</span><br><span class="line">#——————————————————————————————</span><br><span class="line"></span><br><span class="line">################################# REPLICATION</span><br><span class="line">#################################</span><br><span class="line">#复制选项，slave 复制对应的 master。</span><br><span class="line"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">#如果 master 设置了 requirepass，那么 slave 要连上 master，需要有 master 的密码才行。</span><br><span class="line">masterauth 就是用来配置 master 的密码，这样可以在连上 master 后进行认证。</span><br><span class="line"># masterauth &lt;master-password&gt;</span><br><span class="line">#当从库同主机失去连接或者复制正在进行，从机库有两种运行方式：1) 如果</span><br><span class="line">slave-serve-stale-data 设置为 yes(默认设置)，从库会继续响应客户端的请求。2) 如果</span><br><span class="line">slave-serve-stale-data 设置为 no，除去 INFO 和 SLAVOF 命令之外的任何请求都会返回一个错</span><br><span class="line">误”SYNC with master in progress”。</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line">#作为从服务器，默认情况下是只读的（yes），可以修改成 NO，用于写（不建议）。</span><br><span class="line">slave-read-only yes</span><br><span class="line">#是否使用 socket 方式复制数据。目前 redis 复制提供两种方式，disk 和 socket。如果新的 slave</span><br><span class="line">连上来或者重连的 slave 无法部分同步，就会执行全量同步，master 会生成 rdb 文件。有 2 种方式：</span><br><span class="line">disk 方式是 master 创建一个新的进程把 rdb 文件保存到磁盘，再把磁盘上的 rdb 文件传递给 slave。</span><br><span class="line">socket 是 master 创建一个新的进程，直接把 rdb 文件以 socket 的方式发给 slave。disk 方式的时</span><br><span class="line">候，当一个 rdb 保存的过程中，多个 slave 都能共享这个 rdb 文件。socket 的方式就的一个个 slave</span><br><span class="line">顺序复制。在磁盘速度缓慢，网速快的情况下推荐用 socket 方式。</span><br><span class="line">repl-diskless-sync no</span><br><span class="line">#diskless 复制的延迟时间，防止设置为 0。一旦复制开始，节点不会再接收新 slave 的复制请求直到</span><br><span class="line">下一个 rdb 传输。所以最好等待一段时间，等更多的 slave 连上来。</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line">#slave 根据指定的时间间隔向服务器发送 ping 请求。时间间隔可以通过 repl_ping_slave_period来设置，默认 10 秒。</span><br><span class="line"># repl-ping-slave-period 10</span><br><span class="line">#复制连接超时时间。master 和 slave 都有超时时间的设置。master 检测到 slave 上次发送的时间超</span><br><span class="line">过 repl-timeout，即认为 slave 离线，清除该 slave 信息。slave 检测到上次和 master 交互的时</span><br><span class="line">间超过 repl-timeout，则认为 master 离线。需要注意的是 repl-timeout 需要设置一个比</span><br><span class="line">repl-ping-slave-period 更大的值，不然会经常检测到超时。</span><br><span class="line"># repl-timeout 60</span><br><span class="line">#是否禁止复制 tcp 链接的 tcp nodelay 参数，可传递 yes 或者 no。默认是 no，即使用 tcp nodelay。</span><br><span class="line">如果 master 设置了 yes 来禁止 tcp nodelay 设置，在把数据复制给 slave 的时候，会减少包的数量</span><br><span class="line">和更小的网络带宽。但是这也可能带来数据的延迟。默认我们推荐更小的延迟，但是在数据量传输很大的</span><br><span class="line">场景下，建议选择 yes。</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line">#复制缓冲区大小，这是一个环形复制缓冲区，用来保存最新复制的命令。这样在 slave 离线的时候，不</span><br><span class="line">需要完全复制 master 的数据，如果可以执行部分同步，只需要把缓冲区的部分数据复制给 slave，就能</span><br><span class="line">恢复正常复制状态。缓冲区的大小越大，slave 离线的时间可以更长，复制缓冲区只有在有 slave 连接</span><br><span class="line">的时候才分配内存。没有 slave 的一段时间，内存会被释放出来，默认 1m。</span><br><span class="line"># repl-backlog-size 5mb</span><br><span class="line">#master 没有 slave 一段时间会释放复制缓冲区的内存，repl-backlog-ttl 用来设置该时间长度。单位为秒。</span><br><span class="line"># repl-backlog-ttl 3600</span><br><span class="line">#当 master 不可用，Sentinel 会根据 slave 的优先级选举一个 master。最低的优先级的 slave，当</span><br><span class="line">选 master。而配置成 0，永远不会被选举。</span><br><span class="line">slave-priority 100</span><br><span class="line">#redis 提供了可以让 master 停止写入的方式，如果配置了 min-slaves-to-write，健康的 slave</span><br><span class="line">的个数小于 N，mater 就禁止写入。master 最少得有多少个健康的 slave 存活才能执行写命令。这个配</span><br><span class="line">置虽然不能保证 N 个 slave 都一定能接收到 master 的写操作，但是能避免没有足够健康的 slave 的时</span><br><span class="line">候，master 不能写入来避免数据丢失。设置为 0 是关闭该功能。</span><br><span class="line"># min-slaves-to-write 3</span><br><span class="line">#延迟小于 min-slaves-max-lag 秒的 slave 才认为是健康的 slave。</span><br><span class="line"># min-slaves-max-lag 10</span><br><span class="line"># 设置 1 或另一个设置为 0 禁用这个特性。</span><br><span class="line"># Setting one or the other to 0 disables the feature.</span><br><span class="line"># By default min-slaves-to-write is set to 0 (feature disabled) and</span><br><span class="line"># min-slaves-max-lag is set to 10.</span><br><span class="line">################################## SECURITY</span><br><span class="line">###################################</span><br><span class="line">#requirepass 配置可以让用户使用 AUTH 命令来认证密码，才能使用其他命令。这让 redis 可以使用在不受信任的网络中。为了保持向后的兼容性，可以注释该命令，因为大部分用户也不需要认证。使用requirepass 的时候需要注意，因为 redis 太快了，每秒可以认证 15w 次密码，简单的密码很容易被攻破，所以最好使用一个更复杂的密码。</span><br><span class="line"># requirepass foobared</span><br><span class="line">#把危险的命令给修改成其他名称。比如 CONFIG 命令可以重命名为一个很难被猜到的命令，这样用户不能使用，而内部工具还能接着使用。</span><br><span class="line"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line">#设置成一个空的值，可以禁止一个命令</span><br><span class="line"># rename-command CONFIG &quot;&quot;</span><br><span class="line">################################### LIMITS</span><br><span class="line">####################################</span><br><span class="line"># 设置能连上 redis 的最大客户端连接数量。默认是 10000 个客户端连接。由于 redis 不区分连接是客户端连接还是内部打开文件或者和 slave 连接等，所以 maxclients 最小建议设置到 32。如果超过了maxclients，redis 会给新的连接发送’max number of clients reached’，并关闭连接。</span><br><span class="line"># maxclients 10000</span><br><span class="line">#redis 配置的最大内存容量。当内存满了，需要配合 maxmemory-policy 策略进行处理。注意 slave的输出缓冲区是不计算在 maxmemory 内的。所以为了防止主机内存使用完，建议设置的 maxmemory 需要更小一些。</span><br><span class="line"># maxmemory &lt;bytes&gt;</span><br><span class="line">#内存容量超过 maxmemory 后的处理策略。</span><br><span class="line">#volatile-lru：利用 LRU 算法移除设置过过期时间的 key。</span><br><span class="line">#volatile-random：随机移除设置过过期时间的 key。</span><br><span class="line">#volatile-ttl：移除即将过期的 key，根据最近过期时间来删除（辅以 TTL）</span><br><span class="line">#allkeys-lru：利用 LRU 算法移除任何 key。</span><br><span class="line">#allkeys-random：随机移除任何 key。</span><br><span class="line">#noeviction：不移除任何 key，只是返回一个写错误。</span><br><span class="line">#上面的这些驱逐策略，如果 redis 没有合适的 key 驱逐，对于写命令，还是会返回错误。redis 将不</span><br><span class="line">再接收写请求，只接收 get 请求。写命令包括：set setnx setex append incr decr rpush lpush</span><br><span class="line">rpushx lpushx linsert lset rpoplpush sadd sinter sinterstore sunion sunionstore</span><br><span class="line">sdiff sdiffstore zadd zincrby zunionstore zinterstore hset hsetnx hmset hincrby</span><br><span class="line">incrby decrby getset mset msetnx exec sort。</span><br><span class="line"># maxmemory-policy noeviction</span><br><span class="line">#lru 检测的样本数。使用 lru 或者 ttl 淘汰算法，从需要淘汰的列表中随机选择 sample 个 key，选出</span><br><span class="line">闲置时间最长的 key 移除。</span><br><span class="line"># maxmemory-samples 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">############################## APPEND ONLY MODE ###############################</span><br><span class="line">#默认 redis 使用的是 rdb 方式持久化，这种方式在许多应用中已经足够用了。但是 redis 如果中途宕机，会导致可能有几分钟的数据丢失，根据 save 来策略进行持久化，Append Only File 是另一种持久化方式，可以提供更好的持久化特性。Redis 会把每次写入的数据在接收后都写入 appendonly.aof文件，每次启动时 Redis 都会先把这个文件的数据读入内存里，先忽略 RDB 文件。</span><br><span class="line">#——————————————————————————————</span><br><span class="line">appendonly no</span><br><span class="line">#aof 文件名</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line">#——————————————————————————————</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#aof 持久化策略的配置</span><br><span class="line">#no 表示不执行 fsync，由操作系统保证数据同步到磁盘，速度最快。</span><br><span class="line">#always 表示每次写入都执行 fsync，以保证数据同步到磁盘。</span><br><span class="line">#everysec 表示每秒执行一次 fsync，可能会导致丢失这 1s 数据。</span><br><span class="line">appendfsync everysec</span><br><span class="line"># 在 aof 重写或者写入 rdb 文件的时候，会执行大量 IO，此时对于 everysec 和 always 的 aof 模式</span><br><span class="line">来说，执行 fsync 会造成阻塞过长时间，no-appendfsync-on-rewrite 字段设置为默认设置为 no。</span><br><span class="line">如果对延迟要求很高的应用，这个字段可以设置为 yes，否则还是设置为 no，这样对持久化特性来说这是</span><br><span class="line">更安全的选择。设置为 yes 表示 rewrite 期间对新写操作不 fsync,暂时存在内存中,等 rewrite 完成</span><br><span class="line">后再写入，默认为 no，建议 yes。Linux 的默认 fsync 策略是 30 秒。可能丢失 30 秒数据。</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">#aof 自动重写配置。当目前 aof 文件大小超过上一次重写的 aof 文件大小的百分之多少进行重写，即当</span><br><span class="line">aof 文件增长到一定大小的时候 Redis 能够调用 bgrewriteaof 对日志文件进行重写。当前 AOF 文件大</span><br><span class="line">小是上次日志重写得到 AOF 文件大小的二倍（设置为 100）时，自动启动新的日志重写过程。</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">#设置允许重写的最小 aof 文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line">#aof 文件可能在尾部是不完整的，当 redis 启动的时候，aof 文件的数据被载入内存。重启可能发生在</span><br><span class="line">redis 所在的主机操作系统宕机后，尤其在 ext4 文件系统没有加上 data&#x3D;ordered 选项（redis 宕机</span><br><span class="line">或者异常终止不会造成尾部不完整现象。）出现这种现象，可以选择让 redis 退出，或者导入尽可能多的</span><br><span class="line">数据。如果选择的是 yes，当截断的 aof 文件被导入的时候，会自动发布一个 log 给客户端然后 load。</span><br><span class="line">如果是 no，用户必须手动 redis-check-aof 修复 AOF 文件才可以。</span><br><span class="line">aof-load-truncated yes</span><br><span class="line">################################ LUA SCRIPTING ###############################</span><br><span class="line"># 如果达到最大时间限制（毫秒），redis 会记个 log，然后返回 error。当一个脚本超过了最大时限。</span><br><span class="line">只有 SCRIPT KILL 和 SHUTDOWN NOSAVE 可以用。第一个可以杀没有调 write 命令的东西。要是已经</span><br><span class="line">调用了 write，只能用第二个命令杀。</span><br><span class="line">lua-time-limit 5000</span><br><span class="line"></span><br><span class="line">#——————————————————————————————</span><br><span class="line">################################ REDIS CLUSTER ###############################</span><br><span class="line">#集群开关，默认是不开启集群模式。</span><br><span class="line"># cluster-enabled yes</span><br><span class="line">#——————————————————————————————</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。这个文件并不需要手动配置，这个配置文件有 Redis 生成并更新，每个 Redis 集群节点需要一个单独的配置文件，请确保与实例运行的系统中配置文件名称不冲突</span><br><span class="line"># cluster-config-file nodes-6379.conf</span><br><span class="line">#节点互连超时的阀值。集群节点超时毫秒数</span><br><span class="line"># cluster-node-timeout 15000</span><br><span class="line">#在进行故障转移的时候，全部 slave 都会请求申请为 master，但是有些 slave 可能与 master 断开连</span><br><span class="line">接一段时间了，导致数据过于陈旧，这样的 slave 不应该被提升为 master。该参数就是用来判断 slave</span><br><span class="line">节点与 master 断线的时间是否过长。判断方法是：</span><br><span class="line">#比较 slave 断开连接的时间和(node-timeout * slave-validity-factor) +</span><br><span class="line">repl-ping-slave-period</span><br><span class="line">#如果节点超时时间为三十秒, 并且 slave-validity-factor 为 10,假设默认的</span><br><span class="line">repl-ping-slave-period 是 10 秒，即如果超过 310 秒 slave 将不会尝试进行故障转移</span><br><span class="line"># cluster-slave-validity-factor 10</span><br><span class="line">#master 的 slave 数量大于该值，slave 才能迁移到其他孤立 master 上，如这个参数若被设为 2，那</span><br><span class="line">么只有当一个主节点拥有 2 个可工作的从节点时，它的一个从节点会尝试迁移。</span><br><span class="line"># cluster-migration-barrier 1</span><br><span class="line">#默认情况下，集群全部的 slot 有节点负责，集群状态才为 ok，才能提供服务。设置为 no，可以在 slot</span><br><span class="line">没有全部分配的时候提供服务。不建议打开该配置，这样会造成分区的时候，小分区的 master 一直在接</span><br><span class="line">受写请求，而造成很长时间数据不一致。</span><br><span class="line"># cluster-require-full-coverage yes</span><br><span class="line">################################## SLOW LOG</span><br><span class="line">###################################</span><br><span class="line">###slog log 是用来记录 redis 运行中执行比较慢的命令耗时。当命令的执行超过了指定时间，就记录</span><br><span class="line">在 slow log 中，slog log 保存在内存中，所以没有 IO 操作。</span><br><span class="line">#执行时间比 slowlog-log-slower-than 大的请求记录到 slowlog 里面，单位是微秒，所以 1000000</span><br><span class="line">就是 1 秒。注意，负数时间会禁用慢查询日志，而 0 则会强制记录所有命令。</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line">#慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉。这个长度没有限制。只</span><br><span class="line">要有足够的内存就行。你可以通过 SLOWLOG RESET 来释放内存。</span><br><span class="line">slowlog-max-len 128</span><br><span class="line">################################ LATENCY MONITOR</span><br><span class="line">##############################</span><br><span class="line">#延迟监控功能是用来监控 redis 中执行比较缓慢的一些操作，用 LATENCY 打印 redis 实例在跑命令时</span><br><span class="line">的耗时图表。只记录大于等于下边设置的值的操作。0 的话，就是关闭监视。默认延迟监控功能是关闭的，</span><br><span class="line">如果你需要打开，也可以通过 CONFIG SET 命令动态设置。</span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line">############################# EVENT NOTIFICATION</span><br><span class="line">##############################</span><br><span class="line">#键空间通知使得客户端可以通过订阅频道或模式，来接收那些以某种方式改动了 Redis 数据集的事件。</span><br><span class="line">因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态。</span><br><span class="line">#notify-keyspace-events 的参数可以是以下字符的任意组合，它指定了服务器该发送哪些类型的通</span><br><span class="line">知：</span><br><span class="line">##K 键空间通知，所有通知以 __keyspace@__ 为前缀</span><br><span class="line">##E 键事件通知，所有通知以 __keyevent@__ 为前缀</span><br><span class="line">##g DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知</span><br><span class="line">##$ 字符串命令的通知</span><br><span class="line">##l 列表命令的通知</span><br><span class="line">##s 集合命令的通知</span><br><span class="line">##h 哈希命令的通知</span><br><span class="line">##z 有序集合命令的通知</span><br><span class="line">##x 过期事件：每当有过期键被删除时发送</span><br><span class="line">##e 驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送</span><br><span class="line">##A 参数 g$lshzxe 的别名</span><br><span class="line">#输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何 通知被分发。</span><br><span class="line">详细使用可以参考 http:&#x2F;&#x2F;redis.io&#x2F;topics&#x2F;notifications</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line">############################### ADVANCED CONFIG</span><br><span class="line">###############################</span><br><span class="line">#数据量小于等于 hash-max-ziplist-entries 的用 ziplist，大于 hash-max-ziplist-entries</span><br><span class="line">用 hash</span><br><span class="line">hash-max-ziplist-entries 512#value 大小小于等于 hash-max-ziplist-value 的用</span><br><span class="line">ziplist，大于 hash-max-ziplist-value 用 hash。</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line">#数据量小于等于 list-max-ziplist-entries 用 ziplist，大于 list-max-ziplist-entries</span><br><span class="line">用 list。</span><br><span class="line">list-max-ziplist-entries 512#value 大小小于等于 list-max-ziplist-value 的用</span><br><span class="line">ziplist，大于 list-max-ziplist-value 用 list。</span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line">#数据量小于等于 set-max-intset-entries 用 iniset，大于 set-max-intset-entries 用 set。</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line">#数据量小于等于 zset-max-ziplist-entries 用 ziplist，大于 zset-max-ziplist-entries</span><br><span class="line">用 zset。</span><br><span class="line">zset-max-ziplist-entries 128#value 大小小于等于 zset-max-ziplist-value 用 ziplist，</span><br><span class="line">大于 zset-max-ziplist-value 用 zset。</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line">#value 大小小于等于 hll-sparse-max-bytes 使用稀疏数据结构（sparse），大于</span><br><span class="line">hll-sparse-max-bytes 使用稠密的数据结构（dense）。一个比 16000 大的 value 是几乎没用的，</span><br><span class="line">建议的 value 大概为 3000。如果对 CPU 要求不高，对空间要求较高的，建议设置到 10000 左右。</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line">#Redis 将在每 100 毫秒时使用 1 毫秒的 CPU 时间来对 redis 的 hash 表进行重新 hash，可以降低内存</span><br><span class="line">的使用。当你的使用场景中，有非常严格的实时性需要，不能够接受 Redis 时不时的对请求有 2 毫秒的延</span><br><span class="line">迟的话，把这项配置为 no。如果没有这么严格的实时性要求，可以设置为 yes，以便能够尽可能快的释放</span><br><span class="line">内存。activerehashing yes</span><br><span class="line">##对客户端输出缓冲进行限制可以强迫那些不从服务器读取数据的客户端断开连接，用来强制关闭传输缓</span><br><span class="line">慢的客户端。</span><br><span class="line">#对于 normal client，第一个 0 表示取消 hard limit，第二个 0 和第三个 0 表示取消 soft limit，</span><br><span class="line">normal client 默认取消限制，因为如果没有寻问，他们是不会接收数据的。</span><br><span class="line">client-output-buffer-limit normal 0 0 0#对于 slave client 和 MONITER client，如果</span><br><span class="line">client-output-buffer 一旦超过 256mb，又或者超过 64mb 持续 60 秒，那么服务器就会立即断开客</span><br><span class="line">户端连接。</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60#对于 pubsub client，如果</span><br><span class="line">client-output-buffer 一旦超过 32mb，又或者超过 8mb 持续 60 秒，那么服务器就会立即断开客户</span><br><span class="line">端连接。</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line">#redis 执行任务的频率为 1s 除以 hz。</span><br><span class="line">hz 10</span><br><span class="line">#在 aof 重写的时候，如果打开了 aof-rewrite-incremental-fsync 开关，系统会每 32MB 执行一</span><br><span class="line">次 fsync。这对于把文件写入磁盘是有帮助的，可以避免过大的延迟峰值。</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure>
<p>其余的可以根据注释进行查看，可能格式的原因，所以会有点难看。</p>
<h1 id="三、数据持久化方式"><a href="#三、数据持久化方式" class="headerlink" title="三、数据持久化方式"></a>三、数据持久化方式</h1><h2 id="1、RDB-方式-默认"><a href="#1、RDB-方式-默认" class="headerlink" title="1、RDB  方式(默认)"></a>1、RDB  方式(默认)</h2><p>对内存中数据库状态进行快照。</p>
<p>RDB 方式：将 Redis 在内存中的数据库状态保存到磁盘里面，RDB 文件是一个经过压缩的二进制文件，通过该文件可以还原生成 RDB 文件时的数据库状态 （ 默认下，持久化到dump.rdb 文件，并且在 redis 重启后，自动读取其中文件，据悉，通常情况下一千万的字符串类型键，1GB 的快照文件，同步到内存中的 时间是 20-30 秒）</p>
<p><strong>RDB 的生成方式：</strong></p>
<ul>
<li><strong>（1）执行命令手动生成</strong><br>有两个 Redis 命令可以用于生成 RDB 文件，一个是 <strong>SAVE</strong>，另一个是 <strong>BGSAVE</strong>命令，SAVE会阻塞 Redis 服务器进程，直到 RDB 文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求，BGSAVE 命令会派生出一个子进程，然后由子进程负责创建RDB 文件，服务器进程（父进程）继续处理命令请求，创建 RDB 文件结束之前，客户端发送的 BGSAVE 和 SAVE 命令会被服务器拒绝</li>
</ul>
<p><strong>简述：</strong></p>
<ul>
<li>SAVE命令会阻塞Redis服务器进程，指导RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求，</li>
<li>BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。</li>
<li>但是在创建RDB文件未结束之前，也就是数据持久化没有完成之前，客户端再执行SAVE或者BGSAVE命令，都会被服务器拒绝，</li>
</ul>
<p>（1）SAVE命令为什么会阻塞Redis服务器进程呢？<br>Redis是以单进程的形式运行的，如果执行了一个SAVE命令，此时这个SAVE命令会在Redis进程当中执行，SAVE命令是做数据持久化，而这个数据持久化是有时间的，它要做I/O处理，这个时候会造成线程阻塞，直到RDB文件备份完成，在备份期间任何命令操作都不能去执行。</p>
<p>（2）BGSAVE是启动一个新的子进程，在新的进程当中去执行这个数据的备份，这个时候还是会阻塞，但是阻塞仅仅是阻塞子进程，对于父进程（服务器进程）是没有任何影响的，父进程可以继续处理命令请求的。在平时开发中，<strong>推荐使用这个命令</strong>。</p>
<ul>
<li><strong>（2）通过配置自动生成</strong><br>可以设置服务器配置的 save 选项，让服务器每隔一段时间自动执行一次 BGSAVE 命令，可以通过 save 选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行 BGSAVE 命令<br>例如：<br>save 900 1<br>save 300 10<br>save 60 10000<img src="https://img-blog.csdnimg.cn/20200812002346192.png#pic_center" alt="在这里插入图片描述"></li>
</ul>
<p>那么只要满足以下三个条件中的任意一个，BGSAVE 命令就会被执行<br>服务器在 900 秒之内，对数据库进行了至少 1 次修改<br>服务器在 300 秒之内，对数据库进行了至少 10 次修改<br>服务器在 60 秒之内，对数据库进行了至少 10000 次修改</p>
<p>dump.rdb 文件的存放位置为：在哪个目录下启动redis，就会在哪个目录下生成这个文件，配置文件中的（./）就是这个意思。<br><img src="https://img-blog.csdnimg.cn/20200812002608724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2、AOF-方式"><a href="#2、AOF-方式" class="headerlink" title="2、AOF 方式"></a>2、AOF 方式</h2><p>AOF 持久化方式在 redis 中默认是关闭的，需要修改配置文件开启该方式。<br>AOF：把每条命令都写入文件，类似 mysql 的 binlog 日志。<br>AOF 方式：是通过保存 Redis 服务器所执行的写命令来记录数据库状态的文件。<br>AOF 文件刷新的方式，有三种：</p>
<ul>
<li><p>appendfsync always - 每提交一个修改命令都调用 fsync 刷新到 AOF 文件，非常非常慢，但也非常安全。</p>
</li>
<li><p>appendfsync everysec - 每秒钟都调用 fsync 刷新到 AOF 文件，很快，但可能会丢失一秒以内的数据。</p>
</li>
<li><p>appendfsync no - 依靠 OS 进行刷新，redis 不主动刷新 AOF，这样最快，但安全性就差。</p>
</li>
<li><p><strong>默认并推荐每秒刷新，这样在速度和安全上都做到了兼顾</strong></p>
</li>
</ul>
<p><strong>AOF 数据恢复方式：</strong><br>服务器在启动时，通过载入和执行 AOF 文件中保存的命令来还原服务器关闭之前的数据库状态，具体过程：</p>
<ul>
<li>载入 AOF 文件</li>
<li>创建模拟客户端</li>
<li>从 AOF 文件中读取一条命令</li>
<li>使用模拟客户端执行命令</li>
<li>循环读取并执行命令，直到全部完成</li>
</ul>
<p><strong>如果同时启用了 RDB 和 AOF 方式，AOF 优先，启动时只加载 AOF 文件恢复数据</strong></p>
<p>开启AOF方式步骤：<br>首先进入redis.conf配置文件：<br>将no改为yes，文件存放的位置默认在bin目录下，还有刷新的方法，默认推荐是每秒刷新一次。<br><img src="https://img-blog.csdnimg.cn/20200812002917127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="四、Redis集群的搭建"><a href="#四、Redis集群的搭建" class="headerlink" title="四、Redis集群的搭建"></a>四、Redis集群的搭建</h1><h2 id="1、Redis-集群介绍"><a href="#1、Redis-集群介绍" class="headerlink" title="1、Redis  集群介绍"></a>1、Redis  集群介绍</h2><p>Redis3.0 版本之后支持 Cluster。<br>**集群要求集群节点中必须要支持主备模式，也就说集中的主节点(Master)至少要有一个从节点(Slave)**，下图中的每一个蓝色的圈都代表着一个 redis 集群中的主节点。它们任何两个节点之间都是相互连通的。<br>客户端可以与任何一个节点相连接，然后就可以访问集群中的任何一个节点。对其进行存取和其他操作。</p>
<h3 id="1-1-Redis-Cluster-架构图"><a href="#1-1-Redis-Cluster-架构图" class="headerlink" title="1.1 Redis-Cluster 架构图"></a>1.1 Redis-Cluster 架构图</h3><p><img src="https://img-blog.csdnimg.cn/20200812003033866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="1-2、Redis-Cluster-选举-容错"><a href="#1-2、Redis-Cluster-选举-容错" class="headerlink" title="1.2、Redis-Cluster  选举:容错"></a>1.2、Redis-Cluster  选举:容错</h3><p>Redis 之间通过互相的 ping-pong 判断是否节点可以连接上。如果有一半以上的节点去ping 一个节点的时候没有回应，集群就认为这个节点宕机了，然后去连接它的从节点。如果某个节点和所有从节点全部挂掉，我们集群就进入 fail 状态。还有就是如果有一半以上的主节点宕机，那么我们集群同样进入 fail 了状态。这就是我们的 redis 的投票机制，具体原理如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200812003132126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>投票过程是集群中所有master参与,如果半数以上master节点与master节点通信超时(cluster-node-timeout),认为当前 master 节点挂掉.<br><strong>问题：什么时候整个集群不可用(cluster_state:fail)?</strong></p>
<ul>
<li>（1）如果集群任意 master 挂掉,且当前 master 没有 slave。此时集群进入 fail 状态,也可以理解成集群的 slot 映射[0-16383]不完整时进入 fail 状态。</li>
<li>（2） 如果集群超过半数以上 master 挂掉，无论是否有 slave，集群进入 fail 状态.</li>
</ul>
<h3 id="1-3、Redis-Cluster-数据存储"><a href="#1-3、Redis-Cluster-数据存储" class="headerlink" title="1.3、Redis-Cluster 数据存储"></a>1.3、Redis-Cluster 数据存储</h3><p>当我们的存取的 key 到达的时候，redis 会根据 crc16 的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。<br><img src="https://img-blog.csdnimg.cn/20200812003247619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在 Node1 执行 set name oldou<br>        1. 使用 CRC16 算法对 key 进行计算，得到一个数字，然后对数字进行取余。<br>                CRC16 : name = 26384<br>                26384%16384 = 10000<br>        2. 查找到包含 10000 插槽的节点，比如是 node2，自动跳转到 node2<br>        3. 在 node2 上执行 set name oldou命令完成数据的插入<br>        4. 如果在 node1 上执行 get name，先使用 CRC16 算法对 key 进行计算，在使用16384 取余，得到插槽的下标，然后跳到拥有该插槽的 node2 中执行 get name 命令，并返回结果。</p>
<h2 id="2、安装伪集群"><a href="#2、安装伪集群" class="headerlink" title="2、安装伪集群"></a>2、安装伪集群</h2><h3 id="2-1-需求："><a href="#2-1-需求：" class="headerlink" title="2.1 需求："></a>2.1 需求：</h3><ul>
<li>搭建一个 Redis 的最小集群，使用伪集群方式（伪集群就是每个节点都是安装在本机上的）。</li>
<li>Redis 中最小的集群三对主从。</li>
<li>在 192.168.15.132中安装 6 个 redis 实例。</li>
<li>如果使用已经使用过的单机版创建集群时，需要删除 dump.rdb 与 apeendonly.aof 文件。</li>
<li>6 个 redis 实例的端口分配：8001、8002、8003、8004、8005、8006</li>
</ul>
<h3 id="2-2-创建伪集群步骤："><a href="#2-2-创建伪集群步骤：" class="headerlink" title="2.2 创建伪集群步骤："></a>2.2 创建伪集群步骤：</h3><p>redis 集群时需要使用一个 ruby 的脚本来完成集群。<br>进入到<code>/root/temp/redis-3.0.0/src</code>目录下，查找命令:<code>ll *.rb </code>   就可以看到一个文件，在执行这个文件之前，需要我们安装一个ruby。<br><strong>第一步：安装 ruby 环境</strong><br><code>命令： yum install ruby</code><br><img src="https://img-blog.csdnimg.cn/20200812003530859.png#pic_center" alt="在这里插入图片描述"><br><strong>第二步：安装 ruby 的包管理器</strong><br><code>命令：yum install rubygems</code></p>
<p><strong>第三步：在 redis 的安装目录下的 src 目录下找到 redis-trib.rb 这个文件，这是集群时需要的脚本</strong></p>
<p><strong>第四步：这个脚本的执行需要依赖于一些其他的 ruby 包 所以我们还要下载一个redis-3.0.0.gem，将这个文件上传到 linux 服务器的temp中(这个文件在资料的ruby和redis接口文件夹中)。</strong></p>
<p><strong>第五步：安装这个 ruby 包—进入到temp目录中</strong><br><code> 命令：gem install redis-3.0.0.gem</code><br><img src="https://img-blog.csdnimg.cn/20200812003700113.png#pic_center" alt="在这里插入图片描述"><br><strong>第六步：先启动 redis 的 6 个实例–(暂时没有，这个时候创建)<br>                先在 local 目录下创建一个目录名称为：redis-cluster</strong><br><code>命令：mkdir redis-cluster</code></p>
<p><strong>第七步：将安装好的 单机版redis下的 bin 目录拷贝到 redis-cluster 目录下 并起名为 redis01</strong><br><code>命令：进入到 redis 目录下执行：cp -r bin ../redis-cluster/redis01</code><br>之后进入到redis01中删除dump.rdb 与 apeendonly.aof 文件， 然后再修改redis01中的配置文件，vim编辑redis.conf文件修改的地方如下：<br><img src="https://img-blog.csdnimg.cn/20200812003815459.png#pic_center" alt="在这里插入图片描述"><br>修改完成保存并且退出，<strong>第三个图特别重要，如果不开启的话就不能创建集群</strong>。<br><strong>然后进入到/usr/local/redis-cluster的目录下，将redis01拷贝5份：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令：</span><br><span class="line">cp -r redis01&#x2F; redis02</span><br><span class="line">cp -r redis01&#x2F; redis03</span><br><span class="line">cp -r redis01&#x2F; redis04</span><br><span class="line">cp -r redis01&#x2F; redis05</span><br><span class="line">cp -r redis01&#x2F; redis06   </span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200812003912971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>第八步：修改 redis.conf 配置文件–修改拷贝的这些 redis 的端口</strong><br><code>命令：vim redis.conf</code><br>(1)修改端口：默认的为 6379 将六个 redis 实例的端口改成从 8001-8006 在配置文件的 port 属性中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令：</span><br><span class="line">[root@localhost redis-cluster]# vim redis02&#x2F;redis.conf</span><br><span class="line">[root@localhost redis-cluster]# vim redis03&#x2F;redis.conf</span><br><span class="line">[root@localhost redis-cluster]# vim redis04&#x2F;redis.conf</span><br><span class="line">[root@localhost redis-cluster]# vim redis05&#x2F;redis.conf</span><br><span class="line">[root@localhost redis-cluster]# vim redis06&#x2F;redis.conf</span><br></pre></td></tr></table></figure>
<p><strong>第九步 把创建集群的 ruby 脚本复制到 redis-cluster 中</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;root&#x2F;temp&#x2F;redis-3.0.0&#x2F;src&#x2F;  进入到该目录下</span><br><span class="line">cp *.rb &#x2F;usr&#x2F;local&#x2F;redis-cluster&#x2F;    拷贝</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200812004057887.png#pic_center" alt="在这里插入图片描述"><br><strong>第十步 创建一个能够批量启动的脚本程序，在redis-cluster的目录下执行以下命令</strong><br><code>命令：vim startall.sh</code></p>
<p><strong>第十一步 在脚本文件中添加命令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd redis01</span><br><span class="line">.&#x2F;redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis02</span><br><span class="line">.&#x2F;redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis03</span><br><span class="line">.&#x2F;redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis04</span><br><span class="line">.&#x2F;redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis05</span><br><span class="line">.&#x2F;redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis06</span><br><span class="line">.&#x2F;redis-server redis.conf</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure>
<p><strong>第十二步：将批量启动脚本设置为可执行权限</strong><br><code>命令:chmod +x startall.sh</code></p>
<p><strong>第十三步 执行这个批量启动的脚本</strong><br><code>命令：./startall.sh</code></p>
<p><strong>第十四步 查看 redis 是否启动成功</strong><br><code>命令：ps aux|grep redis</code><br><img src="https://img-blog.csdnimg.cn/20200812004257755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>第十五步 创建集群</strong></p>
<p>命 令 ： ./redis-trib.rb create –replicas  1 192.168.15.132:8001 192.168.15.132:8002 192.168.15.132:8003  192.168.15.132:8004 192.168.15.132:8005   192.168.15.132:8006</p>
<p><code>控制台会显示如下信息 输入 yes</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connecting to node 192.168.122.129:8001: OK</span><br><span class="line">Connecting to node 192.168.122.129:8002: OK</span><br><span class="line">Connecting to node 192.168.122.129:8003: OK</span><br><span class="line">Connecting to node 192.168.122.129:8004: OK</span><br><span class="line">Connecting to node 192.168.122.129:8005: OK</span><br><span class="line">Connecting to node 192.168.122.129:8006: OK</span><br><span class="line">&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...</span><br><span class="line">Using 3 masters:</span><br><span class="line">192.168.122.129:8001</span><br><span class="line">192.168.122.129:8002</span><br><span class="line">192.168.122.129:8003</span><br><span class="line">Adding replica 192.168.122.129:8004 to 192.168.122.129:8001</span><br><span class="line">Adding replica 192.168.122.129:8005 to 192.168.122.129:8002</span><br><span class="line">Adding replica 192.168.122.129:8006 to 192.168.122.129:8003</span><br><span class="line">M: 6ab91146f6757f18beafd45b962489cab3d341f7 192.168.122.129:8001</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">M: e4f4d7176f11272f29c6a35fb47ae4078557c9ab 192.168.122.129:8002</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">M: 06d1a2d7cd21d9b43b115c222a34ebce6f007d77 192.168.122.129:8003</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">S: 9ac5a60f61197d364a3e4da1887ddbfb311145bd 192.168.122.129:8004</span><br><span class="line">   replicates 6ab91146f6757f18beafd45b962489cab3d341f7</span><br><span class="line">S: f7c22c52f2ce2096f54429c48a8d4b7027f6d7b3 192.168.122.129:8005</span><br><span class="line">   replicates e4f4d7176f11272f29c6a35fb47ae4078557c9ab</span><br><span class="line">S: e4c559c018adccc965171eaa4b19d1a51a4f025a 192.168.122.129:8006</span><br><span class="line">   replicates 06d1a2d7cd21d9b43b115c222a34ebce6f007d77</span><br><span class="line">Can I set the above configuration? (type &#39;yes&#39; to accept): yes</span><br></pre></td></tr></table></figure>
<p>上图中的M表示主节点，S表示从节点。</p>
<p>如果控制台输出如下信息表集群成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting for the cluster to join....</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.122.129:8001)</span><br><span class="line">M: 6ab91146f6757f18beafd45b962489cab3d341f7 192.168.122.129:8001</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">M: e4f4d7176f11272f29c6a35fb47ae4078557c9ab 192.168.122.129:8002</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">M: 06d1a2d7cd21d9b43b115c222a34ebce6f007d77 192.168.122.129:8003</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">M: 9ac5a60f61197d364a3e4da1887ddbfb311145bd 192.168.122.129:8004</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">   replicates 6ab91146f6757f18beafd45b962489cab3d341f7</span><br><span class="line">M: f7c22c52f2ce2096f54429c48a8d4b7027f6d7b3 192.168.122.129:8005</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">   replicates e4f4d7176f11272f29c6a35fb47ae4078557c9ab</span><br><span class="line">M: e4c559c018adccc965171eaa4b19d1a51a4f025a 192.168.122.129:8006</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">   replicates 06d1a2d7cd21d9b43b115c222a34ebce6f007d77</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建集群成功之后，在每个redis01/redis02/….的目录下都会产生：<br><img src="https://img-blog.csdnimg.cn/20200812004453261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>第十六步 编写关闭脚本</strong><br>编写一个批量关闭的脚本<br><code>命令：vim shutdown.sh</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis01&#x2F;redis-cli -h 192.168.15.132 -p 8001 shutdown</span><br><span class="line">redis01&#x2F;redis-cli -h 192.168.15.132 -p 8002 shutdown</span><br><span class="line">redis01&#x2F;redis-cli -h 192.168.15.132 -p 8003 shutdown</span><br><span class="line">redis01&#x2F;redis-cli -h 192.168.15.132 -p 8004 shutdown</span><br><span class="line">redis01&#x2F;redis-cli -h 192.168.15.132 -p 8005 shutdown</span><br><span class="line">redis01&#x2F;redis-cli -h 192.168.15.132 -p 8006 shutdown</span><br></pre></td></tr></table></figure>
<p><code>分配权限chmod +x shutdown.sh</code></p>
<h3 id="2-3-测试集群"><a href="#2-3-测试集群" class="headerlink" title="2.3 测试集群"></a>2.3 测试集群</h3><p>测试 Redis 集群：可以连接集群中的任意一个节点进行测试 <strong>注意一定要有-c 参数</strong>，否则能连上，但是无法操作 redis 集群<br><code>命令： ./redis01/redis-cli -h 192.168.15.132 -p 8001 -c</code><br>注意：一定要加-c  不然会把你当作一个单机来处理。<br><img src="https://img-blog.csdnimg.cn/20200812005453117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记之消息中间件（RabbitMQ）的学习</title>
    <url>/2020/08/03/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%88RabbitMQ%EF%BC%89%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>本次的笔记整理的主要是在Linux下安装RabbitMQ，并且如果使用Java代码在IDEA中去使用RabbitMQ，如果对Linux不熟悉的话，请看我之前的笔记。</p>
<a href="/2020/07/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ALinux%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D%E3%80%81Xshell%E7%BB%88%E7%AB%AF%E7%9A%84%E5%AE%89%E8%A3%85/" title="Linux的学习（一）">Linux的学习（一）</a>
<a href="/2020/07/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ALinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/" title="Linux的学习（二）基本命令">Linux的学习（二）基本命令</a>
<a href="/2020/07/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLinux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E5%8D%A1%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E9%85%8D%E7%BD%AEJDK%E3%80%81%E4%BB%A5%E5%8F%8Atomcat%E7%9A%84%E5%AE%89%E8%A3%85/" title="Linux的学习（三）">Linux的学习（三）</a>

<p>本次演示的安装包版本为（centos 6.5）：<br>otp_src_22.0.tar.gz<br>rabbitmq-server-generic-unix-3.7.17.tar.xz<br>安装包的百度云链接：<a href="https://pan.baidu.com/s/1mw4bW6RLxFm4RoV-i9vB3A">https://pan.baidu.com/s/1mw4bW6RLxFm4RoV-i9vB3A</a><br>提取码：bnfy</p>
<h1 id="本文主要内容"><a href="#本文主要内容" class="headerlink" title="本文主要内容"></a>本文主要内容</h1><p><strong>主要内容</strong></p>
<ol>
<li>AMQP 简介</li>
<li>RabbitMQ 简介</li>
<li>RabbitMQ 原理</li>
<li>Erlang 安装</li>
<li>安装 RabbitMQ</li>
<li>RabbitMQ 账户管理</li>
<li>交换器</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200803162839321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="一、AMQP简介"><a href="#一、AMQP简介" class="headerlink" title="一、AMQP简介"></a>一、AMQP简介</h1><h2 id="1-AMQP-是什么"><a href="#1-AMQP-是什么" class="headerlink" title="1 AMQP 是什么?"></a>1 AMQP 是什么?</h2><p>AMQP(Advanced Message Queuing Protocol,高级消息队列协议)是进程之间传递异步消息的网络协议。</p>
<h2 id="2-AMQP-工作过程"><a href="#2-AMQP-工作过程" class="headerlink" title="2 AMQP 工作过程"></a>2 AMQP 工作过程</h2><p>发布者(Publisher)发布消息(Message),经过交换机(Exchange)，交换机根据路由规则将收到消息分发给交换机绑定的队列(Queue)，最后 AMQP 代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。<br><img src="https://img-blog.csdnimg.cn/20200803162959836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="3-队列"><a href="#3-队列" class="headerlink" title="3 队列"></a>3 队列</h2><p>队列是数据结构中概念。数据存储在一个队列中，数据是有顺序的，<strong>先进的先出，后进后出</strong>。其中一侧负责进数据，另一次负责出数据。<br>        <strong>MQ（消息队列）很多功能都是基于此队列结构实现的</strong><br><img src="https://img-blog.csdnimg.cn/20200803163052256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="二、RabbitMQ简介"><a href="#二、RabbitMQ简介" class="headerlink" title="二、RabbitMQ简介"></a>二、RabbitMQ简介</h1><h2 id="1-RabbitMQ-介绍"><a href="#1-RabbitMQ-介绍" class="headerlink" title="1 RabbitMQ 介绍"></a>1 RabbitMQ 介绍</h2><p>RabbitMQ 是由 Erlang 语言编写的基于 AMQP 的消息中间件。而消息中间件作为分布式系统重要组件之一，可以解决应用耦合，异步消息，流量削峰等问题。</p>
<p>同时符合当前互联网需求的高并发、大吞吐、多线程三个特点。所以它是一个特别重要的组件，特别是在分布式系统中，可以帮我们做一些解耦和、同步转异步、流量削峰等等。最核心的就是同步转异步。</p>
<h3 id="1-1-解决应用耦合"><a href="#1-1-解决应用耦合" class="headerlink" title="1.1 解决应用耦合"></a>1.1 解决应用耦合</h3><p><strong>1.1.1 不使用 MQ 时</strong><br><img src="https://img-blog.csdnimg.cn/20200803163237823.png" alt="在这里插入图片描述"></p>
<p><strong>1.1.2 使用 MQ 解决耦合</strong><br><img src="https://img-blog.csdnimg.cn/20200803163256114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>应用方式间接处理，类似于RPC远程调用一样，我们可以发现，不管是用RPC来写代码、或者是用RMI技术来写代码、还是用Dubbo技术来写代码，Provider和Consumer都是有关系的，他们的关系连接点是那个标准接口，而Provider和Consumer他们之间是有耦合度的，这个耦合度就在那个接口上，Provider没有实现接口的话，Consumer就不能去调用，Consumer没有去使用这个接口就找不到Provider。</p>
<h2 id="2-RabbitMQ-适用场景（同步–-gt-异步）"><a href="#2-RabbitMQ-适用场景（同步–-gt-异步）" class="headerlink" title="2 RabbitMQ 适用场景（同步–&gt;异步）"></a>2 RabbitMQ 适用场景（同步–&gt;异步）</h2><p> 排队算法、秒杀活动、消息分发、异步处理、数据同步、处理耗时任务（离线处理）、流量销峰等。</p>
<p><strong>举个例子：</strong><br>比如说怎么做流量削峰呢？首先可以将上面两张图中的A看做是淘宝，相当于页面显示，而应用程序B相当于数据处理，也就是做数据的增删改查的，比如到了双十一，客户在页面找商品，然后下订单，由于双十一很多客户买东西，也就是并发更多、这个时候的消费比平时是更强的、产生流水量也是更大的，假如下订单峰值达到几亿个数据，那这个时候的压力太大了，那么这个时候如果去做数据库的写操作，这么高的并发所用的反应时间就会很长，比如说这个时间是5-10S，那么一个用户点击下订单的时候，页面就白了，等5-10s客户可能就不停的刷新，这样体验感就变得很差，如果是加服务器数量的话，双十一过去之后就没那么多人买东西了，这个时候就造成资源的浪费了，在这种情况下就有了MQ给你解决这个问题，当还是有几亿个用户下订单的时候，A就会把数据封装起来放到MQ中，然后A就会和客户说（返回一个页面），订单下定成功了请稍后结算，下订单到回复给客户的这个时间可能就只有1s左右的时间，在用户思考或者等待的时间当中，B应用在不停的往数据库中录入数据，这样用户的体验感就会好很多。</p>
<p><strong>流量削峰其实就是将原来的同步等待的时间变成了异步，让用户不在一个空白的页面等待页面反应过来</strong></p>
<p><strong>再举个例子：我们最爱的抢红包</strong><br>比如说：100个人抢10个红包，发红包时100个人一起点击红包去抢，100个客户端中找出手最快的10个人，于是先将消息放入到MQ当中，由于MQ中使用的是队列，特点是先进先出，将这100个请求放到队列当中，消费端将前十个处理掉，剩下90个就返回回去通知手慢了。</p>
<p><strong>只要是想要将同步处理转为异步处理，都可以考虑MQ，整体来说就是并发的并行转成并发的串行，变成一个排队的机制。串行的话Consumer是可以集群的，所以速度不会变低。</strong></p>
<h1 id="三、-RabbitMQ-原理"><a href="#三、-RabbitMQ-原理" class="headerlink" title="三、 RabbitMQ 原理"></a>三、 RabbitMQ 原理</h1><p><img src="https://img-blog.csdnimg.cn/2020080316430276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200803164354448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200803164410580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200803164434188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200803164458793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200803164530202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200803164551889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="四、-Erlang-安装"><a href="#四、-Erlang-安装" class="headerlink" title="四、 Erlang 安装"></a>四、 Erlang 安装</h1><p> RabbitMQ 是使用 Erlang 语言编写的，所以需要先配置 Erlang<br>本次时在Linux下安装otp_src_22.0.tar.gz</p>
<p>前提准备：</p>
<h2 id="1-修改主机名"><a href="#1-修改主机名" class="headerlink" title="1 修改主机名"></a>1 修改主机名</h2><p>RabbitMQ 是通过主机名进行访问的，必须指定能访问的主机名。我这里将主机名改为了oldou-mq<br>使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;network</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200803165342957.png" alt="在这里插入图片描述"><br><strong>修改hosts：</strong><br>使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;hosts</span><br><span class="line">        新添加了一行，前面为服务器 ip，空格后面添加计算机主机名</span><br></pre></td></tr></table></figure>
<p><strong>注意：我这里的192.168.15.132是我的linux的IP地址，到时候填自己的IP地址就行了</strong><br><img src="https://img-blog.csdnimg.cn/20200803165438843.png" alt="在这里插入图片描述"><br>修改好以上两个就可以进行下一步了。</p>
<h2 id="2-安装依赖"><a href="#2-安装依赖" class="headerlink" title="2 安装依赖"></a>2 安装依赖</h2><p>执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC unixODBC-devel</span><br></pre></td></tr></table></figure>
<h2 id="3-上传文件并解压"><a href="#3-上传文件并解压" class="headerlink" title="3 上传文件并解压"></a>3 上传文件并解压</h2><p>我在root目录下创建了一个temp目录，专门用于上传文件。<br>这里我使用的是lrzsz上传的文件，如果不会使用这个就去目录出查看我之前的笔记。</p>
<p>上传 otp_src_22.0.tar.gz 到/root/temp 目录中，进入目录并解压。<br>解压时注意，此压缩包不具有 gzip 属性，解压参数没有 z，只有 xf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;root&#x2F;temp    到temp目录下</span><br><span class="line">rz    使用rz命令进行上传，这里我之前安装了lrzsz</span><br><span class="line">tar -xf otp_src_22.0.tar.gz     进行解压</span><br></pre></td></tr></table></figure>
<h2 id="4-配置参数"><a href="#4-配置参数" class="headerlink" title="4 配置参数"></a>4 配置参数</h2><p>(1)先新建/usr/local/erlang 文件夹，作为安装文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;erlang</span><br></pre></td></tr></table></figure>
<p>(2)进入解压后的文件夹中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd otp_src_22.0</span><br></pre></td></tr></table></figure>
<p>配置参数(直接复制执行)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;erlang --with-ssl --enable-threads --enable-smp-support --enable-kernel-poll --enable-hipe --without-javac</span><br></pre></td></tr></table></figure>
<p>以上配置的解释，<br>–prefix=/usr/local/erlang    这个是配置安装目录；<br>–with-ssl    这个是要不要提供加密；<br>–enable-threads    这个是开启多线程并发处理；<br>–enable-smp-support    这个是提供smp协议支持信息；<br>–enable-kernel-poll    这个是提供内核池处理能力，因为它使用了操作系统内核线程池，所以erlang在做高并发处理、多线程处理时才那么快；<br>–enable-hipe   这个是开启XX模式<br>–without-javac   这个是不提供javac的编译处理能力；</p>
<h2 id="5-编译并安装"><a href="#5-编译并安装" class="headerlink" title="5 编译并安装"></a>5 编译并安装</h2><p>在解压后的文件目录下，直接使用以下命令编译并运行。<br>时间可能会比较长，要耐心等待。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>安装成功之后是下图所示：<br><img src="https://img-blog.csdnimg.cn/20200803170509223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>之后可以进入到安装目录中查看，<strong>cd /usr/local/erlang/</strong>   使用ls命令查看安装目录，然后在进入到bin目录下可以看到全是可执行文件。<br><img src="https://img-blog.csdnimg.cn/20200803170537714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>退回到erlang目录下，执行bin/erl -version查看版本信息。<br><img src="https://img-blog.csdnimg.cn/20200803170602162.png" alt="在这里插入图片描述"><br>当你看到以上的版本号的时候就说明erlang安装成功了。<br>接下来去配置环境变量，让erlang可以在任意位置执行。</p>
<h2 id="6-修改环境变量"><a href="#6-修改环境变量" class="headerlink" title="6 修改环境变量"></a>6 修改环境变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1)修改&#x2F;etc&#x2F;profile 文件</span><br><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line">        </span><br><span class="line">(2)在文件中添加下面代码</span><br><span class="line">export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;erlang&#x2F;bin</span><br><span class="line"></span><br><span class="line">(3)运行文件，让修改内容生效</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<h2 id="7-查看配置是否成功"><a href="#7-查看配置是否成功" class="headerlink" title="7 查看配置是否成功"></a>7 查看配置是否成功</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">erl -version</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200803170759782.png" alt="在这里插入图片描述"><br>这个时候你不用在erlang的bin目录下也能执行erlang的一些文件命令了。</p>
<h1 id="五、-安装RabbitMQ"><a href="#五、-安装RabbitMQ" class="headerlink" title="五、 安装RabbitMQ"></a>五、 安装RabbitMQ</h1><p>本次安装的RabbitMQ的版本为：rabbitmq-server-generic-unix-3.7.17.tar.xz</p>
<h2 id="1-上传文件并解压"><a href="#1-上传文件并解压" class="headerlink" title="1 上传文件并解压"></a>1 上传文件并解压</h2><p>上传 rabbitmq-server-generic-unix-3.7.17.tar.xz 到/root/temp 中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;root&#x2F;temp</span><br><span class="line">tar -xf rabbitmq-server-generic-unix-3.7.17.tar.xz</span><br></pre></td></tr></table></figure>
<h2 id="2-将解压后的文件移动到-local-下"><a href="#2-将解压后的文件移动到-local-下" class="headerlink" title="2 将解压后的文件移动到 local 下"></a>2 将解压后的文件移动到 local 下</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv rabbitmq_server-3.7.17&#x2F; &#x2F;usr&#x2F;local&#x2F;rabbitmq</span><br></pre></td></tr></table></figure>
<h2 id="3-配置环境变量"><a href="#3-配置环境变量" class="headerlink" title="3 配置环境变量"></a>3 配置环境变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">在文件中添加</span><br><span class="line">export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;rabbitmq&#x2F;sbin</span><br><span class="line"></span><br><span class="line">解析文件</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h2 id="4-开启-web-管理插件"><a href="#4-开启-web-管理插件" class="headerlink" title="4 开启 web 管理插件"></a>4 开启 web 管理插件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进入 rabbitmq&#x2F;sbin 目录</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;rabbitmq&#x2F;sbin</span><br><span class="line"></span><br><span class="line">查看插件列表</span><br><span class="line">.&#x2F;rabbitmq-plugins list</span><br><span class="line"></span><br><span class="line">生效管理插件</span><br><span class="line">.&#x2F;rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200803171300534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>插件安装成功之后，在rabbitMQ的安装目录下的etc目录下可以查看到以下内容：<br><img src="https://img-blog.csdnimg.cn/20200803171328613.png" alt="在这里插入图片描述"></p>
<h2 id="5-后台运行RabbitMQ"><a href="#5-后台运行RabbitMQ" class="headerlink" title="5 后台运行RabbitMQ"></a>5 后台运行RabbitMQ</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 启动 rabbitmq。</span><br><span class="line"> .&#x2F;rabbitmq-server -detached</span><br><span class="line"></span><br><span class="line">停止命令     .&#x2F;rabbitmqctl stop_app</span><br><span class="line">如果无法停止，使用 kill -9 进程号进行关闭 </span><br><span class="line">使用这个命令查看进程    ps aux|grep rabbitmq       </span><br><span class="line">然后在使用 keil -9 进程号  杀掉进程就OK了</span><br></pre></td></tr></table></figure>
<p><strong>举个例子：</strong><br><img src="https://img-blog.csdnimg.cn/20200803171730598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>启动成功信息如下（两张图）</strong>：<br><img src="https://img-blog.csdnimg.cn/2020080317180351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200803171826364.png" alt="在这里插入图片描述"></p>
<h3 id="5-1-启动错误解决"><a href="#5-1-启动错误解决" class="headerlink" title="5.1 启动错误解决"></a>5.1 启动错误解决</h3><p>如果启动 RabbitMQ 发生下述错误，可以提供环境配置文件，解决。环境配置文件命名为: rabbitmq-env.conf。所在位置是： $rabbitmq_home/etc/rabbitmq/目录。内容是： HOSTNAME=主机名称<br><img src="https://img-blog.csdnimg.cn/20200803171945850.png" alt="在这里插入图片描述"><br>在rabbitmq/etc/rabbitmq的安装目录下vim rabbitmq-env.conf<br>添加内容如下所示：<br>HOSTNAME=oldou-mq</p>
<p><strong>注意：这里的oldou-mq是我之前配置的主机名称</strong></p>
<h2 id="6-查看-web-管理界面"><a href="#6-查看-web-管理界面" class="headerlink" title="6 查看 web 管理界面"></a>6 查看 web 管理界面</h2><p>默认可以在安装 rabbitmq 的电脑上通过用户名：guest 密码 guest 进行访问 web 管理界面<br>        端口号：15672（放行端口，或关闭防火墙）<br>        在虚拟机浏览器中输入：<br>         <a href="http://ip:15672/">http://ip:15672</a></p>
<p>启动成功之后，在关闭防火墙的前提下，去浏览器输入linux的主机IP和端口好就能进行访问。<br><img src="https://img-blog.csdnimg.cn/20200803172225492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="六、-RabbitMQ-账户管理"><a href="#六、-RabbitMQ-账户管理" class="headerlink" title="六、 RabbitMQ 账户管理"></a>六、 RabbitMQ 账户管理</h1><h2 id="1-创建账户"><a href="#1-创建账户" class="headerlink" title="1 创建账户"></a>1 创建账户</h2><pre><code>    先进入到sbin目录下：  cd /usr/local/rabbitmq/sbin
    语法：
    ./rabbitmqctl add_user username password</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200803172314644.png" alt="在这里插入图片描述"><br>创建完之后的用户默认是没有权限的。</p>
<h2 id="2-给用户授予管理员角色"><a href="#2-给用户授予管理员角色" class="headerlink" title="2 给用户授予管理员角色"></a>2 给用户授予管理员角色</h2><p> 其中 smallming 为新建用户的用户名<br>**./rabbitmqctl set_user_tags admin administrator**<br><img src="https://img-blog.csdnimg.cn/20200803172415966.png" alt="在这里插入图片描述"></p>
<h2 id="3-给用户授权"><a href="#3-给用户授权" class="headerlink" title="3 给用户授权"></a>3 给用户授权</h2><pre><code>    “/” 表示 RabbitMQ 根虚拟主机
    admin 表示用户名
    &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; 表示完整权限
    ./rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020080317243722.png" alt="在这里插入图片描述"></p>
<h2 id="4-登录"><a href="#4-登录" class="headerlink" title="4 登录"></a>4 登录</h2><p>使用新建账户和密码在 windows 中访问 rabbitmq 并登录<br>在浏览器地址栏输入：<br>                <a href="http://ip:15672/">http://ip:15672/</a><br>用户名：oldou<br>密码：oldou<br>这样就能登录进去了。<br><img src="https://img-blog.csdnimg.cn/2020080317252076.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="七、-Exchange-交换器（交换机）"><a href="#七、-Exchange-交换器（交换机）" class="headerlink" title="七、 Exchange 交换器（交换机）"></a>七、 Exchange 交换器（交换机）</h1><p>交换器负责接收客户端传递过来的消息，并转发到对应的队列中。在 RabbitMQ 中支持四种交换器</p>
<p><strong>1. Direct Exchange：直连交换器（默认）<br>2. Fanout Exchange：扇形交换器<br>3. Topic Exchange：主题交换器</strong><br>4. Header Exchange：首部交换器。</p>
<p>在 RabbitMq 的 Web 管理界面中 Exchanges 选项卡就可以看见这四个交换器。<br><img src="https://img-blog.csdnimg.cn/20200803172652702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="1-direct-交换器（点对点）"><a href="#1-direct-交换器（点对点）" class="headerlink" title="1 direct 交换器（点对点）"></a>1 direct 交换器（点对点）</h2><p><img src="https://img-blog.csdnimg.cn/20200803172716915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>direct 交换器是 RabbitMQ 默认交换器。默认会进行公平调度。所有接受者依次从消息队列中获取值。Publisher 给哪个队列发消息，就一定是给哪个队列发送消息。对交换器绑定的其他队列没有任何影响。<br>        （代码演示）一个队列需要绑定多个消费者<br>        需要使用注解/API：<br>                org.springframework.amqp.core.Queue:队列<br>                AmqpTemplate：操作 RabbitMQ 的接口。负责发送或接收消息<br>                @RabbitListener(queues = “”) 注解某个方法为接收消息方法</p>
<p>接下来我们便使用代码来实现。</p>
<h3 id="1-1-代码实现"><a href="#1-1-代码实现" class="headerlink" title="1.1 代码实现"></a>1.1 代码实现</h3><h4 id="1-1-1-新建项目（01rabbirMQdirect）"><a href="#1-1-1-新建项目（01rabbirMQdirect）" class="headerlink" title="1.1.1 新建项目（01rabbirMQdirect）"></a>1.1.1 新建项目（01rabbirMQdirect）</h4><p>测试项目结构为：<br><img src="https://img-blog.csdnimg.cn/20200803173021902.png" alt="在这里插入图片描述"></p>
<p><strong>1.1.1.1  添加父pom依赖</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.oldou&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;01rabbirMQ-direct&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;&#x2F;packaging&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;amqp-rabbit-consumer&lt;&#x2F;module&gt;</span><br><span class="line">    &lt;&#x2F;modules&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--添加依赖管理项--&gt;</span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.2.5.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;&#x2F;dependencies&gt;</span><br><span class="line">    &lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--SpringBoot提供的关于AMQP协议实现的启动器，可以使用AMQP协议快速访问MQ消息中间件--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>
<p>然后在该项目下新建一个Model—- amqp-rabbit-consumer<br>然后在该文件下新建一个类InfoLogConsumer<br><strong>1.1.1.2  编写消息类</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.rabbit.consumer;</span><br><span class="line"></span><br><span class="line">import org.springframework.amqp.rabbit.annotation.*;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 日志消息消费者，只消费 Info 日志</span><br><span class="line"> * 日志消息存储在队列中 log-info-queue</span><br><span class="line"> * 使用的交换器名称为 log-ex-direct</span><br><span class="line"> * 交换器类型是 direct</span><br><span class="line"> * 队列的路由键是 direct-rk-info</span><br><span class="line"> *</span><br><span class="line"> * 注解 @RabbitListener - 监听注释。可以描述类型和方法</span><br><span class="line"> *  类型 - 当前类型监听某个队列</span><br><span class="line"> *  方法 - 当前方法监听某个队列</span><br><span class="line"> *  属性 -</span><br><span class="line"> *      bindings - QueueBinding[] 类型，代表这个类或者方法监听的队列、交换器、路由键的绑定方式。</span><br><span class="line"> *</span><br><span class="line"> * 注解 @QueueBinding</span><br><span class="line"> *  属性 -</span><br><span class="line"> *      value - 绑定监听的队列是什么</span><br><span class="line"> *      exchange - 队列对应的交换器是什么</span><br><span class="line"> *      key - 队列的路由键是什么</span><br><span class="line"> *  注解 -</span><br><span class="line"> *    @Queue - 描述一个队列</span><br><span class="line"> *      属性 -</span><br><span class="line"> *          value|name - 队列名称</span><br><span class="line"> *          autoDelete - 是否自动删除，默认为&quot;&quot;，</span><br><span class="line"> *              如果队列名称定义，不自动删除；队列名称不定义，队列为自动删除队列</span><br><span class="line"> *              如果是自动删除，代表的所有的consumer关闭后，队列自动删除。</span><br><span class="line"> *    @Exchange - 描述一个交换器</span><br><span class="line"> *      属性 -</span><br><span class="line"> *          value|name - 交换器名称</span><br><span class="line"> *          autoDelete - 是否自动删除，默认为&quot;&quot;,就是自动删除，可选false，非自动删除</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RabbitListener(bindings &#x3D; &#123;</span><br><span class="line">    @QueueBinding(</span><br><span class="line">        value &#x3D; @Queue(value &#x3D; &quot;log-info-queue&quot;,autoDelete &#x3D; &quot;false&quot;),</span><br><span class="line">        exchange &#x3D; @Exchange(value &#x3D; &quot;log-ex-direct&quot;,type &#x3D; &quot;direct&quot;,autoDelete &#x3D; &quot;false&quot;),</span><br><span class="line">        key &#x3D; &quot;direct-rk-info&quot;</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br><span class="line">@Component</span><br><span class="line">public class InfoLogConsumer &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 消息消费的方法。当队列log-inf-queue中出现消息，立即消费。</span><br><span class="line">     * @param msg 消息内容</span><br><span class="line">     *</span><br><span class="line">     *  注解 @RabbitHandler - 配合类型上的@RabbitListener注解</span><br><span class="line">     *     作用：标记当前的方法是一个监听消息队列，消费消息的方法。</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RabbitHandler()</span><br><span class="line">    public void onMessage(String msg)&#123;</span><br><span class="line">        System.out.println(&quot;InfoLogConsumer 消费消息 &quot;+ msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1.1.1.3  编写配置文件</strong><br>新建 application.yml.<br>我们如果不配置这个文件的话，以下就为默认值：<br>host:默认值 localhost<br>username 默认值：guest<br>password 默认值：guest<br>配置文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 192.168.15.132  # RabbitMQ服务的地址，默认localhost</span><br><span class="line">    post: 5672  #RabbitMQ的端口，默认是5672 注意：5672是TCP协议的端口，15672是http协议的端口</span><br><span class="line">    username: oldou  #访问RabbitMQ的用户名，默认是guest</span><br><span class="line">    password: oldou  #访问RabbitMQ的密码，默认是guest</span><br><span class="line">    virtual-host: &#x2F;  #访问RabbitMQ的哪一个虚拟主机，默认为 &#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：配置文件的名字必须要是application.yml，如果名称写错，那么访问的时候就一直时localhost。</p>
<p><strong>编写消息的启动类：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class RabbitConsumerApp &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(RabbitConsumerApp.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>书写好之后，在Linux启动RabbitMQ的前提下，首先在浏览器访问192.168.15.132:15672，并且登录用户进入管理界面，然后在IDEA中启动消息的启动类。这个时候控制台的输出中就有一个本机的端口，在管理界面中刷新，可以看见该端口。<br><img src="https://img-blog.csdnimg.cn/20200803173349625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>我们也可以使用另外一种方式来书写消息类：<br>在消息类的同一个包下新建一个类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  日志消息消费者，消费 error和 warn 日志</span><br><span class="line"> *  error日志消息存储在队列中 log-error-queue</span><br><span class="line"> *  warn日志消息存储在队列中 log-warn-queue</span><br><span class="line"> *  使用的交换器名称为 log-ex-direct</span><br><span class="line"> *  交换器类型是 direct</span><br><span class="line"> *  队列的路由键是 direct-rk-error</span><br><span class="line"> *  队列的路由键是 direct-rk-warn</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component    &#x2F;&#x2F;加这个注解表示让Spring容器做一下加载</span><br><span class="line">public class LogConsumer &#123;</span><br><span class="line">    @RabbitListener(bindings &#x3D; &#123;</span><br><span class="line">         @QueueBinding(</span><br><span class="line">             value &#x3D; @Queue(value &#x3D; &quot;log-error-queue&quot;),</span><br><span class="line">             exchange &#x3D; @Exchange(value &#x3D; &quot;log-ex-direct&quot;),</span><br><span class="line">             key &#x3D; &quot;direct-rk-error&quot;</span><br><span class="line">         )</span><br><span class="line">    &#125;)</span><br><span class="line">    public void onLogErrorMessage(String msg)&#123;</span><br><span class="line">        System.out.println(&quot;错误日志信息： &quot; + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(bindings &#x3D; &#123;</span><br><span class="line">         @QueueBinding(</span><br><span class="line">             value &#x3D; @Queue(value &#x3D; &quot;log-warn-queue&quot;,autoDelete &#x3D; &quot;false&quot;),</span><br><span class="line">             exchange &#x3D; @Exchange(value &#x3D; &quot;log-ex-direct&quot;),</span><br><span class="line">             key&#x3D;&quot;direct-rk-warn&quot;</span><br><span class="line">         )</span><br><span class="line">    &#125;)</span><br><span class="line">    public void onLogWarnMessage(String msg)&#123;</span><br><span class="line">        System.out.println(&quot;警告日志信息 &quot;+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新启动以下启动类然后刷新一下网页可以看见：<br><img src="https://img-blog.csdnimg.cn/20200803173526227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>1.1.1.4  编写生产者（消息生产者）</strong><br>首先在父工程下新建一个Model，名为（amqp-rabbit-publisher），然后在该工程下编写消息的发送类：LogMessageSender</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.rabbit.sender;</span><br><span class="line"></span><br><span class="line">import org.springframework.amqp.core.AmqpTemplate;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 发送消息的类型。</span><br><span class="line"> * 把消息发送到RabbitMQ中。</span><br><span class="line"> * 在spring-boot-starter-amqp中，启动器会自动创建并初始化一个AmqpTemplate，</span><br><span class="line"> * 作为访问Amqp消息服务器（MQ中间件）的客户端对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">public class LogMessageSender &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AmqpTemplate template;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发送消息的方法</span><br><span class="line">     * template.convertAndSend(String exchange,String rountingKey,Object message);</span><br><span class="line">     * exchange - 交换器名称</span><br><span class="line">     * rountingKey - 路由器</span><br><span class="line">     * message - 要发送的消息内容，就是传递的消息对象的消息体</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void sendMessage(String exchange,String rountingKey,String message)&#123;</span><br><span class="line">        this.template.convertAndSend(exchange,rountingKey,message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后编写一个启动类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class RabbitPublisherApp &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(RabbitPublisherApp.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再然后编写一个测试类如1.1.1.5：<br>编写配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 192.168.15.132  # RabbitMQ服务的地址，默认localhost</span><br><span class="line">    username: oldou  #访问RabbitMQ的用户名，默认是guest</span><br><span class="line">    password: oldou  #访问RabbitMQ的密码，默认是guest</span><br></pre></td></tr></table></figure>
<p> <strong>1.1.1.5编写测试类</strong><br>SpringBoot 整合 Spring-AMQP 后包含内置对象 AmqpTemplate</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com;</span><br><span class="line"></span><br><span class="line">import com.rabbit.sender.LogMessageSender;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 消息发送者测试类型</span><br><span class="line"> *&#x2F;</span><br><span class="line">@SpringBootTest(classes &#x3D; RabbitPublisherApp.class)</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class TestPublisher &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private LogMessageSender sender;</span><br><span class="line"></span><br><span class="line">    private String exchange &#x3D; &quot;log-ex-direct&quot;;</span><br><span class="line">    private String rkInfo &#x3D; &quot;direct-rk-info&quot;;</span><br><span class="line">    private String rkError &#x3D; &quot;direct-rk-error&quot;;</span><br><span class="line">    private String rkWarn &#x3D; &quot;direct-rk-warn&quot;;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testSend()&#123;</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        &#x2F;&#x2F;发送10条消息</span><br><span class="line">        for(int i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;rInt%3 - 0 ：表示投递消息到Info; 1 表示投递消息到error; 2表示投递消息到warn</span><br><span class="line">            int rInt &#x3D; r.nextInt(10);</span><br><span class="line">            if(rInt%3 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                this.sender.sendMessage(exchange,rkInfo,&quot;发送Info日志消息 - index &#x3D; &quot;+ i + &quot;; rInt &quot;+rInt);</span><br><span class="line">            &#125;else if(rInt%3 &#x3D;&#x3D; 1)&#123;</span><br><span class="line">                this.sender.sendMessage(exchange,rkError,&quot;发送Error日志消息 - index &#x3D; &quot;+ i + &quot;; rInt &quot;+rInt);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                this.sender.sendMessage(exchange,rkWarn,&quot;发送Warn日志消息 - index &#x3D; &quot;+ i + &quot;; rInt &quot;+rInt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先启动消费者consumer，然后在进入到消息的消费者测试类中启动，这个时候就可以看见消费者拿到消息，控制台输出如下：<br><img src="https://img-blog.csdnimg.cn/20200803173844110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>以上输出的信息为什么没有按照index=1/2/3/4/5…这样的顺序来输出呢？原因是因为处理的效率不一样，效率低的自然就处理时间长一点，因为输出就是这样。</p>
<h2 id="2-fanout-交换器（广播）"><a href="#2-fanout-交换器（广播）" class="headerlink" title="2 fanout 交换器（广播）"></a>2 fanout 交换器（广播）</h2><p><img src="https://img-blog.csdnimg.cn/20200803173916321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>扇形交换器，实际上做的事情就是广播，fanout 会把消息发送给所有的绑定在当前交换器上的队列。<strong>对应 Consumer 依然采用公平调度方式</strong>。<br>        （代码演示）一个交换器需要绑定多个队列<br>        需要使用注解/API：<br>        FanoutExchange：fanout 交换器<br>        Binding：绑定交换器和队列<br>        BindingBuilder：Binding 的构建器<br>        amq.fanout:内置 fanout 交换器名称</p>
<h3 id="2-1-代码"><a href="#2-1-代码" class="headerlink" title="2.1 代码"></a>2.1 代码</h3><p>新建pojo工程，User类，在里面添加get/set方法、无参/带参构造、equals/hashcode、toString方法</p>
<p>项目总体结构如下：<br><img src="https://img-blog.csdnimg.cn/20200803174026786.png" alt="在这里插入图片描述"><br><strong>2.1.1 Publisher</strong><br>新建一个工程02rabbitMQfanout，然后新建一个消费者FanoutConsumer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 广播交换器，消费者</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">public class FanoutConsumer &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 消费消息的方法</span><br><span class="line">     * @param user 消息体内容</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RabbitListener(bindings &#x3D; &#123;</span><br><span class="line">            @QueueBinding(</span><br><span class="line">                    value &#x3D; @Queue(value &#x3D; &quot;queue-user-1&quot;,autoDelete &#x3D; &quot;false&quot;),</span><br><span class="line">                    exchange &#x3D; @Exchange(value &#x3D; &quot;ex-fanout&quot;,type &#x3D; &quot;fanout&quot;,autoDelete &#x3D; &quot;false&quot;)</span><br><span class="line">            )</span><br><span class="line">    &#125;)</span><br><span class="line">    public void onMessage(User user)&#123;</span><br><span class="line">        System.out.println(&quot;onMessage run : &quot; + user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 消费消息的方法</span><br><span class="line">     * @param user 消息体内容</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RabbitListener(bindings &#x3D; &#123;</span><br><span class="line">            @QueueBinding(</span><br><span class="line">                    value &#x3D; @Queue(value &#x3D; &quot;queue-user-2&quot;,autoDelete &#x3D; &quot;false&quot;),</span><br><span class="line">                    exchange &#x3D; @Exchange(value &#x3D; &quot;ex-fanout&quot;,type &#x3D; &quot;fanout&quot;)</span><br><span class="line">            )</span><br><span class="line">    &#125;)</span><br><span class="line">    public void onMessage2(User user)&#123;</span><br><span class="line">        System.out.println(&quot;onMessage run : &quot; + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后编写配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 192.168.15.132</span><br><span class="line">    username: oldou</span><br><span class="line">    password: oldou</span><br></pre></td></tr></table></figure>
<p>Pom文件中的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;02rabbitMQfanout&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.bjsxt&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;consumer&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;artifactId&gt;pojo&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;com.bjsxt&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>
<p>编写测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class RabbitConsumer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(RabbitConsumer.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动之后可以在管理平台上看见，接下来便是去书写发送者。</p>
<p><strong>2.1.2 编写发送方法</strong><br>发送者代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.rabbit;</span><br><span class="line"></span><br><span class="line">import com.entity.User;</span><br><span class="line">import org.springframework.amqp.core.AmqpTemplate;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 发送消息类型，消息发送到fanout交换器中</span><br><span class="line"> * 交换器名称是：ex-fanout</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">public class UserMessageSender &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AmqpTemplate template;</span><br><span class="line"></span><br><span class="line">    public void send(User user)&#123;</span><br><span class="line">        this.template.convertAndSend(&quot;ex-fanout&quot;,&quot;&quot;,user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class RabbitSender &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(RabbitSender.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 192.168.15.132</span><br><span class="line">    username: oldou</span><br><span class="line">    password: oldou</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com;</span><br><span class="line"></span><br><span class="line">import com.entity.User;</span><br><span class="line">import com.rabbit.UserMessageSender;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 消息发送者测试类型</span><br><span class="line"> *&#x2F;</span><br><span class="line">@SpringBootTest(classes &#x3D; RabbitSender.class)</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class TestPublisher &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMessageSender sender;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testSendUserMessageToFanout()&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;3;i++)&#123;</span><br><span class="line">            User user &#x3D; new User();</span><br><span class="line">            user.setId((long)i);</span><br><span class="line">            user.setName(&quot;姓名 - &quot; + i);</span><br><span class="line">            user.setAge(20 + i);</span><br><span class="line">            this.sender.send(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pom文件：<br>···<br><?xml version="1.0" encoding="UTF-8"?><br><project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"><br>    <parent><br>        <artifactId>02rabbitMQfanout</artifactId><br>        <groupId>com.bjsxt</groupId><br>        <version>1.0-SNAPSHOT</version><br>    </parent><br>    <modelVersion>4.0.0</modelVersion></p>
<pre><code>&lt;artifactId&gt;publisher&lt;/artifactId&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;artifactId&gt;pojo&lt;/artifactId&gt;
        &lt;groupId&gt;com.bjsxt&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</project>
···

<p>运行消息生产者，结果如下：<br><img src="https://img-blog.csdnimg.cn/20200803174429956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>交换器把消息投入到两个队列当中，先进先出，那么两个Consumer消费消息的时候都是按照顺序依次消费，处理数据的时候是一起运行的，因为代码环境硬件都是一样的，而System.out.println是有缓存Buffer的，所以偶尔会有那么一两次是交叉输出的。</p>
<h2 id="3-topic-交换器-主题交换"><a href="#3-topic-交换器-主题交换" class="headerlink" title="3 topic 交换器(主题交换)"></a>3 topic 交换器(主题交换)</h2><p>它是最常用的交换器，也是功能最完整、功能最全的一种交换器，它能够实现点到点、点到面、点到部分的数据传输。<br><img src="https://img-blog.csdnimg.cn/20200803180700932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>允许在路由键（RoutingKey）中出现匹配规则。<br>路由键的写法和包写法相同。com.bjsxt.xxxx.xxx 格式。<br>在绑定时可以带有下面特殊符号，中间可以出现:<br>        * : 代表一个单词（两个.之间内容）<br>        # : 0 个或多个字符<br>接收方依然是公平调度，同一个队列中内容轮换获取值。<br>需要使用注解/API：<br>TopicExchange：Topic 交换器<br>amq.topic:内置 topic 交换器名称</p>
<h3 id="3-1-代码实现"><a href="#3-1-代码实现" class="headerlink" title="3.1 代码实现"></a>3.1 代码实现</h3><p>项目结构为：<br><img src="https://img-blog.csdnimg.cn/20200803180749575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>3.1.1 Publisher</strong><br>首先新建一个子项目model—-topicPublisher<br>书写一段发送消息的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.rabbit;</span><br><span class="line"></span><br><span class="line">import org.springframework.amqp.core.AmqpTemplate;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 发送消息到主题交换器</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">public class TopicSender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发送消息的方法</span><br><span class="line">     * @param exchange</span><br><span class="line">     * @param rountingKey</span><br><span class="line">     * @param message</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void send(String exchange,String rountingKey,String message)&#123;</span><br><span class="line">        amqpTemplate.convertAndSend(exchange,rountingKey,message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后书写启动类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class TopicRabbitMQSenderApp &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(TopicRabbitMQSenderApp.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>书写测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com;</span><br><span class="line"></span><br><span class="line">import com.rabbit.TopicSender;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 消息发送者测试类型</span><br><span class="line"> *&#x2F;</span><br><span class="line">@SpringBootTest(classes &#x3D; TopicRabbitMQSenderApp.class)</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class TestTopicSender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TopicSender topicSender1;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testSendMessageToTopic()&#123;</span><br><span class="line">        &#x2F;&#x2F;随机数%6</span><br><span class="line">        &#x2F;&#x2F; 0 rk - user.rk.sms       *.rk.*   *.rk.sms</span><br><span class="line">        &#x2F;&#x2F; 1 rk - user.rk.email     *.rk.*   *.rk.email</span><br><span class="line">        &#x2F;&#x2F; 2 rk - order.rk.sms      *.rk.*   *.rk.sms</span><br><span class="line">        &#x2F;&#x2F; 3 rk - order.rk.email    *.rk.*   *.rk.email</span><br><span class="line">        &#x2F;&#x2F; 4 rk - reg.rk.sms        *.rk.*   *.rk.sms</span><br><span class="line">        &#x2F;&#x2F; 5 rk - reg.rk.qq         *.rk.*</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">            int rInt &#x3D; r.nextInt(100);</span><br><span class="line">            if(rInt%6 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                this.topicSender1.send(&quot;ex-topic&quot;,&quot;user.rk.sms&quot;,&quot;用户登录验证码是123456 - 发送短信&quot;);</span><br><span class="line">            &#125;else if(rInt%6 &#x3D;&#x3D; 1)&#123;</span><br><span class="line">                this.topicSender1.send(&quot;ex-topic&quot;,&quot;user.rk.email&quot;,&quot;用户登录验证码是123456 - 发送到邮箱&quot;);</span><br><span class="line">            &#125;else if(rInt%6 &#x3D;&#x3D; 2)&#123;</span><br><span class="line">                this.topicSender1.send(&quot;ex-topic&quot;,&quot;order.rk.sms&quot;,&quot;订单下订成功 - 发送短信&quot;);</span><br><span class="line">            &#125;else if(rInt%6 &#x3D;&#x3D; 3)&#123;</span><br><span class="line">                this.topicSender1.send(&quot;ex-topic&quot;,&quot;order.rk.email&quot;,&quot;订单下订成功 - 发送到邮箱&quot;);</span><br><span class="line">            &#125;else if(rInt%6 &#x3D;&#x3D; 4)&#123;</span><br><span class="line">                this.topicSender1.send(&quot;ex-topic&quot;,&quot;reg.rk.sms&quot;,&quot;用户注册验证码是123456 - 发送短信&quot;);</span><br><span class="line">            &#125;else if(rInt%6 &#x3D;&#x3D; 5)&#123;</span><br><span class="line">                this.topicSender1.send(&quot;ex-topic&quot;,&quot;reg.rk.qq&quot;,&quot;用户注册验证码是123456 - 发送到QQ&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 192.168.15.132</span><br><span class="line">    username: oldou</span><br><span class="line">    password: oldou</span><br></pre></td></tr></table></figure>
<p><strong>3.1.2 Consumer</strong><br>新建一个子项目topicConsumer，书写消费消息的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.rabbit;</span><br><span class="line"></span><br><span class="line">import org.springframework.amqp.rabbit.annotation.Exchange;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.Queue;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.QueueBinding;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 主题消息消费者</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">public class TopicConsumer &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 短信消息消费者,对应的rountingKey是user.rk.sms | order.rk.sms | reg.rk.sms等</span><br><span class="line">     * 分别代表 - 用户登录短信 | 订单下订成功通知短信 | 支付成功通知短信 | 注册码通知短信 等。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RabbitListener(bindings &#x3D; &#123;</span><br><span class="line">            @QueueBinding(</span><br><span class="line">                    value &#x3D; @Queue(value &#x3D; &quot;queue-sms-topic&quot;,autoDelete &#x3D; &quot;false&quot;),</span><br><span class="line">                    exchange &#x3D; @Exchange(value &#x3D; &quot;ex-topic&quot;,type &#x3D; &quot;topic&quot;),</span><br><span class="line">                    key &#x3D; &quot;*.rk.sms&quot;</span><br><span class="line">            )</span><br><span class="line">    &#125;)</span><br><span class="line">    public void onUserSMSMessage(String message)&#123;</span><br><span class="line">        System.out.println(&quot;用户短信消息内容是： &quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 路由键包括： user.rk.email | reg.rk.email | pay.rk.email 等</span><br><span class="line">     * @param message</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RabbitListener(bindings &#x3D; &#123;</span><br><span class="line">            @QueueBinding(</span><br><span class="line">                    value &#x3D; @Queue(value &#x3D; &quot;queue-email-topic&quot;,autoDelete &#x3D; &quot;false&quot;),</span><br><span class="line">                    exchange &#x3D; @Exchange(value &#x3D; &quot;ex-topic&quot;,type &#x3D; &quot;topic&quot;),</span><br><span class="line">                    key &#x3D; &quot;*.rk.email&quot;</span><br><span class="line">            )</span><br><span class="line">    &#125;)</span><br><span class="line">    public void onUserEmailMessage(String message)&#123;</span><br><span class="line">        System.out.println(&quot;用户邮件消息内容是： &quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 所有的和rk相关的消息，统一处理消费</span><br><span class="line">     * 包含的路由键有：user.rk.sms | user.rk.email | reg.rk.sms | reg.rk.email 等</span><br><span class="line">     * 不发短信，不发邮件，作为一个日志记录工具存在</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RabbitListener(bindings &#x3D; &#123;</span><br><span class="line">            @QueueBinding(</span><br><span class="line">                    value &#x3D; @Queue(value &#x3D; &quot;queue-all-topic&quot;,autoDelete &#x3D; &quot;false&quot;),</span><br><span class="line">                    exchange &#x3D; @Exchange(value &#x3D; &quot;ex-topic&quot;,type &#x3D; &quot;topic&quot;),</span><br><span class="line">                    key &#x3D; &quot;*.rk.*&quot;</span><br><span class="line">            )</span><br><span class="line">    &#125;)</span><br><span class="line">    public void onUserServiceMessage(String message)&#123;</span><br><span class="line">        System.out.println(&quot;执行的消息处理逻辑是： &quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是在配置路由键处，<em>表示所有的，</em>.rk.*就表示路由键中中间只要是rk的所有路由键都会执行这个方法。<br>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class TopicRabbitMQApp &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(TopicRabbitMQApp.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 192.168.15.132</span><br><span class="line">    username: oldou</span><br><span class="line">    password: oldou</span><br></pre></td></tr></table></figure>
<p>先启动消费者，当消息生产者一旦发送消息时，消费者就会根据路由键的类型去取消息并且根据类型进行输出，只要符合消费消息的都进行输出，以上测试代码输出如下：<br><img src="https://img-blog.csdnimg.cn/20200803181036453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="八、-传递对象类型参数"><a href="#八、-传递对象类型参数" class="headerlink" title="八、 传递对象类型参数"></a>八、 传递对象类型参数</h1><p>如果消息是对象类型，此对象的类型必须进行序列化，且需要给定序列化值<br><img src="https://img-blog.csdnimg.cn/20200803181132757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>以上便是我学习RabbitMQ时整理的笔记，如果不正确的地方欢迎各位大佬们指正，上面的代码都是我测试过了的，如果出现异常或者是其他之类的错误，就需要好好检查一下代码、配置文件以及Linux的防火墙等等</strong></p>
]]></content>
      <categories>
        <category>消息中间件</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>RabbitMQ学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合容器知识点整理</title>
    <url>/2020/08/05/Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%EF%BC%882020%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="1、什么是集合？"><a href="#1、什么是集合？" class="headerlink" title="1、什么是集合？"></a>1、什么是集合？</h2><p>集合是一个用于存储数据的容器，任何集合框架都包含：对外的接口、接口的实现、集合运算的算法。</p>
<ul>
<li><p>接口：表示集合的抽象数据类型。接口允许我们操作集合时不必关注具体实现，从而达到“多态”。在面向对象编程语言中，接口通常用来形成规范。</p>
</li>
<li><p>实现：集合接口的具体实现，是重用性很高的数据结构。</p>
</li>
<li><p>算法：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。这些算法通常是多态的，因为相同的方法可以在同一个接口被多个类实现时有不同的表现。事实上，算法是可复用的函数。</p>
</li>
</ul>
<h2 id="2、集合的特点"><a href="#2、集合的特点" class="headerlink" title="2、集合的特点"></a>2、集合的特点</h2><ul>
<li>对象的封装，对象多了也是需要存储的，而集合用于存储对象；</li>
<li>对象的个数确定时可以使用数组，但是对象的个数不确定时可以采用集合。因为集合的长度是可变的。</li>
</ul>
<h2 id="3、集合和数组的区别以及相互转换"><a href="#3、集合和数组的区别以及相互转换" class="headerlink" title="3、集合和数组的区别以及相互转换"></a>3、集合和数组的区别以及相互转换</h2><p>区别：</p>
<ul>
<li>集合的长度是可变的，数组的长度是固定的；</li>
<li>数组既可以存储基本数据类型，也可以存储引用数据类型，而集合只可以存储引用数据类型；</li>
<li>数组存储的元素必须是同一数据类型的，而集合存储的对象可以是不同数据类型的。</li>
</ul>
<p>转换：</p>
<ul>
<li>集合转数组：使用List自带的方法toArray()；</li>
<li>数组转集合：使用Arrays.asList(array)进行转换；</li>
</ul>
<h2 id="4、使用集合框架的好处有哪些？"><a href="#4、使用集合框架的好处有哪些？" class="headerlink" title="4、使用集合框架的好处有哪些？"></a>4、使用集合框架的好处有哪些？</h2><ul>
<li>容量自增长，集合有扩容机制，当达到一定数量时就会进行扩容；</li>
<li>提供了高性能的数据结构和算法，使得编码更加轻松，提高了程序速度和质量；</li>
<li>可以方便的扩展或改写集合，提高代码复用性和可操作性；</li>
<li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</li>
</ul>
<h2 id="5、集合的总体框架介绍"><a href="#5、集合的总体框架介绍" class="headerlink" title="5、集合的总体框架介绍"></a>5、集合的总体框架介绍</h2><p> <img src="https://img-blog.csdnimg.cn/20200808155437382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200808155501138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Java容器分为Collection和Map两大接口，Collection接口的子接口有Set、List、Queue三种。<br>我们比较常用的是Set、List、Map接口，其中Map接口不是Collection的子接口。</p>
<h3 id="5-1-各类接口的简介"><a href="#5-1-各类接口的简介" class="headerlink" title="5.1 各类接口的简介"></a>5.1 各类接口的简介</h3><p>（1）Collection集合主要有List和Set两大接口，其次还有Queue接口。</p>
<ul>
<li><p>List：它是一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，并且可以插入多个null元素，元素都有索引。常用的实现类有：ArrayList、LinkedList和Vector。</p>
</li>
<li><p>Set：它是一个无序（存入和去除顺序有可能不一致）容器，不可能存储重复元素，只允许存入一个null元素，但是必须保持元素唯一性。Set接口常用的实现类有HashSet、LinkedHashSet以及TreeSet。</p>
</li>
<li><p>Queue：和List、Set时同一级别的，都是继承Collection接口，它是一个队列，特点是先进先出（FIFO），它和堆栈一样，也是一种运算受限的线性表，后面学习的消息中间件中使用到的就是Queue。</p>
</li>
</ul>
<p>（2）Map集合</p>
<ul>
<li>Map集合是一个键值对集合，存储键、值之间的映射。Key无序且唯一，Value不要求有序且允许重复。 -  - Map没有继承与Collection接口，它是独立接口从Map集合中检索元素时，只要给出键对象就会返回对一你个的值对象。</li>
<li>Map接口常用的实现类有：HashMap、TreeMap、Hashtable、LinkedHashMap、ConcurrentHashMap。</li>
</ul>
<h3 id="5-2-集合框架的底层数据结构"><a href="#5-2-集合框架的底层数据结构" class="headerlink" title="5.2 集合框架的底层数据结构"></a>5.2 集合框架的底层数据结构</h3><p>（1）List接口</p>
<ul>
<li>ArrayList：底层是Object数组</li>
<li>Vector：底层也是Object数组</li>
<li>LinkedList：底层使用的是双向循环列表</li>
</ul>
<p>（2）Set接口</p>
<ul>
<li>HashSet（无序且唯一）：底层是基于HashMap实现的，采用的是HashMap来保存元素；</li>
<li>LinkedHashSet：它继承于HashSet，其内部是通过LinkedHashMap来实现的。</li>
<li>TreeSet（有序、唯一）：底层使用红黑树（自平衡的排序二叉树）。</li>
</ul>
<p>（3）Map接口</p>
<ul>
<li>HashMap：JDK1.8之前采用的是数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）且数组长度小于64时，首先会进行扩容，否则将链表转化为红黑树，以减少搜索时间；</li>
<li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑；</li>
<li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li>TreeMap： 红黑树（自平衡的排序二叉树）；</li>
</ul>
<h3 id="5-3-集合框架的特点"><a href="#5-3-集合框架的特点" class="headerlink" title="5.3 集合框架的特点"></a>5.3 集合框架的特点</h3><p>（1）List 有序，元素可重复</p>
<ul>
<li><p>ArrayList<br>底层数据结构是数组，查询快，增删慢、线程不安全，效率高</p>
</li>
<li><p>Vector<br>底层数据结构是数组，查询快，增删慢、线程安全，效率低</p>
</li>
<li><p>LinkedList<br>底层数据结构是链表，查询慢，增删快、线程不安全，效率高</p>
</li>
</ul>
<p>（2）Set 无序,唯一</p>
<ul>
<li><p>HashSet<br>底层数据结构是哈希表。(无序,唯一)<br>如何来保证元素唯一性?<br>1.依赖两个方法：hashCode()和equals()</p>
</li>
<li><p>LinkedHashSet<br>底层数据结构是链表和哈希表。(FIFO插入有序,唯一)<br>1.由链表保证元素有序<br>2.由哈希表保证元素唯一</p>
</li>
<li><p>TreeSet<br>底层数据结构是红黑树。(唯一，有序)<br>1.如何保证元素排序的呢?<br>  自然排序<br> 比较器排序<br>2.如何保证元素唯一性的呢?<br> 根据比较的返回值是否是0来决定</p>
</li>
</ul>
<h3 id="5-4-Java中有那些集合是线程安全的呢？"><a href="#5-4-Java中有那些集合是线程安全的呢？" class="headerlink" title="5.4 Java中有那些集合是线程安全的呢？"></a>5.4 Java中有那些集合是线程安全的呢？</h3><p>（1）Vector：比ArrayList多了个同步机制（线程安全）；<br>（2）Hashtable：底层的方法或变量使用sycnhronized关键字修饰；<br>（3）ConcurrentHashMap<br>（4）Statck：堆栈类，先进后出；<br>（5）Enumeration：枚举，相当于迭代器。</p>
<h3 id="5-5-List、Set、Map三者之间的区别是什么？"><a href="#5-5-List、Set、Map三者之间的区别是什么？" class="headerlink" title="5.5 List、Set、Map三者之间的区别是什么？"></a>5.5 List、Set、Map三者之间的区别是什么？</h3><ul>
<li>List是一个有序容器、元素可重复，可以插入多个null元素，元素都有索引；</li>
<li>Set是一个无序容器、元素不重复，只允许插入一个null值，并且必须保证元素唯一性；</li>
<li>Map是一个键值对集合，里面存储着key-value之间的映射，Key无序且唯一，Value不要求有序且允许重复；<br>List和Set接口是继承于Collection接口，而Map是一个独立的接口，没有继承Collection接口。</li>
</ul>
<h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><h2 id="一、ArrayList"><a href="#一、ArrayList" class="headerlink" title="一、ArrayList"></a>一、ArrayList</h2><h3 id="1、ArrayList的简介"><a href="#1、ArrayList的简介" class="headerlink" title="1、ArrayList的简介"></a>1、ArrayList的简介</h3><ul>
<li>ArrayList是List接口的实现类，底层使用数组的数据结构进行存储，他其实就是一个动态数组，当我们使用它来进行基本数据类型的存储时，只能存储基本数据类型的包装类，因为它底层实现的是数组对象Object[] elementData，因此不能进行基本数据类型的存储。<br>它有以下几个特点：</li>
<li>查询效率高、增删效率低、线程不安全。但是使用频率高。    </li>
</ul>
<p>（1）为什么它的查找效率高呢？<br>答：因为ArrayList的底层是以数组实现，是一种随机访问模式，ArrayList实现了RandomAccess接口，因此查询的时候很快。</p>
<p>（2）为什么增删的效率低呢？<br>答：当增加/删除元素的时候，需要做一次数组拷贝的操作，如果元素比较多就比较耗性能。</p>
<p>（3）应用场景：适合使用在顺序添加、随机访问的场景。</p>
<h3 id="2、ArrayLisy的默认长度以及扩容机制"><a href="#2、ArrayLisy的默认长度以及扩容机制" class="headerlink" title="2、ArrayLisy的默认长度以及扩容机制"></a>2、ArrayLisy的默认长度以及扩容机制</h3><p>（1）通过看ArrayList的源码可以知道ArrayList的默认长度为10（DEFAULT_CAPACITY = 10），如图源码所示：<br><img src="https://img-blog.csdnimg.cn/20200808155733190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>它可以通过构造方法初始化的时候指定底层数组的大小，开始的时候默认是空数组，也就是长度为0，只有当我们去调用add方法添加数据时才会分配默认值10。</p>
<p>（2）然后我们都知道，数组的长度是有限的，当插入元素到一定程度的时候，就会进行扩容，打比方说我们现在有一个长度为10的数组，现在我们要新增一个元素，但是发现已经装不下了，这个时候会进行以下步骤：</p>
<ul>
<li>第一步：重新定义一个长度为10+10/2的数组（定义一个原数组容量的1.5倍），也就是新增一个容量为15的数组；</li>
<li>第二步：将原数组中的数据原封不动的复制到新数组中，相当于对数组进行了拷贝，这个时候再把指向原数组的地址换到新数组。<br>以上两步就是ArrayList的扩容。</li>
</ul>
<h3 id="3、ArrayList在JDK1-7和JDK1-8版本初始化的时候有什么区别？"><a href="#3、ArrayList在JDK1-7和JDK1-8版本初始化的时候有什么区别？" class="headerlink" title="3、ArrayList在JDK1.7和JDK1.8版本初始化的时候有什么区别？"></a>3、ArrayList在JDK1.7和JDK1.8版本初始化的时候有什么区别？</h3><p>ArrayList在JDK1.7 之前初始化时会调用this(10)才是真正的容量为10，JDK1.7之后本身就默认走了空数组，只有第一次调用add()方法时容量才会变成10。</p>
<h3 id="4、ArrayList-int-initialCapacity-会不会初始化数组大小？"><a href="#4、ArrayList-int-initialCapacity-会不会初始化数组大小？" class="headerlink" title="4、ArrayList(int initialCapacity) 会不会初始化数组大小？"></a>4、ArrayList(int initialCapacity) 会不会初始化数组大小？</h3><p>会初始化数组大小，但是List的大小没有变，因为List的大小返回的时size的。</p>
<h3 id="5、ArrayList常用的方法有哪些？"><a href="#5、ArrayList常用的方法有哪些？" class="headerlink" title="5、ArrayList常用的方法有哪些？"></a>5、ArrayList常用的方法有哪些？</h3><ul>
<li><p><code>boolean add(E e)</code><br>将指定的元素添加到此列表的尾部。</p>
</li>
<li><p><code>void add(int index, E element)</code><br>将指定的元素插入此列表中的指定位置。</p>
</li>
<li><p><code>boolean addAll(Collection c)</code><br>按照指定 collection 的迭代器所返回的元素顺序，将该 collection 中的所有元素添加到此列表的尾部。</p>
</li>
<li><p><code>boolean addAll(int index, Collection c)</code><br>从指定的位置开始，将指定 collection 中的所有元素插入到此列表中。</p>
</li>
<li><p><code>void clear()</code><br>移除此列表中的所有元素。</p>
</li>
<li><p><code>Object clone()</code><br>返回此 ArrayList 实例的浅表副本。</p>
</li>
<li><p><code>boolean contains(Object o)</code><br>如果此列表中包含指定的元素，则返回 true。</p>
</li>
<li><p><code>void ensureCapacity(int minCapacity)</code><br>如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。</p>
</li>
<li><p><code>E get(int index)</code><br>返回此列表中指定位置上的元素。</p>
</li>
<li><p><code>int indexOf(Object o)</code><br>返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。</p>
</li>
<li><p><code>boolean isEmpty()</code><br>如果此列表中没有元素，则返回 true</p>
</li>
<li><p><code>int lastIndexOf(Object o)</code><br>返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含索引，则返回 -1。</p>
</li>
<li><p><code>E remove(int index)</code><br>移除此列表中指定位置上的元素。</p>
</li>
<li><p><code>boolean remove(Object o)</code><br>移除此列表中首次出现的指定元素（如果存在）。</p>
</li>
<li><p><code>protected void removeRange(int fromIndex, int toIndex)</code><br>移除列表中索引在 fromIndex（包括）和 toIndex（不包括）之间的所有元素。</p>
</li>
<li><p><code>E set(int index, E element)</code><br>用指定的元素替代此列表中指定位置上的元素。</p>
</li>
<li><p><code>int size()</code><br>返回此列表中的元素数。</p>
</li>
<li><p><code>Object[] toArray()</code><br>按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组。</p>
</li>
<li><p><code>T[] toArray(T[] a)</code><br>按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。</p>
</li>
<li><p><code>void trimToSize()</code><br>将此 ArrayList 实例的容量调整为列表的当前大小。</p>
</li>
</ul>
<h3 id="6、ArrayList初始化过程源码分析"><a href="#6、ArrayList初始化过程源码分析" class="headerlink" title="6、ArrayList初始化过程源码分析"></a>6、ArrayList初始化过程源码分析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   &#x2F;&#x2F;这里是说明了ArrayList创建时是赋值了一个长度默认为0的数组，同时也是一个Object类型的数组</span><br><span class="line">   private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;</span><br><span class="line">   &#x2F;&#x2F;ArrayList的底层是一个动态数组对象</span><br><span class="line">   transient Object[] elementData;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;1、无参构造方法</span><br><span class="line">   public ArrayList() &#123;</span><br><span class="line">       &#x2F;&#x2F;这里相当于this.elementData &#x3D; &#123;&#125;;</span><br><span class="line">       this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    private static final Object[] EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;</span><br><span class="line">   &#x2F;&#x2F;2、带参构造方法   initialCapacity表示自己赋值的容量</span><br><span class="line">   public ArrayList(int initialCapacity) &#123;</span><br><span class="line">       if (initialCapacity &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果大于0 那么就创建一个容量为initialCapacity的数组对象</span><br><span class="line">           this.elementData &#x3D; new Object[initialCapacity];</span><br><span class="line">       &#125; else if (initialCapacity &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;这里是为了保证健壮性</span><br><span class="line">           &#x2F;&#x2F;如果为0，表示没有赋值，就创建一个长度为0的空数组</span><br><span class="line">           this.elementData &#x3D; EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           &#x2F;&#x2F;这里也是为了保证程序的健壮性，如果赋值为负数就报异常</span><br><span class="line">           throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                   initialCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;这个size是ArrayList的大小</span><br><span class="line">        private int size;</span><br><span class="line">   &#x2F;&#x2F;3、添加方法 add(Object obj)</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">       &#x2F;&#x2F;检测容量是否够用，如果不够用就进行扩容，假设为空 0</span><br><span class="line">       ensureCapacityInternal(size + 1); &#x2F;&#x2F;0+1</span><br><span class="line">       &#x2F;&#x2F;添加元素  elementData[size] &#x3D; e;  size++;</span><br><span class="line">       elementData[size++] &#x3D; e;</span><br><span class="line">       return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;初始容量10</span><br><span class="line">   private static final int DEFAULT_CAPACITY &#x3D; 10;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;4、检测当前数组容量是否够用</span><br><span class="line">    &#x2F;&#x2F;minCapacity表示最小容量 0+1</span><br><span class="line">   private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">       &#x2F;&#x2F;判断数组的是否为空   第一次调用时  elementData &#x3D;&#x3D; &#123;&#125;</span><br><span class="line">       if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果为空就就行比较，然后取最大值 为空的话最大值为10</span><br><span class="line">            minCapacity &#x3D; Math.max(DEFAULT_CAPACITY, minCapacity);&#x2F;&#x2F;max(10,1);</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;计算出来之后就调用这个方法  minCapacity为10</span><br><span class="line">       ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;4.1、传入这个方法的minCapacity为10</span><br><span class="line">    private void ensureExplicitCapacity(int minCapacity) &#123; &#x2F;&#x2F;10</span><br><span class="line">        modCount++;</span><br><span class="line">       &#x2F;&#x2F; 进行判断，发现现在数组当前同理不满足所需最小容量</span><br><span class="line">        if (minCapacity - elementData.length &gt; 0) &#x2F;&#x2F;10 - 0 &gt; 0</span><br><span class="line">           &#x2F;&#x2F;进行扩容</span><br><span class="line">           grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;5、扩容</span><br><span class="line">   private void grow(int minCapacity) &#123;  &#x2F;&#x2F;当期数组所需最小容量10</span><br><span class="line">        int oldCapacity &#x3D; elementData.length; &#x2F;&#x2F;当前数组长度  0</span><br><span class="line">        int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1); &#x2F;&#x2F;计算新的数组容量 这里相当于扩容0.5倍</span><br><span class="line">        if (newCapacity - minCapacity &lt; 0) &#x2F;&#x2F; 0-10&lt;0</span><br><span class="line">            newCapacity &#x3D; minCapacity; &#x2F;&#x2F;将容量进行赋值 newCapacity&#x3D;10</span><br><span class="line">        &#x2F;&#x2F;以下判断是为了保持程序的健壮性</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">           newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">        &#x2F;&#x2F;对数组进行拷贝 并且新数组elementData的长度为10</span><br><span class="line">        elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> <strong>总结</strong>：以上为第一次调用add方法时ArrayList底层所做的事情，下面详细总结一下：<br> 当我们新创建一个ArrayList，没有赋初值，那么底层就调用无参构造方法，去创建一个Object数组对象，这个数组对象的默认长度为0，当我们第一次调用add方法去添加元素的时候，首先会进行一次容量的检测<code>ensureCapacityInternal(size + 1);</code>检测容量不够用的话就会进行扩容，将容量变成默认长度10(<code>private static final int DEFAULT_CAPACITY = 10;</code>)，<br>这也就是为什么我们说的ArrayList的默认长度为10，然后扩容时是扩容为原数组的1.5倍，如果当前长度为10，需要扩容时容量就会计算为<code>15(oldCapacity + (oldCapacity &gt;&gt; 1);)</code></p>
<h3 id="7、ArrayList部分方法源码分析"><a href="#7、ArrayList部分方法源码分析" class="headerlink" title="7、ArrayList部分方法源码分析"></a>7、ArrayList部分方法源码分析</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;** 方法的源码分析</span><br><span class="line">    （1）add(int index,Object obj)方法  在指定索引的位置上添加元素</span><br><span class="line">public void add(int index, E element) &#123; &#x2F;&#x2F;索引和元素</span><br><span class="line"> &#x2F;&#x2F;检测索引是否正确</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"> &#x2F;&#x2F;检测容量是否够用</span><br><span class="line">    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line"> &#x2F;&#x2F;数组的拷贝           原数组   原数组开始位置  新数组  新数组开始位置  拷贝元素的个数</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + 1,size - index);</span><br><span class="line">    elementData[index] &#x3D; element; &#x2F;&#x2F;将元素添加到索引为index的位置上</span><br><span class="line">    size++; &#x2F;&#x2F;元素的个数+1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    （2）get(int index)根据索引获取元素对象</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">    rangeCheck(index); &#x2F;&#x2F;检测索引是否正确</span><br><span class="line"></span><br><span class="line">    return elementData(index); &#x2F;&#x2F;调用elementData方法，操作数组根据索引取出元素对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    （3）set(int index,E element) 根据索引，设置元素对象的值</span><br><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">&#x2F;&#x2F;根据索引获取数组中的元素</span><br><span class="line">    E oldValue &#x3D; elementData(index);</span><br><span class="line"> &#x2F;&#x2F;将新的元素设置到索引为index的位置上</span><br><span class="line">    elementData[index] &#x3D; element;</span><br><span class="line">    return oldValue; &#x2F;&#x2F;返回被替换的元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    （4）remove(int index)  根据索引删除元素</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue &#x3D; elementData(index);&#x2F;&#x2F;根据所以取出数组中的元素</span><br><span class="line"> &#x2F;&#x2F;计算拷贝的元素个数</span><br><span class="line">    int numMoved &#x3D; size - index - 1;</span><br><span class="line"></span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line"> &#x2F;&#x2F;数组的拷贝</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                numMoved);</span><br><span class="line"> &#x2F;&#x2F;将最后一个位置设置为null</span><br><span class="line">    elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work</span><br><span class="line">&#x2F;&#x2F;返回被删除的元素</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 其他的方法都与以上类似，直接去看源码即可</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="二、LinkedList"><a href="#二、LinkedList" class="headerlink" title="二、LinkedList"></a>二、LinkedList</h2><h3 id="1、LinkedList的简介"><a href="#1、LinkedList的简介" class="headerlink" title="1、LinkedList的简介"></a>1、LinkedList的简介</h3><p>LinkedList类继承了AbstractSequentialList抽象类，同时继承了List、Deque、Clonable、Serializable接口，它可以被当做堆栈、队列或者双端队列进行操作。<br>LinkedList底层采用的是双向链表的数据结构进行存储，节点用静态内部类Node，它增删元素效率比较高，但是结构比较复杂。<br>源码如下：<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> private static class Node &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Nodenext; &#x2F;&#x2F;后继节点</span><br><span class="line">    Nodeprev; &#x2F;&#x2F;前驱节点</span><br><span class="line">    Node(Node prev, E element, Node next) &#123;</span><br><span class="line">        this.item &#x3D; element;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">        this.prev &#x3D; prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>添加以下代码时的结构图：<br><img src="https://img-blog.csdnimg.cn/20200808160507305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2、LinkedList和ArrayList之间的区别是什么？"><a href="#2、LinkedList和ArrayList之间的区别是什么？" class="headerlink" title="2、LinkedList和ArrayList之间的区别是什么？"></a>2、LinkedList和ArrayList之间的区别是什么？</h3><ul>
<li>数据结构：ArrayList底层采用动态数组的数据结构，LinkedList底层采用双向链表的数据结构；</li>
<li>随机访问效率：ArrayList的随机访问效率比LinkedList要高，因为LinkedList是线性的数据存储方式，查询时需要移动指针从前往后依次查找；</li>
<li>增删效率：在非首尾的增删操作，LinkedList的效率要比ArrayList高，因为ArrayList的增删操作会影响数组内其他元素的下标。</li>
<li>内存空间：LinkedList要比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，另一个指向后一个元素。</li>
<li>两者都是线程不安全的。</li>
</ul>
<p>双向链表也叫双链表，它的每个数据节点中都有两个指针，分别指向直接前驱和直接后驱。因此从双向链表中任何一个节点开始都可以很方便的访问它的前驱节点和后驱节点。</p>
<h2 id="三、Vector"><a href="#三、Vector" class="headerlink" title="三、Vector"></a>三、Vector</h2><p>Vector的底层数据结构和ArrayList一样是动态数组，区别在于Vector是线程安全的，它继承了AbstractList类。<br><strong>Vector的默认长度为10，初始化未设置初始值时，会调用无参构造方法，然后使用this(10)，直接将容量赋值为10，然后当容量不足时会进行扩容，扩容后容量为原来的两倍。10–&gt;20</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public Vector() &#123;</span><br><span class="line">    this(10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、ArrayList和Vector的区别"><a href="#3、ArrayList和Vector的区别" class="headerlink" title="3、ArrayList和Vector的区别"></a>3、ArrayList和Vector的区别</h3><p>相同点：两者都实现了List接口，都是有序集合，底层数据结构相同，并且方法类似。<br>不同点：</p>
<ul>
<li>线程安全：Vector使用了synchronized关键字来实现线程同步，是线程安全的，而ArrayList是非线程安全的；</li>
<li>性能：ArrayList在性能方面要由于Vector；</li>
<li>扩容：ArrayList和Vector都会根据实际需求动态的进行扩容，Vector每次扩容会增加1倍，而ArrayList增加0.5倍。</li>
<li>容量初始化方式：ArrayList在创建时是一个空数组，在第一次调用add方法时才初始化容量为10，而LinkedList在创建对象的时候就直接初始化容量为10。</li>
<li>版本不一样，Vector时JDK1.0的，ArrayList时JDK1.2的版本。</li>
</ul>
<h3 id="4、ArrayList、LinkedList、Vector三者之间的对比"><a href="#4、ArrayList、LinkedList、Vector三者之间的对比" class="headerlink" title="4、ArrayList、LinkedList、Vector三者之间的对比"></a>4、ArrayList、LinkedList、Vector三者之间的对比</h3><ul>
<li>Vector是线程安全的容器，但是性能别ArrayList差；</li>
<li>LinkedList的插入数据的速度较快；</li>
<li>Vector和ArrayList的底层都是使用动态数组实现的。</li>
</ul>
<h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><h3 id="1、HashSet的工作原理"><a href="#1、HashSet的工作原理" class="headerlink" title="1、HashSet的工作原理"></a>1、HashSet的工作原理</h3><p>HashSet是基于HashMap实现的，底层数据结构是哈希表，主结构数组，HashSet的值存放在HashMap的key上，HashMap的Value统一为PRESENT，因此HashSet是一个无序集合，且里面的元素唯一，允许插入null元素，但不允许有重复的值。HashSet基本上都是直接调用底层的HashMap的相关方法来实现的。</p>
<h3 id="2、HashSet是如何保证数据不重复的？"><a href="#2、HashSet是如何保证数据不重复的？" class="headerlink" title="2、HashSet是如何保证数据不重复的？"></a>2、HashSet是如何保证数据不重复的？</h3><p>当调用HashSet中的add()方法添加元素时，首先会判断元素是否存在，而判断元素是否存在不仅仅要比较hash值同时还需要结合equals()方法进行比较。当调用HashSet中的add方法时会间接的使用HashMap中的put方法，我们都知道HashMap的键是唯一的，不允许重复，而从HashSet的源码可以知道添加的元素就是作为HashMap的Key，并且当HashMap中的Key/Value相同时新的Value会替换掉就的Value，HashMap比较Key是否相等时先是比较HashCode然后在比较equals，因此保证了数据不重复。</p>
<p>以下为HashSet的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> private static final Object PRESENT &#x3D; new Object();</span><br><span class="line">private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">public HashSet() &#123;</span><br><span class="line">    map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span><br><span class="line">    return map.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>附重点：</strong><br>（1）hashcode()和equals()的一些注意点</p>
<ul>
<li>如果两个对象相等，那么它们的hashcode一定相等，且对两个对象的equals方法返回为true；</li>
<li>如果两个对象有相同的hashcode，但它们不一定是相等的，equals方法返回不一定为true；</li>
<li>当equals方法被覆盖（重写）时，hashcode方法也异地你个要被覆盖（重写）；</li>
<li>hashCode方法的默认行为是对堆上的对象产生独特值，如果没重写hashCode，则该class的两个对象无论如何都不会相等，即使这两个对象指向相同的数据。</li>
</ul>
<p>（2）==和equlas的对比</p>
<ul>
<li>==判断两个变量或者实例是不是指向同一个内存空间，而equals方法是比较两个变量或者实例所指向的呢内存空间的值是不是相同的；</li>
<li>==是对内存地址进行比较，而equals方法是对字符串的内容进行比较；</li>
<li>==比较的是引用是否相同，而equals方法比较的是值是否相同。</li>
</ul>
<h3 id="3、HashSet的一些常用方法介绍"><a href="#3、HashSet的一些常用方法介绍" class="headerlink" title="3、HashSet的一些常用方法介绍"></a>3、HashSet的一些常用方法介绍</h3><ul>
<li>add 添加一个元素</li>
<li>clear 请发出整个HashSet中的元素</li>
<li>contains 判断集合中是否包含某个元素</li>
<li>remove 删除指定的元素</li>
<li>size 返回集合的大小</li>
<li>isEmpty 判断是否为空</li>
</ul>
<h3 id="4、HashSet和HashMap的区别"><a href="#4、HashSet和HashMap的区别" class="headerlink" title="4、HashSet和HashMap的区别"></a>4、HashSet和HashMap的区别</h3><ul>
<li>实现接口：HashMap实现了Map接口，而HashSet实现的是Set接口；</li>
<li>存储对比：HashMap存储的是键值对，而HashSet仅仅存储对象；</li>
<li>添加元素方式：HashMap调用put方法向Map中添加元素，而HashSet调用的是add方法向Set中添加元素；</li>
<li>效率：HashMap相对于HashSet来说较快，因为HashMap是使用唯一的键获取对象。</li>
<li>获取Hashcode的方式：HashMap使用的是Key计算hashcode，而HashSet是通过成员对象来计算hashcode，对于两个对象的hashcode可能相同，所以使用equals方法来判断对象是否相等。</li>
</ul>
<h3 id="5、HashSet的源码分析"><a href="#5、HashSet的源码分析" class="headerlink" title="5、HashSet的源码分析"></a>5、HashSet的源码分析</h3><p>HashSet的源码只有短短的300行，现在我们来看一下HashSet的构造方法和成员变量，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; HashSet 真实的存储元素结构</span><br><span class="line">private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 作为各个存储在 HashMap 元素的键值对中的 Value</span><br><span class="line">private static final Object PRESENT &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;空参数构造方法 调用 HashMap 的空构造参数  </span><br><span class="line">&#x2F;&#x2F;初始化了 HashMap 中的加载因子 loadFactor &#x3D; 0.75f</span><br><span class="line">public HashSet() &#123;</span><br><span class="line">    map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指定期望容量的构造方法</span><br><span class="line">public HashSet(int initialCapacity) &#123;</span><br><span class="line">    map &#x3D; new HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;指定期望容量和加载因子</span><br><span class="line">public HashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    map &#x3D; new HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;使用指定的集合填充Set</span><br><span class="line">public HashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    &#x2F;&#x2F;调用  new HashMap&lt;&gt;(initialCapacity) 其中初始期望容量为 16 和 c 容量 &#x2F; 默认 load factor 后 + 1的较大值</span><br><span class="line">    map &#x3D; new HashMap&lt;&gt;(Math.max((int) (c.size()&#x2F;.75f) + 1, 16));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 该方法为 default 访问权限，不允许使用者直接调用，目的是为了初始化 LinkedHashSet 时使用</span><br><span class="line">HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">    map &#x3D; new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过HashSet的构造参数我们可以看出每个构造方法都调用了对应的HashMap的构造方法，因此我们可以知道<strong>HashSet的默认初始化容量为16（源码中是1&lt;&lt;4），负载因子默认为0.75f，和HashMap的一样。</strong></li>
<li>我们都知道Set集合是不允许存储重复的元素的，又由构造参数得出HashSet的底层存储结构为HashMap，那么从源码中可以得知，<strong>实现这不可重复的属性是由HashMap中存储键值对的Key来实现</strong>。</li>
</ul>
<h3 id="6、LinkedHashSet的简介"><a href="#6、LinkedHashSet的简介" class="headerlink" title="6、LinkedHashSet的简介"></a>6、LinkedHashSet的简介</h3><p>LinkedHashSet继承于HashSet，底层采用的链表+哈希表的数据结构，FIFO插入元素，是一个有序容器，且元素唯一，可以容纳null元素。</p>
<h3 id="7、LinkedHashSet源码分析"><a href="#7、LinkedHashSet源码分析" class="headerlink" title="7、LinkedHashSet源码分析"></a>7、LinkedHashSet源码分析</h3><p>上面HashSet源码的构造方法中有一个default权限的构造方法，该构造方法内部调用的是LinkedHashMap的构造方法，而LinkedHashMap比HashMap多了一个维护双向链表添加元素时保持的顺序。<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     &#x2F;&#x2F; dummy 参数没有作用这里可以忽略</span><br><span class="line">    HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">        map &#x3D; new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;调用 LinkedHashMap 的构造方法，该方法初始化了初始起始容量，以及加载因子，</span><br><span class="line">&#x2F;&#x2F;accessOrder &#x3D; false 即迭代顺序不等于访问顺序</span><br><span class="line">    public LinkedHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        super(initialCapacity, loadFactor);</span><br><span class="line">        accessOrder &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">LinkedHashSet的构造方法一共有四个，统一调用了父类HashSet的 HashSet(int initialCapacity, float loadFactor, boolean dummy)构造方法。</span><br><span class="line"> &#x2F;&#x2F;初始化 LinkedHashMap 的初始容量为诶 16 加载因子为 0.75f</span><br><span class="line">public LinkedHashSet() &#123;</span><br><span class="line">    super(16, .75f, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化 LinkedHashMap 的初始容量为 Math.max(2*c.size(), 11) 加载因子为 0.75f </span><br><span class="line">public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    super(Math.max(2*c.size(), 11), .75f, true);</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化 LinkedHashMap 的初始容量为参数指定值 加载因子为 0.75f </span><br><span class="line">public LinkedHashSet(int initialCapacity) &#123;</span><br><span class="line">    super(initialCapacity, .75f, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化 LinkedHashMap 的初始容量,加载因子为参数指定值 </span><br><span class="line">public LinkedHashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    super(initialCapacity, loadFactor, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上就是LinkedHashSet的源码，从源码中就可以知道它的实现完全依赖于LinkedHashMap内部的数据结构。</p>
<h3 id="7、TreeSet的简介"><a href="#7、TreeSet的简介" class="headerlink" title="7、TreeSet的简介"></a>7、TreeSet的简介</h3><p>TreeSet是一个key唯一，有序（升序）容器，底层采用的是红黑树的数据结构，它是基于TreeMap实现的，不能存储null元素，同时也不支持同步，而且TreeMap中的key实际上就是一个TreeSet。使用TreeSet要求使用内部比较器或者外部比较器。</p>
<h2 id="四、Collections工具类的部分方法介绍"><a href="#四、Collections工具类的部分方法介绍" class="headerlink" title="四、Collections工具类的部分方法介绍"></a>四、Collections工具类的部分方法介绍</h2><ul>
<li>Collections.sort(list)：如果list集合是字符串就会按照英文字母升序排序，如果是Integer类型就会按照数字大小排序；</li>
<li>Collections.addAll(list,elements)：一次性添加多个元素；</li>
<li>Collections.binarySearch(list,element)：二分查找，返回元素所在索引，element表示要查找的元素，使用前需要进行排序</li>
<li>Collections.copy(list1,list2)：将list1中的元素全部拷贝到list2集合，前提是list2集合的长度要大于或等于list1的长度，如果定义了泛型，那么集合的类型就需要一致</li>
<li>Collections.fill(list,element)：将element元素对list集合进行元素的填充，填充之后全部的元素都是element</li>
<li>Collections.max(list)：返回list集合中最大的元素</li>
<li>Collections.min(list)：返回list集合中最小的元素</li>
<li>Collections.reverse(list)：将list中的元素进行逆序排序</li>
<li>Collections.synchronizedList(list)：将集合转换成线程同步</li>
</ul>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><h3 id="1、HashMap的简介"><a href="#1、HashMap的简介" class="headerlink" title="1、HashMap的简介"></a>1、HashMap的简介</h3><p>HashMap是我们常见的数据结构，在JDK1.7之前它是由数组+链表组成的数据结构，数组中每个地方都存储了Key-Value这样的实例，它的数据结构是一个Entry节点，在JDK1.8之后，HashMap的结构就变成了数组+链表+红黑树这么一个数据结构，把原来的Entry节点变成了Node节点，当链表长度大于8且数组长度大于64时会自动转化为红黑树。<br>（1）当我们使用put方法往HashMap中加入元素的时候，HashMap会利用Hash算法将Key的HashCode重新hash，并计算出当前对象元素在数组中的下标，然后将其存储进去；<br>（2）在存储时如果出现hash值相同的Key，这个时候就会使用equals()方法去比较它们的Key是否相同，如果Key相同，那么就进行值的覆盖，如果Key不同，那么就会将当前的Key-Value放入到链表当中。<br>（3）然后说到插入链表的方式，在JDK1.7之前采用的是头插法，意思就是新来的值会取代原有的值，原来的值就被顺推到链表中去；在JDK1.8之后采用的是尾插法，意思就是新来的值会往后添加到链表中去，当链表长度大于8且数组长度大于64时会自动转化为红黑树。<br> <img src="https://img-blog.csdnimg.cn/20200808160944177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0NjIxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2、HashMap的扩容机制"><a href="#2、HashMap的扩容机制" class="headerlink" title="2、HashMap的扩容机制"></a>2、HashMap的扩容机制</h3><p>HashMap的底层是使用数组进行存储的，我们都知道数组的容量是有限的，数据的多次插入，到达一定数量之后就会进行扩容，也就是resize，那什么时候resize呢？首先得有两个因素：Capacity（HashMap当前的长度，默认初始容量为16）和LoadFactor（负载因子，0.75f），要怎么理解呢？就比如说当前的数组大小为100，当你存进第76个元素的时候，判断发现需要进行resize了，也就是需要进行扩容了，HashMap的扩容不是简单扩大点容量就行了，它分为以下两步：<br>第一步：先去创建一个新的Entry空数组，长度为原来数组的两倍；<br>第二步：进行rehash，遍历原来的Entry数组，把所有的Entry重新Hash到新数组中；<br>整个过程就是HashMap的扩容。</p>
<h3 id="3、聊一聊JDK1-7之前的头插法和JDK1-8之后的尾插法？"><a href="#3、聊一聊JDK1-7之前的头插法和JDK1-8之后的尾插法？" class="headerlink" title="3、聊一聊JDK1.7之前的头插法和JDK1.8之后的尾插法？"></a>3、聊一聊JDK1.7之前的头插法和JDK1.8之后的尾插法？</h3><ul>
<li>JDK1.7之前使用的是头插法，就是在往链表中插入元素的时候，新来的值会取代原有的值，原有的值就会顺推到链表中去；<br>缺点：不好的地方在于头插法在数组进行扩容的时候，原有链表中的顺序有所改变，扩容之后重新Hash，可能会导致扩容转移后的前后链表顺序倒置，在转移的过程中修改了原有链表中的节点引用关系，这样的话在多线程操作下就会造成死循环，然后当我们使用get去取值的时候就会进入死循环。</li>
<li>JDK1.8之后，插入数据的方式就变成了尾插入，使用尾插入在相同的情况下会将元素往后添加，这样就不会出现以上的情况，在扩容时会保持链表元素原有的顺序，就不会出现链表成环的问题。</li>
</ul>
<h3 id="4、JDK1-7是头插法，JDK1-8是尾插法，那头插法的时候，它会有死循环，这是线程不安全的原因之一吗？-那JDK1-8之后它的线程就是安全的吗？"><a href="#4、JDK1-7是头插法，JDK1-8是尾插法，那头插法的时候，它会有死循环，这是线程不安全的原因之一吗？-那JDK1-8之后它的线程就是安全的吗？" class="headerlink" title="4、JDK1.7是头插法，JDK1.8是尾插法，那头插法的时候，它会有死循环，这是线程不安全的原因之一吗？ 那JDK1.8之后它的线程就是安全的吗？"></a>4、JDK1.7是头插法，JDK1.8是尾插法，那头插法的时候，它会有死循环，这是线程不安全的原因之一吗？ 那JDK1.8之后它的线程就是安全的吗？</h3><p>不是的，那也不是线程安全的，因为1.8采用的是尾插法，但是没有改变它原来就是数据插入这么一个顺序，所以在这不会出现一个链表循环的这么一个过程。</p>
<h3 id="5、HashMap的线程不安全，在日常开发中，你是怎么去保证他线程安全的？"><a href="#5、HashMap的线程不安全，在日常开发中，你是怎么去保证他线程安全的？" class="headerlink" title="5、HashMap的线程不安全，在日常开发中，你是怎么去保证他线程安全的？"></a>5、HashMap的线程不安全，在日常开发中，你是怎么去保证他线程安全的？</h3><p>一般可以使用想ConcurrentHashMap这种线程安全的一个集合容器。</p>
<h3 id="6、HashMap是如何解决哈希冲突的？"><a href="#6、HashMap是如何解决哈希冲突的？" class="headerlink" title="6、HashMap是如何解决哈希冲突的？"></a>6、HashMap是如何解决哈希冲突的？</h3><h3 id="7、为什么String和包装类适合当HashMap中的Key？"><a href="#7、为什么String和包装类适合当HashMap中的Key？" class="headerlink" title="7、为什么String和包装类适合当HashMap中的Key？"></a>7、为什么String和包装类适合当HashMap中的Key？</h3><ul>
<li>String和包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少哈希碰撞的几率；</li>
<li>两者都是被final关键字修饰，即不变性，保证了Key不可被轻易更改，这样就不会有hash不同的情况出现；</li>
<li>两者内部都重写了equals方法和hashCode方法，符合HashMap的规范；</li>
</ul>
<h3 id="8、如果要使用对象作为HashMap中的Key，应当如何处理？"><a href="#8、如果要使用对象作为HashMap中的Key，应当如何处理？" class="headerlink" title="8、如果要使用对象作为HashMap中的Key，应当如何处理？"></a>8、如果要使用对象作为HashMap中的Key，应当如何处理？</h3><p>如果使用对象作为Key，那么这个对象就需要重写equals方法和hashCode方法，原因如下：</p>
<ul>
<li>重写equals方法是因为需要计算存储数据的存储位置；</li>
<li>重写hashCode方法是为了保证Key在哈希表中的唯一性。</li>
</ul>
<h3 id="9、HashMap的默认初始化长度是16，为什么是16而不是8，32呢？"><a href="#9、HashMap的默认初始化长度是16，为什么是16而不是8，32呢？" class="headerlink" title="9、HashMap的默认初始化长度是16，为什么是16而不是8，32呢？"></a>9、HashMap的默认初始化长度是16，为什么是16而不是8，32呢？</h3><p>源码中写的值是1&lt;&lt;4，这是由于位运算性能好，直接操作内存而不需要进行进制转换，要知道计算机可是以二进制的形式做数据存储的，至于为什么是16的话，我们在创就创建HashMap的时候，阿里巴巴规范插件会提醒我们最好赋初值，而且最好是2的次幂，这样是为了位运算的方便，位运算比算数计算的效率高多了，之所以选16是为了服务将Key映射到index的算法，通过Key的HashCode值去做位运算，Hash算法的结果是均匀的，主要还是为了实现均匀分布。</p>
<h3 id="10、那线程安全的，还有像HashTable啊，或者说我给他加Synchronized，或者Lock，或者用Collection-Synchronized都对他进行一个同步的操作，为什么你选择了ConcurrentHashMap？"><a href="#10、那线程安全的，还有像HashTable啊，或者说我给他加Synchronized，或者Lock，或者用Collection-Synchronized都对他进行一个同步的操作，为什么你选择了ConcurrentHashMap？" class="headerlink" title="10、那线程安全的，还有像HashTable啊，或者说我给他加Synchronized，或者Lock，或者用Collection.Synchronized都对他进行一个同步的操作，为什么你选择了ConcurrentHashMap？"></a>10、那线程安全的，还有像HashTable啊，或者说我给他加Synchronized，或者Lock，或者用Collection.Synchronized都对他进行一个同步的操作，为什么你选择了ConcurrentHashMap？</h3><p>HashTable虽然是线程安全的，但是其底层方法基本上都是使用了synchronized关键字修饰，效率低；<br>而ConcurrentHashMap它的并发度更高，并且它的数据结构在JDK1.8之后和HashMap一样变成了数组+链表+红黑树，它只会锁住我们目前获取到的那个Entry所在的那个节点的值，并且在上锁的时候它使用了CAS + Synchronized，再加上JDK1.6之后对Sychronized进行了一个优化和升级的过程，所以它的效率是更高的，也就是支持的并法度是更高的。</p>
<h3 id="11、简单介绍一下锁升级的过程。"><a href="#11、简单介绍一下锁升级的过程。" class="headerlink" title="11、简单介绍一下锁升级的过程。"></a>11、简单介绍一下锁升级的过程。</h3><p>在锁对象的对象头里面有一个threadid字段，第一次访问的时候这个字段是为空的，然后JVM让其持有偏向锁，并且将这个字段设置为其线程id，再次进入的时候会先判断threadid是否与其线程id一致，如果一致就可以直接使用该对象，如果不一致则将偏向锁升级为轻量级锁，通过自旋一定次数来获取锁，执行一定次数之后如果还没有正常获取到想要使用的对象，此时就将轻量级锁升级为重量级锁，此过程就构成了Synchronized锁的升级。</p>
<p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<h3 id="12、HashMap和Hashtable的区别是什么？"><a href="#12、HashMap和Hashtable的区别是什么？" class="headerlink" title="12、HashMap和Hashtable的区别是什么？"></a>12、HashMap和Hashtable的区别是什么？</h3><ul>
<li>线程安全：HashMap是非线程安全的，Hashtable是线程安全的，因为Hashtable的底层使用了synchronized关键字修饰；</li>
<li>效率：由于Hashtable的线程安全底层加了synchronized，所以HashMap的效率要比Hashtable高。</li>
<li>初始化容量以及扩容大小：HashMap的初始化容量为16，每次扩容时，容量会变成原来的2倍，而Hashtable的初始化容量为11，每次扩容都变为原来的2n+1。</li>
<li>底层数据结构：HashMap当链表长度大于阈值8的时候就会将链表转化为红黑树，而Hashtable没有这个机制。</li>
<li>是否允许null值：HashMap允许键和值为null，但是只允许一个null的Key，而Hashtable不允许非null的键和值存在。      </li>
<li>实现方式不一样：Hashtable继承了Dictionary类(JDK1.0)，而HashMap继承的是AbstractMap类；</li>
<li>迭代器不同：HashMap中的迭代器是fail-fast(快速识别机制)，而Hashtable不是。</li>
</ul>
<h3 id="13、怎么决定是使用HashMap还是TreeMap？"><a href="#13、怎么决定是使用HashMap还是TreeMap？" class="headerlink" title="13、怎么决定是使用HashMap还是TreeMap？"></a>13、怎么决定是使用HashMap还是TreeMap？</h3><ul>
<li>当对数据进行插入、删除、定位查找等操作的时候，可以优先考虑使用HashMap；</li>
<li>而如果是要对一个有序的Key集合进行遍历的时候，这个时候使用TreeMap就更好一些。</li>
</ul>
<h3 id="14、Hashmap中的链表大小超过八个时会自动转化为红黑树，当删除小于六时重新变为链表，为啥呢？"><a href="#14、Hashmap中的链表大小超过八个时会自动转化为红黑树，当删除小于六时重新变为链表，为啥呢？" class="headerlink" title="14、Hashmap中的链表大小超过八个时会自动转化为红黑树，当删除小于六时重新变为链表，为啥呢？"></a>14、Hashmap中的链表大小超过八个时会自动转化为红黑树，当删除小于六时重新变为链表，为啥呢？</h3><p>根据泊松分布，在负载因子默认为0.75的时候，单个hash槽内元素个数为8的概率小于百万分之一，所以将7作为一个分水岭，等于7的时候不转换，大于等于8的时候才进行转换，小于等于6的时候就化为链表。</p>
<h3 id="15、说一下关于ConcurrentHashMap的并法度、性能问题、数据操作，还有数据结构是什么样的么？（重点理解）"><a href="#15、说一下关于ConcurrentHashMap的并法度、性能问题、数据操作，还有数据结构是什么样的么？（重点理解）" class="headerlink" title="15、说一下关于ConcurrentHashMap的并法度、性能问题、数据操作，还有数据结构是什么样的么？（重点理解）"></a>15、说一下关于ConcurrentHashMap的并法度、性能问题、数据操作，还有数据结构是什么样的么？（重点理解）</h3><p>首先ConcurrentHashMap的底层是基于数组+链表组成的，不过JDK1.7和JDK1.8中具体实现稍微有点不一样，首先说一下它在1.7中的数据结构吧。<br>（1）JDK1.7的时候由Segment数组和HashEntry组成，和HashMap一样为数组+链表，至于并法度问题，<br>那是因为ConcurrentHashMap采用了分段锁技术，其中Segment继承了ReentrantLock，不会像Hasntable那样不管是put还是get操作都需要做同步处理，理论上ConcurrentHashMap支持CurrentLevel(也就是Segment数组数量)的线程并发，每当一个线程占用锁访问一个Segment时，不会影响到其他的Segment，也就是说当容量是16的话，它的并法度就是16，可以同时允许16个线程操作16个Segment并且还是线程安全的。</p>
<p>（2）关于它put操作：源码中它是先定位到Segment然后再进行put操作，首先第一步的时候尝试获取锁，如果获取失败肯定就有其他线程存在竞争，于是就利用自旋获取锁，简单来说就是第一步：尝试自选获取锁；第二：如果重试的次数达到了最大的扫描次数就改为阻塞锁获取，保证能够获取成功。<br>然后get的逻辑就比较简单了，只要将键通过Hash之后定位到具体的Segment，再通过一次Hash定位到具体的元素上，由于HashEntry中的值属性是用volatile关键词修饰的，保证了内存可见性，所以每次获取时都是最新值，ConcurrentHashMap的get方法是非常高效的，因为整个过程都不需要加锁。</p>
<p>（3）JDK1.7虽然支持每个Segment并发访问，但是还是存在一些问题，因为基本上还是数组+链表的方式，所以我们去查询的时候还得遍历数组，这样会导致效率很低，这个和JDK1.7的HashMap是存在一样的问题，所以在JDK1.8的时候完全优化了，JDK1.8的时候就抛弃了Segment分段锁，而是采用了CAS+Synchronized来保证并发安全性，跟HashMap很像，也把之前的HashEntry改成了Node，但是作用不变，把值和next采用了volatile去修饰，保证了可见性，同时引入了红黑树，在链表大于一定值的时候会转换(默认值是8)，这就是它的存取操作。</p>
<h3 id="16、ConcurrentHashMap在进行put操作的时候还是比较复杂的，大致分为以下步骤："><a href="#16、ConcurrentHashMap在进行put操作的时候还是比较复杂的，大致分为以下步骤：" class="headerlink" title="16、ConcurrentHashMap在进行put操作的时候还是比较复杂的，大致分为以下步骤："></a>16、ConcurrentHashMap在进行put操作的时候还是比较复杂的，大致分为以下步骤：</h3><p>（1）根据key计算出HashCode；<br>（2）判断是否需要进行初始化；<br>（3）即为当前Key定位出的Node，如果为空表示当前位置可以写入数据，利用CAS尝试写入，失败则自旋保证成功；<br>（4）如果当前位置的哈希码等于Moved等于-1的话，就需要进行扩容；<br>（5）如果都不满足，则利用Synchronized锁写入数据；<br>（6）如果数量还是大于Treeify_Threshold就要转换成红黑树；</p>
<h3 id="17、HashMap和ConcurrentHashMap的区别是什么？"><a href="#17、HashMap和ConcurrentHashMap的区别是什么？" class="headerlink" title="17、HashMap和ConcurrentHashMap的区别是什么？"></a>17、HashMap和ConcurrentHashMap的区别是什么？</h3><p>（1）线程安全：ConcurrenrHashMap是线程安全的，HashMap是非线程安全的；</p>
<p>（2）HashMap的键值对允许有null，但是ConcurrentHashMap都不允许。</p>
<h3 id="18、HashTable和ConcurrentHashMap的区别是什么？"><a href="#18、HashTable和ConcurrentHashMap的区别是什么？" class="headerlink" title="18、HashTable和ConcurrentHashMap的区别是什么？"></a>18、HashTable和ConcurrentHashMap的区别是什么？</h3><p>（1）底层数据结构：ConcurrenrHashMap在JDK1.7 之前采用的是分段的数组+链表，JDK1.8之后采用的是数据+链表/红黑树；而HashTable在JDK1.8之前都是采用的数组+链表的形式，数组采用的是HashMap的主体，链表主要是为了解决哈希冲突而存在的；</p>
<p>（2）实现线程安全的方式：① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；②Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p>
<h3 id="19、为什么重写equals方法的时候需要重写hashCode方法？使用HashMap举个例子不？"><a href="#19、为什么重写equals方法的时候需要重写hashCode方法？使用HashMap举个例子不？" class="headerlink" title="19、为什么重写equals方法的时候需要重写hashCode方法？使用HashMap举个例子不？"></a>19、为什么重写equals方法的时候需要重写hashCode方法？使用HashMap举个例子不？</h3><p>因为在java中，所有的对象都是继承于Object类。Ojbect类中有两个方法equals、hashCode，这两个方法都是用来比较两个对象是否相等的。</p>
<p>在未重写equals方法我们是继承了object的equals方法，那里的 equals是比较两个对象的内存地址，显然我们new了2个对象内存地址肯定不一样</p>
<p>对于值对象，==比较的是两个对象的值<br>对于引用对象，比较的是两个对象的地址</p>
<p>在HashMap中是通过key的hashCode去寻找元素索引下标index的，加入某个index为2的是一个链表，我们去get的时候是根据key去hash然后计算出index，重写了equals方法后，去找链表中的元素的时候是找不到的，因此我们重写了equals方法建议一定要重写hashCode方法，以此保证相同的对象返回相同的hash值，不同的对象返回不同的值，不然一个链表的hashCode都一样的，就乱套了。</p>
<h3 id="20、为什么HashTable不允许键值为null？"><a href="#20、为什么HashTable不允许键值为null？" class="headerlink" title="20、为什么HashTable不允许键值为null？"></a>20、为什么HashTable不允许键值为null？</h3><p>因为Hashtable使用的是安全失败机制（fail-safe），这种机制会使你此次读到的数据不一定是最新的数据。如果你使用的是null，就会使你无法判断对应的key是不存在还是为空，因为你无法再调用一次contain(key)来对key是否存在进行判断，ConcurrentHashMap同理。</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="1、什么是泛型？"><a href="#1、什么是泛型？" class="headerlink" title="1、什么是泛型？"></a>1、什么是泛型？</h2><ul>
<li>Java泛型设计规则：只要在编译期间没有出现警告，那么运行期间就不会出现ClassCastException异常；</li>
<li>泛型：把类型明确的工作推迟到创建对象或者是调用方法的时候才去明确的特殊的类型。</li>
</ul>
<p>参数化类型：</p>
<ul>
<li>把类型当做是参数一样进行传递；</li>
<li>&lt;数据类型&gt;只能是引用类型；</li>
</ul>
<p>相关术语</p>
<ul>
<li>ArrayList<E>中的E称为类型参数变量；</li>
<li>ArrayList<Integer>中的Integer称为实际类型参数；</li>
<li>整个ArrayList<E>称为泛型类型；</li>
<li>整个ArrayList<Integer>称为参数化的类型ParaneterizedType；</li>
</ul>
<h2 id="2、为什么需要泛型"><a href="#2、为什么需要泛型" class="headerlink" title="2、为什么需要泛型"></a>2、为什么需要泛型</h2><ul>
<li><p>没有泛型的时候：<br>Collection、Map集合对元素的类型是没有任何限制的，假设一个Collection集合中装载的全是一个Person对象，但是外面把Pig对象存储也到集合中，这个样是没有任何语法错误的，但是把对象扔进集合中，集合是不知道元素的类型是什么样的，仅仅知道是Object类型的，因此使用get()的时候，返回的是Object。获取该对象的时候还需要进行强制类型转换。</p>
</li>
<li><p>有泛型以后：<br>限制了存储对象的类型，代码变得更加简洁，因为获取元素的时候不需要进行强制类型转换了；<br>程序更加健壮，因为只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常；<br>代码的可读性和稳定性更强，因为载编写集合的时候就限制的类型。</p>
</li>
</ul>
<h3 id="2-1-有了泛型后使用增强for遍历集合"><a href="#2-1-有了泛型后使用增强for遍历集合" class="headerlink" title="2.1 有了泛型后使用增强for遍历集合"></a>2.1 有了泛型后使用增强for遍历集合</h3><p>由于我们在创建集合的时候，明确了集合的类型，因此我们可以使用增强for来遍历集合<br> //创建一个集合对象<br>ArrayList<String> list = new ArrayList&lt;&gt;();</p>
<p>list.add(“hello”);<br>list.add(“world”);<br>list.add(“oldou”);</p>
<p>//由于明确了类型.我们可以增强for进行遍历<br>for (String str : list) {<br>    System.out.println(str);<br>}</p>
<h2 id="3、泛型的用法"><a href="#3、泛型的用法" class="headerlink" title="3、泛型的用法"></a>3、泛型的用法</h2><h3 id="3-1-泛型类"><a href="#3-1-泛型类" class="headerlink" title="3.1 泛型类"></a>3.1 泛型类</h3><ul>
<li>定义：将泛型定义在类上就是泛型类，载使用该类的时候，类型才能确定下来。</li>
<li>优点：当用户明切了类型，这个类就代表着什么类型，就不用再担心强转以及运行时转化异常的问题了。<br>泛型定义代码示例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">1:把泛型定义在类上</span><br><span class="line">2:类型变量定义在类上,方法中也可以使用</span><br><span class="line">*&#x2F;</span><br><span class="line">public class ObjectTool&lt;T&gt; &#123;</span><br><span class="line">    private T obj;</span><br><span class="line"></span><br><span class="line">    public T getObj() &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setObj(T obj) &#123;</span><br><span class="line">        this.obj &#x3D; obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当用户想要使用哪种类型的时候，就在创建的时候指定类型，使用的时候该类就会自动转换成用户想要的使用类型。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;创建对象并指定元素类型</span><br><span class="line">    ObjectTool&lt;String&gt; tool &#x3D; new ObjectTool&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    tool.setObj(new String(&quot;钟福成&quot;));</span><br><span class="line">    String s &#x3D; tool.getObj();</span><br><span class="line">    System.out.println(s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建对象并指定元素类型</span><br><span class="line">    ObjectTool&lt;Integer&gt; objectTool &#x3D; new ObjectTool&lt;&gt;();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 如果我在这个对象里传入的是String类型的,它在编译时期就通过不了了.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    objectTool.setObj(10);</span><br><span class="line">    int i &#x3D; objectTool.getObj();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-泛型方法"><a href="#3-2-泛型方法" class="headerlink" title="3.2 泛型方法"></a>3.2 泛型方法</h3>将泛型定义在方法上就叫泛型方法，泛型是先定义后使用的，泛型方法定义如下所示：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义泛型方法..</span><br><span class="line">public &lt;T&gt; void show(T t) &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">&#125;</span><br><span class="line">使用时传递进来的是什么类型，返回值就是什么类型的。</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;创建对象</span><br><span class="line">    ObjectTool tool &#x3D; new ObjectTool();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;调用方法,传入的参数是什么类型,返回值就是什么类型</span><br><span class="line">    tool.show(&quot;hello&quot;);</span><br><span class="line">    tool.show(12);</span><br><span class="line">    tool.show(12.5);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
泛型类时拥有泛型这个特性的类，由于它本质上还是一个Java类，所以它是可以被继承的。<br>而被继承分为两种情况：</li>
<li>子类明切泛型类的类型参数变量</li>
<li>子类不明切泛型类的类型参数变量</li>
</ul>
<p>（1）子类明切泛型类的类型参数变量</p>
<ul>
<li>泛型接口<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    把泛型定义在接口上</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface Inter&lt;T&gt; &#123;</span><br><span class="line">public abstract void show(T t);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>泛型接口的实现类<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 子类明确泛型类的类型参数变量:</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public class InterImpl implements Inter&lt;String&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show(String s) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
（2）子类不明确泛型类的类型参数变量</li>
<li>当子类不明切泛型类的类型参数变量时，外界使用子类的时候，需要传递类型参数变量进来，在实现类上需要定义处类型参数变量。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 子类不明确泛型类的类型参数变量:</span><br><span class="line"> *      实现类也要定义出&lt;T&gt;类型的</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class InterImpl&lt;T&gt; implements Inter&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void show(T t) &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;测试第一种情况</span><br><span class="line">    &#x2F;&#x2F;Inter&lt;String&gt; i &#x3D; new InterImpl();</span><br><span class="line">    &#x2F;&#x2F;i.show(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;第二种情况测试</span><br><span class="line">    Inter&lt;String&gt; ii &#x3D; new InterImpl&lt;&gt;();</span><br><span class="line">    ii.show(&quot;100&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
需要注意的是：</li>
<li>实现类重写父类的方法时，返回值的类型要和父类一致。</li>
<li>类上生命的泛型追非静态成员有效。</li>
</ul>
<h3 id="3-3-通配符？"><a href="#3-3-通配符？" class="headerlink" title="3.3 通配符？"></a>3.3 通配符？</h3><p>除了使用<T>表示泛型外，还有&lt;?&gt;这种形式，而？就被称为通配符。      </p>
<ul>
<li>通配符的出现时喂了指定泛型中的类型范围。<br>通配符有一下三种形式：</li>
<li>&lt;?&gt;  被称为无限定通配符；</li>
<li>&lt;? extends T&gt; 被称为有上限通配符；</li>
<li>&lt;? super T&gt; 被称为又下限通配符；</li>
</ul>
<h3 id="3-4-类型擦除"><a href="#3-4-类型擦除" class="headerlink" title="3.4 类型擦除"></a>3.4 类型擦除</h3><p>泛型时Java1.5版本才引进的概念，在此之前是没有泛型的概念的，但显然泛型代码能够很好的和之前版本的代码兼容，这是因为泛型信息只存在于代码的编译阶段，在进入JVM之前，与泛型想改的信息都会被擦除掉，这就叫做类型擦除。</p>
<p>首先来个小题目：<br>（1）判断一下以下代码的输出情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; l1 &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; l2 &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">           </span><br><span class="line">System.out.println(l1.getClass() &#x3D;&#x3D; l2.getClass());</span><br></pre></td></tr></table></figure>
<p>输出结果为true，这是因为List<String>和List<Integer>在JVM中的Class都是List.class，泛型的类型被擦除了。<br>（2）类型String和Integer去哪了呢？<br>是由于泛型转译</p>
<h3 id="3-5-泛型中需要注意的地方"><a href="#3-5-泛型中需要注意的地方" class="headerlink" title="3.5 泛型中需要注意的地方"></a>3.5 泛型中需要注意的地方</h3><ul>
<li><p>泛型类或泛型方法中是不能直接使用8种基本的数据类型的，而是使用它们的包装类；<br>例如：List<Integer> list = new ArrayList&lt;&gt;();</p>
</li>
<li><p>Java中不能创建具体类型的泛型数组</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java容器</category>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Java容器</tag>
      </tags>
  </entry>
</search>
