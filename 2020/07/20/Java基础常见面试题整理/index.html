<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java基础常见面试题 | Mr.ou`s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1、JDK和JRE有什么区别？JDK就是Java Development Kit 。JDK是面向开发人员使用的SDK，它提供了Java的开发环境和运行环境。SDK是Software Development Kit 一般指软件开发包，可以包括函数库、编译程序等。 JRE是Java Runtime Enviroment是指Java的运行环境，是面向Java程序的使用者，而不是开发者。 2、&#x3D;&#x3D; 和 e">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础常见面试题">
<meta property="og:url" content="http://example.com/2020/07/20/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="Mr.ou&#96;s Blog">
<meta property="og:description" content="1、JDK和JRE有什么区别？JDK就是Java Development Kit 。JDK是面向开发人员使用的SDK，它提供了Java的开发环境和运行环境。SDK是Software Development Kit 一般指软件开发包，可以包括函数库、编译程序等。 JRE是Java Runtime Enviroment是指Java的运行环境，是面向Java程序的使用者，而不是开发者。 2、&#x3D;&#x3D; 和 e">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-07-20T12:38:40.000Z">
<meta property="article:modified_time" content="2020-07-20T15:05:31.882Z">
<meta property="article:author" content="Mr.ou">
<meta property="article:tag" content="面试题">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Mr.ou`s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mr.ou`s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java基础常见面试题整理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/20/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" class="article-date">
  <time datetime="2020-07-20T12:38:40.000Z" itemprop="datePublished">2020-07-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>►<a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java基础常见面试题
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1、JDK和JRE有什么区别？"><a href="#1、JDK和JRE有什么区别？" class="headerlink" title="1、JDK和JRE有什么区别？"></a>1、JDK和JRE有什么区别？</h1><p>JDK就是Java Development Kit 。JDK是面向开发人员使用的SDK，它提供了Java的开发环境和运行环境。SDK是Software Development Kit 一般指软件开发包，可以包括函数库、编译程序等。</p>
<p>JRE是Java Runtime Enviroment是指Java的运行环境，是面向Java程序的使用者，而不是开发者。</p>
<h1 id="2、-和-equals-的区别是什么？"><a href="#2、-和-equals-的区别是什么？" class="headerlink" title="2、== 和 equals 的区别是什么？"></a>2、== 和 equals 的区别是什么？</h1><p>（1）== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。<br>(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)</p>
<p>（2）equals() : 它的作用也是判断两个对象是否相等。<br>但它一般有两种使用情况：<br>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</p>
<p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p>
<h1 id="3、两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#3、两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="3、两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？"></a>3、两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</h1><p>如果两个对象相等，则hashcode一定也是相同的</p>
<p>两个对象相等，对两个对象分别调用equals方法都返回true</p>
<p>两个对象有相同的hashcode值，它们也不一定是相等的</p>
<p>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</p>
<p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
<h1 id="4、final-在-java-中有什么作用？"><a href="#4、final-在-java-中有什么作用？" class="headerlink" title="4、final 在 java 中有什么作用？"></a>4、final 在 java 中有什么作用？</h1><p>用于修饰类、属性和方法；</p>
<p>被final修饰的类不可以被继承<br>被final修饰的方法不可以被重写<br>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</p>
<h1 id="5、java-中的-Math-round-1-5-等于多少？-Math-round-1-5-等于多少？"><a href="#5、java-中的-Math-round-1-5-等于多少？-Math-round-1-5-等于多少？" class="headerlink" title="5、java 中的 Math.round(1.5) 等于多少？ Math.round(-1.5) 等于多少？"></a>5、java 中的 Math.round(1.5) 等于多少？ Math.round(-1.5) 等于多少？</h1><p>Math.round(1.5)等于2，Math.round(-1.5)等于-1，四舍五入是在原来的基础上加上0.5向下取整。</p>
<h1 id="6、说出以下代码的输出结果。"><a href="#6、说出以下代码的输出结果。" class="headerlink" title="6、说出以下代码的输出结果。"></a>6、说出以下代码的输出结果。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> public class A &#123;</span><br><span class="line">   static&#123;</span><br><span class="line">      System.out.println(&quot;static in class A&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public A()&#123;</span><br><span class="line">      System.out.println(&quot;class A&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> public class SubA extends A &#123;</span><br><span class="line">   static &#123;</span><br><span class="line">      System.out.println(&quot;static in class SubA&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public SubA() &#123;</span><br><span class="line">      super();</span><br><span class="line">      System.out.println(&quot;class SubA&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public SubA(String sa) &#123;</span><br><span class="line">      System.out.println(&quot;class SubA &quot; + sa);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> public class StaticTest &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      SubA subA1 &#x3D; new SubA(&quot;111111&quot;);</span><br><span class="line">      SubA subA2 &#x3D; new SubA(&quot;222222&quot;);</span><br><span class="line">      SubA subA3 &#x3D; new SubA(&quot;333333&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输出结果为：</span><br><span class="line"> static in class A</span><br><span class="line">static in class SubA</span><br><span class="line">class A</span><br><span class="line">class SubA 111111</span><br><span class="line">class A</span><br><span class="line">class SubA 222222</span><br><span class="line">class A</span><br><span class="line">class SubA 333333</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong><br>子类构造方法调用规则：<br>（1）如果子类的构造方法中没有通过 super 显式调用父类的有参构造方法，<br>        也没有通过 this 显式调用自身的其他构造方法，则系统会默认先调用父类的无参构造方法。<br>        这种情况下，写不写 super(); 语句，效果是一样的<br>（2）如果子类的构造方法中通过 super 显式调用父类的有参构造方法，<br>         将执行父类相应的构造方法，不执行父类无参构造方法<br>（3）如果子类的构造方法中通过 this 显式调用自身的其他构造方法，将执行类中相应的构造方法<br>（4）如果存在多级继承关系，在创建一个子类对象时，以上规则会多次向更高一级父类应用，<br>         一直到执行顶级父类 Object 类的无参构造方法为止<br><strong>结论：</strong><br>类的实例化方法调用顺序：<br>类加载器实例化时进行的操作步骤：加载 -&gt; 连接 -&gt; 初始化<br>（1）父类静态代变量<br>（2）父类静态代码块<br>（3）子类静态变量<br>（4）子类静态代码块<br>（5）父类非静态变量（父类实例成员变量）<br>（6）父类构造函数<br>（7）子类非静态变量（子类实例成员变量）<br>（8）子类构造函数</p>
<h1 id="7、Java中，基本的数据类型有哪些？"><a href="#7、Java中，基本的数据类型有哪些？" class="headerlink" title="7、Java中，基本的数据类型有哪些？"></a>7、Java中，基本的数据类型有哪些？</h1><p>基本数据类型有byte、short、int、long、float、double、char、boolean八种基本数据类型。<br>byte：1个字节，8位<br>short：2个字节，16位<br>int：4个字节，32位<br>long：8个字节，64位<br>float：4个字节，32位<br>double：8个字节，64位<br>boolean：逻辑上理解是占用 1位，但是实际中会考虑计算机高效存储因素<br>char：2个字节，16位</p>
<h1 id="8、String-属于基础的数据类型吗？"><a href="#8、String-属于基础的数据类型吗？" class="headerlink" title="8、String 属于基础的数据类型吗？"></a>8、String 属于基础的数据类型吗？</h1><p>不属于，Java中基本数据类型只有byte、short、int、long、float、double、char、boolean八种数据类型。<br>String在Java中属于对象，底层实现是char数组，使用final修饰。</p>
<h1 id="9、switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上？"><a href="#9、switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上？" class="headerlink" title="9、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？"></a>9、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？</h1><p>在Java5以前，switch(expr)中的expr只能是byte、char、short、int四种数据类型。从Java5以后引入了枚举，expr可以是enum类型，Java7开始，expr就可以支持String字符串了，但是目前还不能使用long类型的。</p>
<h1 id="10、java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#10、java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="10、java 中操作字符串都有哪些类？它们之间有什么区别？"></a>10、java 中操作字符串都有哪些类？它们之间有什么区别？</h1><p>Java中操作字符串的类有String、StringBuffer、StringBuilder三个类。<br><strong>三者的相同点：</strong><br>（1）都可以存储和操作字符串；<br>（2）底层都使用了final修饰，不能被继承。<br>（3）提供了API相似。<br><strong>三者的区别：</strong><br>（1）String是不可变字符序列，String内容是不能被改变的；<br>（2）StringBuffer和StringBuilder是可变字符序列，他们都可以对字符串内容进行修改，<br>   并且修改之后的内存地址不会发生改变；<br>（3）StringBuilder是JDK1.5的，效率高，但是它的线程不安全，<br>          StringBuffer是JDK1.0的，效率低，但是它是线程安全的(方法加了Synchronized)。</p>
<p><strong>对于三者使用的总结</strong></p>
<p>如果要操作少量的数据用 = String</p>
<p>单线程操作字符串缓冲区 下操作大量数据 = StringBuilder</p>
<p>多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</p>
<h1 id="11、String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#11、String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="11、String str=”i”与 String str=new String(“i”)一样吗？"></a>11、String str=”i”与 String str=new String(“i”)一样吗？</h1><p>不一样，因为内存的分配方式不一样，String str = “i”的方式，Java虚拟机会将其分配到常量池中；而String str = new String(“i”) 则会被分配到堆内存中。</p>
<p>提问：String s = new String(“abc”)创建了几个对象呢？<br>答案是两个对象，一个是静态区的”abc”，另外一个是用new创建在堆上的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str1 &#x3D; &quot;hello&quot;; &#x2F;&#x2F;str1指向静态区</span><br><span class="line">String str2 &#x3D; new String(&quot;hello&quot;);  &#x2F;&#x2F;str2指向堆上的对象</span><br><span class="line">String str3 &#x3D; &quot;hello&quot;;</span><br><span class="line">String str4 &#x3D; new String(&quot;hello&quot;);</span><br><span class="line">System.out.println(str1.equals(str2)); &#x2F;&#x2F;true</span><br><span class="line">System.out.println(str2.equals(str4)); &#x2F;&#x2F;true</span><br><span class="line">System.out.println(str1 &#x3D;&#x3D; str3); &#x2F;&#x2F;true</span><br><span class="line">System.out.println(str1 &#x3D;&#x3D; str2); &#x2F;&#x2F;false</span><br><span class="line">System.out.println(str2 &#x3D;&#x3D; str4); &#x2F;&#x2F;false</span><br><span class="line">System.out.println(str2 &#x3D;&#x3D; &quot;hello&quot;); &#x2F;&#x2F;false</span><br><span class="line">str2 &#x3D; str1;</span><br><span class="line">System.out.println(str2 &#x3D;&#x3D; &quot;hello&quot;); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
<h1 id="13、如何将字符串反转？"><a href="#13、如何将字符串反转？" class="headerlink" title="13、如何将字符串反转？"></a>13、如何将字符串反转？</h1><p>使用StringBuffer或者StringBuilder中的reverse()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; StringBuffer reverse</span><br><span class="line"> StringBuffer stringBuffer &#x3D; new StringBuffer();</span><br><span class="line"> stringBuffer. append(&quot;abcdefg&quot;);</span><br><span class="line"> System. out. println(stringBuffer. reverse()); &#x2F;&#x2F; gfedcba</span><br><span class="line">&#x2F;&#x2F; StringBuilder reverse</span><br><span class="line"> StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line"> stringBuilder. append(&quot;abcdefg&quot;);</span><br><span class="line"> System. out. println(stringBuilder. reverse()); &#x2F;&#x2F; gfedcba</span><br></pre></td></tr></table></figure>
<h1 id="14、String-类的常用方法都有那些？"><a href="#14、String-类的常用方法都有那些？" class="headerlink" title="14、String 类的常用方法都有那些？"></a>14、String 类的常用方法都有那些？</h1><p>（1）String 类的常用方法都有那些？<br>（2）indexOf()：返回指定字符的索引。<br>（3）charAt()：返回指定索引处的字符。<br>（4）replace()：字符串替换。<br>（5）trim()：去除字符串两端空白。<br>（6）split()：分割字符串，返回一个分割后的字符串数组。<br>（7）getBytes()：返回字符串的 byte 类型数组。<br>（8）length()：返回字符串长度。<br>（9）toLowerCase()：将字符串转成小写字母。<br>（10）toUpperCase()：将字符串转成大写字符。<br>（11）substring()：截取字符串。<br>（12）equals()：字符串比较。</p>
<h1 id="15、HashMap中使用String做key有什么好处？"><a href="#15、HashMap中使用String做key有什么好处？" class="headerlink" title="15、HashMap中使用String做key有什么好处？"></a>15、HashMap中使用String做key有什么好处？</h1><pre><code>    HashMap内部实现是通过key的hashcode来确定value的存储位置，因为字符串是不可变的，并且使用字符串时会在字符串常量池中进行缓存，所以当创建字符串的时候，hashcode会被缓存下来，不需要再次计算，所以相比于其他对象来说快一些。</code></pre>
<h1 id="16、抽象类必须要有抽象方法吗？"><a href="#16、抽象类必须要有抽象方法吗？" class="headerlink" title="16、抽象类必须要有抽象方法吗？"></a>16、抽象类必须要有抽象方法吗？</h1><p>抽象类不一定要有抽象方法，但是抽象方法必要要有抽象类。</p>
<h1 id="17、普通类和抽象类有哪些区别？"><a href="#17、普通类和抽象类有哪些区别？" class="headerlink" title="17、普通类和抽象类有哪些区别？"></a>17、普通类和抽象类有哪些区别？</h1><p>（1）抽象类不能被实例化；<br>（2）抽象类可以有抽象方法，但是普通类没有；<br>（3）含有抽象方法的类必须是抽象类；<br>（4）抽象方法不能被声明为静态；<br>（5）抽象方法不能被private；<br>（6）抽象方法不能被final修饰。</p>
<h1 id="18、抽象类能使用-final-修饰吗？"><a href="#18、抽象类能使用-final-修饰吗？" class="headerlink" title="18、抽象类能使用 final 修饰吗？"></a>18、抽象类能使用 final 修饰吗？</h1><p>不能，因为被final修饰的类不能被继承，而定义抽象类就是为了让其他类去继承的，如果使用final修饰了就矛盾了，因此不能被final修饰。</p>
<h1 id="19、接口和抽象类有什么区别？"><a href="#19、接口和抽象类有什么区别？" class="headerlink" title="19、接口和抽象类有什么区别？"></a>19、接口和抽象类有什么区别？</h1><p>（1）实现：抽象类的子类使用extends来继承，而接口就必须使用implements来实现接口；<br>（2）构造函数：抽象类可以有构造函数，但是接口没有；<br>（3）实现数量：类可以实现很多个接口，但是只能继承一个抽象类；<br>（4）访问修饰符：接口的方法默认使用的是public修饰，而抽象类中的方法可以是任意访问修饰符；</p>
<h1 id="20、内部类有哪几种？详细说明一下。"><a href="#20、内部类有哪几种？详细说明一下。" class="headerlink" title="20、内部类有哪几种？详细说明一下。"></a>20、内部类有哪几种？详细说明一下。</h1><p>内部类的定义：可以将一个类的定义放在另外一个类的定义内部；<br>内部类的种类：成员内部类、局部内部类、匿名内部类、静态内部类。</p>
<p>（1）静态内部类：定义在类内部的静态类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line"></span><br><span class="line">   private static int radius &#x3D; 1;</span><br><span class="line"></span><br><span class="line">   static class StaticInner &#123;</span><br><span class="line">      public void visit() &#123;</span><br><span class="line">         System.out.println(&quot;visit outer static  variable:&quot; + radius);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，new 外部类.静态内部类()，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> Outer.StaticInner inner &#x3D; new Outer.StaticInner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure>
<p>（2）成员内部类：定义在类内部，成员位置上的非静态类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> public class Outer &#123;</span><br><span class="line"></span><br><span class="line">   private static  int radius &#x3D; 1;</span><br><span class="line">   private int count &#x3D;2;</span><br><span class="line"></span><br><span class="line">   class Inner &#123;</span><br><span class="line">      public void visit() &#123;</span><br><span class="line">         System.out.println(&quot;visit outer static  variable:&quot; + radius);</span><br><span class="line">         System.out.println(&quot;visit outer   variable:&quot; + count);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式外部类实例.new 内部类()，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> Outer outer &#x3D; new Outer();</span><br><span class="line">Outer.Inner inner &#x3D; outer.new Inner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure>
<p>（3）局部内部类：定义在方法的内部，就是局部内部类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> public class Outer &#123;</span><br><span class="line"></span><br><span class="line">   private  int out_a &#x3D; 1;</span><br><span class="line">   private static int STATIC_b &#x3D; 2;</span><br><span class="line"></span><br><span class="line">   public void testFunctionClass()&#123;</span><br><span class="line">      int inner_c &#x3D;3;</span><br><span class="line">      class Inner &#123;</span><br><span class="line">         private void fun()&#123;</span><br><span class="line">            System.out.println(out_a);</span><br><span class="line">            System.out.println(STATIC_b);</span><br><span class="line">            System.out.println(inner_c);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Inner  inner &#x3D; new Inner();</span><br><span class="line">      inner.fun();</span><br><span class="line">   &#125;</span><br><span class="line">   public static void testStaticFunctionClass()&#123;</span><br><span class="line">      int d &#x3D;3;</span><br><span class="line">      class Inner &#123;</span><br><span class="line">         private void fun()&#123;</span><br><span class="line">            &#x2F;&#x2F; System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量</span><br><span class="line">            System.out.println(STATIC_b);</span><br><span class="line">            System.out.println(d);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Inner  inner &#x3D; new Inner();</span><br><span class="line">      inner.fun();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，new 内部类()，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> public static void testStaticFunctionClass()&#123;</span><br><span class="line">   class Inner &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   Inner  inner &#x3D; new Inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）匿名内部类：没有名字的内部类，日常开发中使用的比较多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> public class Outer &#123;</span><br><span class="line"></span><br><span class="line">   private void test(final int i) &#123;</span><br><span class="line">      new Service() &#123;</span><br><span class="line">         public void method() &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">               System.out.println(&quot;匿名内部类&quot; );</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;.method();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;匿名内部类必须继承或实现一个已有的接口 </span><br><span class="line">interface Service&#123;</span><br><span class="line">   void method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了没有名字，<strong>匿名内部类还有以下特点：</strong><br>A、匿名内部类必须继承一个抽象类或者实现一个接口。<br>B、匿名内部类不能定义任何静态成员和静态方法。<br>C、当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。<br>D、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">匿名内部类创建方式：</span><br><span class="line"> new 类&#x2F;接口&#123;</span><br><span class="line">      &#x2F;&#x2F;匿名内部类实现部分</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h1 id="21、内部类有哪些使用场景？你在哪些地方使用到了内部类？"><a href="#21、内部类有哪些使用场景？你在哪些地方使用到了内部类？" class="headerlink" title="21、内部类有哪些使用场景？你在哪些地方使用到了内部类？"></a>21、内部类有哪些使用场景？你在哪些地方使用到了内部类？</h1><p>（1）在设计模式中使用静态内部类实现单例模式；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonDemo03 &#123;</span><br><span class="line"></span><br><span class="line">    private static class SingletonClassInstance&#123;</span><br><span class="line">        private static final SingletonDemo03 instance &#x3D; new SingletonDemo03();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonDemo03 getInstance()&#123;</span><br><span class="line">        return SingletonClassInstance.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SingletonDemo03()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）其他的忘记了，，，等记得来的时候再补上0.0</p>
<h1 id="22、Files的常用方法都有哪些？"><a href="#22、Files的常用方法都有哪些？" class="headerlink" title="22、Files的常用方法都有哪些？"></a>22、Files的常用方法都有哪些？</h1><p>（1）Files. exists()：检测文件路径是否存在。<br>（2）Files. createFile()：创建文件。<br>（3）Files. createDirectory()：创建文件夹。<br>（4）Files. delete()：删除一个文件或目录。<br>（5）Files. copy()：复制文件。<br>（6）Files. move()：移动文件。<br>（7）Files. size()：查看文件个数。<br>（8）Files. read()：读取文件。<br>（9）Files. write()：写入文件。</p>
<h1 id="23、Date类常用方法都有哪些？"><a href="#23、Date类常用方法都有哪些？" class="headerlink" title="23、Date类常用方法都有哪些？"></a>23、Date类常用方法都有哪些？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">-----日期类型如何格式化？</span><br><span class="line">      ***************************************************************************************</span><br><span class="line">      DateFormat  sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line">      String s &#x3D; sdf.format(new Date());&#x2F;&#x2F;日期转字符串</span><br><span class="line">      ***************************************************************************************</span><br><span class="line">      -----字符串如何转日期？</span><br><span class="line">      ***************************************************************************************</span><br><span class="line">      DateFormat  sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line">      String s &#x3D; &quot;2019-10-31 22:53:10&quot;;</span><br><span class="line">      Date date &#x3D; sdf.parse(s);</span><br><span class="line">      ***************************************************************************************</span><br><span class="line">      -----如何取得当前年、月、日、时、分、秒、毫秒？</span><br><span class="line">      年：Calendar.getInstance().get(Calendar.YEAR)；</span><br><span class="line">      或者Year.now()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line">      还有LocalDate.now().getYear();&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line"></span><br><span class="line">      月：Calendar.getInstance().get(Calendar.MONTH)+1；</span><br><span class="line">      MonthDay.now().getMonthValue()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line">      LocalDate.now().getMonthValue()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line"></span><br><span class="line">      日：Calendar.getInstance().get(Calendar.DAY_OF_MONTH)；</span><br><span class="line">      MonthDay.now().getDayOfMonth()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line">      LocalDate.now().getDayOfMonth()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line"></span><br><span class="line">      时：Calendar.getInstance().get(Calendar.HOUR_OF_DAY)；</span><br><span class="line">      LocalTime.now().getHour()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line"></span><br><span class="line">      分：Calendar.getInstance().get(Calendar.MINUTE)；</span><br><span class="line">      LocalTime.now().getMinute()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line"></span><br><span class="line">      秒：Calendar.getInstance().get(Calendar.SECOND)；</span><br><span class="line">      LocalTime.now().getSecond()；&#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line"></span><br><span class="line">      毫秒：Calendar.getInstance().get(Calendar.MILLISECOND)；</span><br><span class="line">      ***************************************************************************************</span><br><span class="line">--如何取得从1970年1月1日0时0分0秒到现在的毫秒数？</span><br><span class="line">      System.currentTimeMillis();</span><br><span class="line">      Calendar.getInstance().getTimeInMillis();</span><br><span class="line">--如何格式化日期？</span><br><span class="line">      new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date())；</span><br><span class="line">      &#x2F;&#x2F;JDK 1.8 java.time 包</span><br><span class="line">      LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;))；</span><br></pre></td></tr></table></figure>


<h1 id="24、java-中-IO-流分为几种？"><a href="#24、java-中-IO-流分为几种？" class="headerlink" title="24、java 中 IO 流分为几种？"></a>24、java 中 IO 流分为几种？</h1><p>（1）按照流向可以分为输入流和输出流；<br>（2）按照操作单元划分可以分为字节流和字符流；<br>（3）按照流的角色划分可分为节点流和处理流；</p>
<h1 id="25、BIO、NIO、AIO-有什么区别？"><a href="#25、BIO、NIO、AIO-有什么区别？" class="headerlink" title="25、BIO、NIO、AIO 有什么区别？"></a>25、BIO、NIO、AIO 有什么区别？</h1><p><strong>简答：</strong></p>
<p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>
<p><strong>详细回答：</strong></p>
<p>BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p>
<p>NIO (New I/O): NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。</p>
<p>AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/20/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" data-id="ckf1w6tua0034w8uka25o8biv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/07/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BRedis%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARedis%E4%BB%8B%E7%BB%8D%E3%80%81%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Redis学习笔记
        
      </div>
    </a>
  
  
    <a href="/2020/07/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BZookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AZookeeper%E7%AE%80%E4%BB%8B%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E3%80%81%E7%9B%91%E5%90%AC%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E3%80%81%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E5%AE%89%E8%A3%85/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">学习笔记之Zookeeper学习（二）：Zookeeper集群的安装、启动关闭脚本的编写、常用命令介绍</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%AE%B9%E5%99%A8/">Java容器</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%AE%B9%E5%99%A8/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/TCP-IP/">TCP/IP</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/TCP-IP/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Zookeeper/">Zookeeper</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Zookeeper/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Zookeeper/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">个人博客</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/">消息中间件</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%AE%B9%E5%99%A8/" rel="tag">Java容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E5%AD%A6%E4%B9%A0/" rel="tag">Linux学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ%E5%AD%A6%E4%B9%A0/" rel="tag">RabbitMQ学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis%E5%AD%A6%E4%B9%A0/" rel="tag">Redis学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring%E5%AD%A6%E4%B9%A0/" rel="tag">Spring学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/" rel="tag">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zookeeper%E5%AD%A6%E4%B9%A0/" rel="tag">Zookeeper学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" rel="tag">个人博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" rel="tag">经验分享</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">Java基础</a> <a href="/tags/Java%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">Java容器</a> <a href="/tags/Linux%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">Linux学习</a> <a href="/tags/RabbitMQ%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">RabbitMQ学习</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Redis%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">Redis学习</a> <a href="/tags/SpringBoot/" style="font-size: 12.5px;">SpringBoot</a> <a href="/tags/Spring%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">Spring学习</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/tags/Zookeeper%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">Zookeeper学习</a> <a href="/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" style="font-size: 10px;">个人博客</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">学习笔记</a> <a href="/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" style="font-size: 10px;">经验分享</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 12.5px;">设计模式</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 17.5px;">面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/09/09/SpringBoot%E4%B8%AD%E4%BD%BF%E7%94%A8Druid%E6%95%B4%E5%90%88JDBC/">SpringBoot整合JDBC</a>
          </li>
        
          <li>
            <a href="/2020/09/08/%E7%AC%AC%E4%B8%80%E4%B8%AASpringBoot%E7%A8%8B%E5%BA%8F%E4%BB%A5%E5%8F%8A%E5%B0%8F%E5%BD%A9%E8%9B%8B/">第一个SpringBoot程序以及启动图标设置</a>
          </li>
        
          <li>
            <a href="/2020/08/16/Redis%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81/">Redis基本事务以及实现乐观锁</a>
          </li>
        
          <li>
            <a href="/2020/08/16/Redis%E7%9A%84%E4%BA%94%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/">Redis的数据类型（5种基础，3种特殊）</a>
          </li>
        
          <li>
            <a href="/2020/08/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BRedis%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D%E3%80%81%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E3%80%81%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/">Redis的常用命令、配置文件介绍、数据持久化方式、集群搭建</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Mr.ou<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>